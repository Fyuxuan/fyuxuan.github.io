<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>（三）Kubernetes 之 pod</title>
      <link href="/k8s3/"/>
      <url>/k8s3/</url>
      
        <content type="html"><![CDATA[<p>pod 是一组并置的容器，代表了 Kubernetes 中的基本构建模块。在实际应用中我们并不会单独部署容器，更多的是针对一组 pod 的容器进行部署和操作。然而这并不意味着一个 pod 总是要包含多个容器，实际上只包含一个单独容器的 pod 也是非常常见的。值得注意的是，当一个 pod 包含多个容器时，这些容器总是运行于同一个工作节点上，一个 pod 绝不会跨越多个工作节点。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670631091472.jpg" alt="-w688"></p><p>在包含容器的 pod 下，我们可以同时运行一些密切相关的进程，并为它们提供几乎相同的环境，此时这些进程就好像全部运行于单个容器中一样，同时又保持着一定的隔离。这样一来，我们便能全面地利用容器所提供的特性，同时对这些进程来说它们就像运行在一起一样，实现两全其美 。</p><p>容器之间彼此是完全隔离的，但此时我们期望的是隔离容器组，而不是单个容器，并让每个容器组内的容器共享一些资源，而不是完全隔离。Kubernetes 通过配置 Docker 来让一个 pod 内的所有容器共享相同的 Linux 命名空间，而不是每个容器都有自己的一组命名空间。</p><p>由于一个 pod 中的所有容器都在相同的 network 和 UTS 命名空间下运行，所以它们都共享相同的主机名和网络接口。同样这些容器也都在相同的 IPC 命名空间下运行，因此能够通过 IPC 进行通信。在最新的 Kubernetes 和 Docker 版本中，它们也能够共享相同的 PID 命名空间，但是该特征默认是未激活的。</p><blockquote><p>当同一个 pod 中的容器使用单独的 PID 命名空间时，在容器中执行 ps aux 就只会看到容器自己的进程。</p></blockquote><p>但是当涉及文件系统时，情况就有所不同。由于大多数容器的文件系统来自容器镜像，因此默认情况下，每个容器的文件系统与其他容器完全隔离。但我们可 以使用 Volume 的 Kubernetes 资源来共享文件目录。</p><p>由于一个 pod 中的容器运行于相同的 Network 命名空间中，因此它们共享相同的 IP 地址和端口空间。这意味着在同－ pod 中的容器运行的多个进程需要注意不能绑定到相同的端口号，否则会导致端口冲突，但这只涉及同一 pod 中的容器。 由于每个 pod 都有独立的端口空间，对于不同 pod 中的容器来说永远不会遇到端口冲突。此外，一个 pod 中的所有容器也都具有相同的网络接口，因此容器可以通过 localhost 与同一 pod 中的其他容器进行通信。</p><p>Kubernetes 集群中的所有 pod 都在同一个共享网络地址空间中，这意味着每个 pod 都可以通过其他 pod 的 IP 地址来实现相互访问。它们之间没有 NAT（网络地址转换）网关。当两个 pod 彼此之间发送网络数据包时，它们都会将对方的实际 IP 地址看作数据包中的源 IP。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670648371662.jpg" alt="-w616"><br><img src="https://upload-images.jianshu.io/upload_images/1455014-5262ffd168735d45.jpg" alt="-w616"></p><h2 id="在-Kubernetes-中运行一个简单的-pod"><a href="#在-Kubernetes-中运行一个简单的-pod" class="headerlink" title="在 Kubernetes 中运行一个简单的 pod"></a>在 Kubernetes 中运行一个简单的 pod</h2><p>我们可以通过 kubectl run 命令， 该命令可以创建所有资源组件而无需 JSON 或 YAML 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl run yx-nginx --image=nginx  --port=80 --generator=run/v1</span><br></pre></td></tr></table></figure><ul><li>–image=nginx 指定运行的镜像</li><li>–port=80 告诉kubernetes应用正在监听80端口</li><li>–generator 一般来说不会使用它，这里使用是为了让kubernetes创建一个 ReplicationController而不是Deployment</li></ul><h3 id="列出-pod"><a href="#列出-pod" class="headerlink" title="列出 pod"></a>列出 pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   0/1     Pending   0          9m28s</span><br></pre></td></tr></table></figure><p>可以看到 pod 处于挂起状态，READY 列显示 0/1 代表 pod 的容器还未就绪。pod 还没有运行的 原因是：该 pod 被分配到的工作节点正在下载容器镜像，完成之后才可以运行。下载完成后，将创建 pod 的容器， 然后 pod 会变为运行状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   1/1     Running   0          9m28s</span><br></pre></td></tr></table></figure><p>再次列出 pod，可以发现 pod的状态已经发生改变了。</p><h3 id="查看pod详细信息"><a href="#查看pod详细信息" class="headerlink" title="查看pod详细信息"></a>查看pod详细信息</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">describe</span> pod <span class="keyword">yx</span>-nginx-2r4xf</span><br></pre></td></tr></table></figure><h2 id="使用描述文件创建-pod"><a href="#使用描述文件创建-pod" class="headerlink" title="使用描述文件创建 pod"></a>使用描述文件创建 pod</h2><p>YAML 格式的 Pod 定义文件的完整内容:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment">## 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">## 元数据 </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>  <span class="comment">## Pod 名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span> <span class="comment">## Pod 所属的命名空间 默认值为 default</span></span><br><span class="line"><span class="attr">  labels:</span> <span class="comment">## 自定义标签列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  annotations:</span> <span class="comment">## 自定义注解列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">##pod 中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span> <span class="comment">## 容器列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span> <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">string</span> <span class="comment">## 容器镜像名称</span></span><br><span class="line">    <span class="comment">## 镜像拉取策略: </span></span><br><span class="line">    <span class="comment">## Always(默认值): 表示每次都尝试重新拉取镜像。</span></span><br><span class="line">    <span class="comment">## IfNotPresent: 表示 如果本地有该镜像，则使用本地的镜像，本地不存在时拉取镜像。</span></span><br><span class="line">    <span class="comment">## Never: 表示仅使用本地镜像。</span></span><br><span class="line">    <span class="comment">## 下面几种情况系统将默认设置 imagePullPolicy=Always。</span></span><br><span class="line">    <span class="comment">## 1. 不设置 imagePullPolicy，也未指定镜像的 tag</span></span><br><span class="line">    <span class="comment">## 2. 不设置 imagePullPolicy，镜像 tag 为 latest</span></span><br><span class="line">    <span class="comment">## 3. 启用名为 AlwaysPullImages 的准入控制器（Admission Controller）</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never |IfNotPresent]</span></span><br><span class="line"><span class="string">command: [string] ## 容器的启动命令列表，如果不指定，则使用镜像打包时使用的启动命令。</span></span><br><span class="line"><span class="string">args: [string]  ## 容器的启动命令参数列表</span></span><br><span class="line"><span class="string">workingDir: string ## 容器的工作目录</span></span><br><span class="line"><span class="string">volumeMounts: ## 挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="string">- name: string ## 引用 pod 定义的共享存储卷的名称，需使用 volumes[]部分定义的共享存储卷名称</span></span><br><span class="line"><span class="string">  mountPath: string ## 存储卷在容器内 Mount 的绝对路径，应少于 512 个字符</span></span><br><span class="line"><span class="string">  readOnly: boolean ## 是否为只读模式，默认为读写模式</span></span><br><span class="line"><span class="string">ports: ## 容器需要暴露的端口号列表</span></span><br><span class="line"><span class="string">- name: string ## 端口的名称</span></span><br><span class="line"><span class="string">  containerPort: int ## 容器需要监听的端口号</span></span><br><span class="line"><span class="string">  hostPort: int ## 容器所在主机需要监听的端口号，默认与 containerPort 相同。设置 hostPort 时，同一台宿主机将无法启动该容器的第 2 份副本</span></span><br><span class="line"><span class="string">  protocol: string ## 端口协议，支持 TCP 和 UDP, 默认值为 TCP</span></span><br><span class="line"><span class="string">env:  ## 容器运行前需设置的环境变量列表</span></span><br><span class="line"><span class="string">- name: string ## 环境变量的名称</span></span><br><span class="line"><span class="string">  value: string ## 环境变量的值</span></span><br><span class="line"><span class="string">resources: ## 资源限制和资源请求的设置</span></span><br><span class="line"><span class="string">   limits: </span></span><br><span class="line"><span class="string">     cpu: string ## CPU 限制，单位为 core 数，将用于 docker run --cpu-shares 参数</span></span><br><span class="line"><span class="string">memory: string ## 内存限制，单位可以为 MiB、GiB等，将用于 docker run --memory 参数</span></span><br><span class="line"><span class="string">  requests :</span></span><br><span class="line"><span class="string">cpu: string ## CPU 请求，单位为 core 数，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">memory: string ## 内存请求，单位可以为 MiB、GiB等，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">livenessProbe :</span></span><br><span class="line"><span class="string">  exec:</span></span><br><span class="line"><span class="string">command: [string]</span></span><br><span class="line"><span class="string">  httpGet:</span></span><br><span class="line"><span class="string">path: string</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string">host: string</span></span><br><span class="line"><span class="string">scheme: string </span></span><br><span class="line"><span class="string">httpHeaders:</span></span><br><span class="line"><span class="string">- name: string</span></span><br><span class="line"><span class="string">  value: string</span></span><br><span class="line"><span class="string">  tcpSocket:</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string"></span><span class="attr">      initialDelaySeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      successThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]</span></span><br><span class="line"><span class="string"></span><span class="attr">  nodeSelector:</span> <span class="string">object</span></span><br><span class="line"><span class="attr">  imagePullSecrets:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  hostNetwork:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  volumes:</span> <span class="comment">## 在该 Pod 上定义的共享存储卷列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">emptyDir:</span> <span class="string">&#123;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="attr">hostPath:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">secret:</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">configMap:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure></p><h3 id="pod定义的主要几个部分"><a href="#pod定义的主要几个部分" class="headerlink" title="pod定义的主要几个部分"></a>pod定义的主要几个部分</h3><p>pod定义由这么几个部分组成：首先是YAML中使用的 kubernetes API 版本和 YAML 描述的资源类型，其次就是几乎在所有 kubernetes 资源中都可以找到的三大重要部分：</p><ul><li>metadata：包括名称，命名空间，标签和关于该容器的其他信息。</li><li>spec：包含 pod 内容的实际说明，例如 pod 的容器，卷和其他数据。</li><li>status：包含运行中的 pod 的当前信息，例如 pod 所处的条件，每个容器的描述和状态，以及内部IP和其他基本信息。</li></ul><h3 id="编写一个简单的-YAML-描述文件创建-pod"><a href="#编写一个简单的-YAML-描述文件创建-pod" class="headerlink" title="编写一个简单的 YAML 描述文件创建 pod"></a>编写一个简单的 YAML 描述文件创建 pod</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx</span> <span class="comment">##pod名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span> <span class="comment">## pod里运行那些容器</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span>  <span class="comment">## 镜像名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span>    <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">80</span> <span class="comment">## 容器运行监听的端口</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 kubectl explain 查找资源对象的属性<br>kubectl explain pod<br>kubectl explain pod.spec</p></blockquote><h4 id="使用-kubectl-create-来创建-pod"><a href="#使用-kubectl-create-来创建-pod" class="headerlink" title="使用 kubectl create 来创建 pod"></a>使用 kubectl create 来创建 pod</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f test-nginx.yaml</span><br><span class="line">``` </span><br><span class="line">&gt; kubectl create -f 命令用于从YAML或JOSN文件创建任何资源，不只是pod。</span><br><span class="line"></span><br><span class="line">#### 获取运行中 pod 的完整定义</span><br><span class="line">```shell</span><br><span class="line">kubectl get po test-nginx -o yaml</span><br><span class="line">kubectl get po test-nginx -o json</span><br></pre></td></tr></table></figure><h4 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h4><p>使用 kubectl logs 命令获取 pod 日志<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx</span><br></pre></td></tr></table></figure></p><p>获取多容器 pod 的日志时指定容器名称<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx -c test</span><br></pre></td></tr></table></figure></p><blockquote><p>kubectl logs 命令将显示当前容器的日志。 当你想知道为什么前一个容器终止时，你想看到的是前一个容器的日志，而不是当前容器的。可以通过添加 –previous 选项来完成：<br>kubectl logs test-nginx –previous</p></blockquote><h3 id="停止和移除-pod"><a href="#停止和移除-pod" class="headerlink" title="停止和移除 pod"></a>停止和移除 pod</h3><ul><li>按名称删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods test-nginx</span><br></pre></td></tr></table></figure><ul><li>使用标签选择器删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods -l env=debug</span><br></pre></td></tr></table></figure><ul><li>删除指定命名空间下的所有 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods --all -n test-namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）Kubernetes简介：Kubernetes架构</title>
      <link href="/k8s1/"/>
      <url>/k8s1/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。<br>Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。<br>Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p><h2 id="Borg简介"><a href="#Borg简介" class="headerlink" title="Borg简介"></a>Borg简介</h2><p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。</p><p>Borg主要由BorgMaster、Borglet、borgcfg和Scheduler组成，如下图所示</p><p>  <img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662939314245.jpg" alt="-w572"></p><ul><li>BorgMaster 是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中；</li><li>Scheduer 负责任务的调度，根据应用的特点将其调度到具体的机器上去；</li><li>Borglet 负责真正运行任务（在容器中）；</li><li>borgcfg 是 Borg 的命令行工具，用于跟 Borg 系统交互，一般通过一个配置文件来提交任务。</li></ul><h2 id="Kubernetes-特性"><a href="#Kubernetes-特性" class="headerlink" title="Kubernetes 特性"></a>Kubernetes 特性</h2><p>Kubernetes 是一种用于在一组主机上运行和协同容器化应用程序的系统，旨在提供可预测性、可扩展性与高可用性的方法来完全管理容器化应用程序和服务的生命周期的平台。用户可以定义应用程序的运行方式，以及与其他应用程序或外部世界交互的途径，并能实现服务的扩容和缩容，执行平滑滚动更新，以及在不同版本的应用程序之间调度流量以测试功能或回滚有问题的部署。 Kubernetes 提供了接口和可组合的平台原语，使得用户能够以高度的灵活性和可靠性定义及管理应用程序。简单总结起来，它具有以下几个重要特性 。</p><h3 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1. 自动装箱"></a>1. 自动装箱</h3><p>建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并 通过调度机制混合关键型应用和非关键型应用的工作负载于同一节点以提升资源利用率。</p><h3 id="2-自我修复（自愈）"><a href="#2-自我修复（自愈）" class="headerlink" title="2. 自我修复（自愈）"></a>2. 自我修复（自愈）</h3><p>支持容器故障后自动重启、节点故障后重新调度容器，以及其他可用节点、健康状态 检查失败后关闭容器并重新创建等自我修复机制。</p><h3 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3. 水平扩展"></a>3. 水平扩展</h3><p>支持通过简单命令或 UI 手动水平扩展，以及基于 CPU 等资源负载率的自动水平扩展机制 。</p><h3 id="4-服务发现和负载均衡"><a href="#4-服务发现和负载均衡" class="headerlink" title="4. 服务发现和负载均衡"></a>4. 服务发现和负载均衡</h3><p>Kubernetes 通过其附加组件之一的 KubeDNS （或 CoreDNS ）为系统内置了服务发现功能，它会为每个 Service 配置 DNS 名称，并允许集群内的客户端直接使用此名称发出访问请求，而 Service 则通过 iptables 或 ipvs 内建了负载均衡机制 。</p><h3 id="5-自动发布和回滚"><a href="#5-自动发布和回滚" class="headerlink" title="5. 自动发布和回滚"></a>5. 自动发布和回滚</h3><p>Kubernetes 支持“灰度”更新应用程序或其配置信息，它会监控更新过程中应用程序的健康状态，以确保它不会在同一时刻杀掉所有实例，而此过程中一旦有故障发生，就会立即自动执行回滚操作 。</p><h3 id="6-密钥和配置管理"><a href="#6-密钥和配置管理" class="headerlink" title="6. 密钥和配置管理"></a>6. 密钥和配置管理</h3><p>Kubernetes 的 ConfigMap 实现了配置数据与 Docker 镜像解稠，需要时，仅对配置做出变更而无须重新构建 Docker 镜像，这为应用开发部署带来了很大的灵活性。此外，对于应用所依赖的一些敏感数据，如用户名和密码、令牌、密钥等信息， Kubernetes 专门提供了 Secret 对象为其解耦，既便利了应用的快速开发和交付，又提供了一定程度上的安全保障。</p><h3 id="7-存储编排"><a href="#7-存储编排" class="headerlink" title="7. 存储编排"></a>7. 存储编排</h3><p>Kubernetes 支持 Pod 对象按需自动挂载不同类型的存储系统 ，这包括节点本地存储、公有云服务商的云存储（如 AWS 和 GCP 等），以及网络存储系统（例如， NFS、iSCSI、GlusterFS、Ceph、Cinder 和 Flocker 等）。</p><h3 id="8-批量处理执行"><a href="#8-批量处理执行" class="headerlink" title="8. 批量处理执行"></a>8. 批量处理执行</h3><p>除了服务型应用，Kubernetes 还支持批处理作业及 CI（持续集成），如果需要， 一样可以实现容器故障后恢复。</p><h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><p>Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Labels 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像，如下图所示</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662946967695.jpg" alt=""></p><p>Kubernetes 主要由以下几个核心组件组成：</p><ul><li>etcd 保存了整个集群的状态；</li><li>kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li><li>kube-controller-manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>kube-scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li><li>kubelet 负责维持容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），默认的容器运行时为 Docker；</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的 Add-ons：</p><ul><li>CoreDNS 负责为整个集群提供 DNS 服务</li><li>Ingress Controller 为服务提供外网入口</li><li>Heapster 提供资源监控</li><li>Dashboard 提供 GUI</li><li>Federation 提供跨可用区的集群</li><li>Fluentd-elasticsearch 提供集群日志采集、存储与查询</li></ul><h2 id="Kubernetes架构示意图"><a href="#Kubernetes架构示意图" class="headerlink" title="Kubernetes架构示意图"></a>Kubernetes架构示意图</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>下图清晰表明了Kubernetes的架构设计以及组件之间的通信协议。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663927970976.jpg" alt="Kuberentes架构（图片来自于网络）"></p><p>下面是更抽象的一个视图：</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928276452.jpg" alt="kubernetes整体架构示意图"></p><h3 id="Master架构"><a href="#Master架构" class="headerlink" title="Master架构"></a>Master架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928485300.jpg" alt="Kubernetes master架构示意图"></p><h3 id="Node架构"><a href="#Node架构" class="headerlink" title="Node架构"></a>Node架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928706968.jpg" alt="kubernetes node架构示意图"></p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928960235.jpg" alt="Kubernetes分层架构示意图"></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li><li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</li><li>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</li><li>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）Kubernetes简介：核心资源对象&amp;核心组件</title>
      <link href="/k8s2/"/>
      <url>/k8s2/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群是配置 Kubernetes 的所有组件、功能和工作负载的物理平台。 集群中一台服务器（或高可用部署中的一组服务器）用作 Master ，负责管理整个集群，余下的其他机器用作 Worker Node ，它们是使用本地和外部资源接收和运行工作负载的服务器。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>Master 是集群的网关和中枢，负责为用户和客户端暴露 API ，跟踪其他服务器的健 康状态、以最优方式调度工作负载，以及编排其他组件之间的通信等任务，它是用户或客户端与集群之间的核心联络点，并负责 Kubernetes 系统的大多数集中式管控逻辑。 单个 Master 节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是 Kubernetes 集群的工作节点，负责接收来自 Master 的工作指令并根据指令相应地创建或销毁 Pod 对象，以及调整网络规则以合理地路由和转发流量等。 理论上讲，Node 可以是任何形式的计算设备，不过 Master 会统一将其抽象为 Node 对象进行管理。</p><p>Kubernetes 将所有 Node 的资源集结于一处形成一台更加强大的“服务器”，在用户将应用部署于其上时，Master 会使用调度算法将其自动指派至某个特定的 Node 运行。在 Node 加入集群或从集群中移除时 Master 也会按需重新编排影响到的 Pod（容器）。于是，用户无须关心其应用究竟运行于何处。</p><p>从抽象的视角来讲， Kubernetes 还有着众多的组件来支撑其内部的业务逻辑，包括运行应用、应用编排、服务暴露、应用恢复等，它们在 Kubernetes 中被抽象为Pod、Label、Annotation、Ingress、Service、Controller等资源对象。</p><h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Kubernetes 并不直接运行容器，而是使用一个抽象的资源对象来封装一个或者多个容器，这个抽象为 Pod ，它也是 Kubernetes 的最小调度单元。同一 Pod 中的容器共享网络名称空间和存储资源，这些容器可经由本地回环接口 lineout 直接通信，但彼此之间又在 Mount、User 及 PID 等名称空间上保持了隔离。尽管 Pod 中可以包含多个容器，但是作为最小调度单元，它应该尽可能地保持“小”，即通常只应该包含一个主容器。</p><h3 id="Label-资源标签"><a href="#Label-资源标签" class="headerlink" title="Label 资源标签"></a>Label 资源标签</h3><p>标签（ Label ）是将资源进行分类的标识符，资源标签其实就是一个键值型（ key/values) 数据。标签旨在指定对象（如 Pod 等）辨识性的属性，这些属性仅对用户存在特定的意义，对 Kubernetes 集群来说并不直接表达核心系统语义。标签可以在对象创建时附加其上，并能够在创建后的任意时间进行添加和修改。一个对象可以拥有多个标签，一个标签也可以附加于多个对象（通常是同一类对象）之上</p><h3 id="标签选择器（-Selector-）"><a href="#标签选择器（-Selector-）" class="headerlink" title="标签选择器（ Selector ）"></a>标签选择器（ Selector ）</h3><p>标签选择器（ Selector ）全称为 “ Label Selector” 它是一种根据 Label 来过滤符合条件的资源对象的机制。 例如，将附有标签“ role:backend ”的所有 Pod 对象挑选出来归为一组就是标签选择器的一种应用，用户通常使用标签对资源对象进行分类，而后使用标签选择器挑选出它们，直接批量给挑选出来的资源对象做相应的操作。</p><h3 id="Pod-控制器"><a href="#Pod-控制器" class="headerlink" title="Pod 控制器"></a>Pod 控制器</h3><p>尽管 Pod 是 Kubernetes 的最小调度单元，但用户通常并不会直接部署及管理 Pod 对象，而是要借助于另一类抽象——控制器（Controller）对其进行管理。 用于工作负载的控制器是一种管理 Pod 生命周期的资源抽象，它们是 Kubernetes 上的一类对象，而非单个资源对象，包 括 ReplicationController、ReplicaSet、 Deployment、StatefulSet、Job 等 。 以 Deployment 控制器为例，它负责确保指定的 Pod 对象的副本数量精确符合定义，否则“多退少补”。使用控制器之后就不再需要手动管理 Pod 对象了，用户只需要声明应用的期望状态，控制器就会自动对其进行进程管理。</p><h3 id="服务资源（-Service"><a href="#服务资源（-Service" class="headerlink" title="服务资源（ Service )"></a>服务资源（ Service )</h3><p>Service 是建立在一组 Pod 对象之上的资源抽象，它通过标签选择器选定一组 Pod 对象， 并为这组 Pod 对象定义一个统一的固定访问入口（通常是一个 IP 地址），若 Kubernetes 集群存在 DNS 附件，它就会在 Service 创建时为其自动配置一个 DNS 名称以便客户端进行服务发现。 到达 Service IP 的请求将被负载均衡至其后的端点——各个 Pod 对象之上，因此 Service 从本质上来讲是一个四层代理服务。 另外， Service 还可以将集群外部流量引入到集群中来 。</p><h3 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h3><p>存储卷（ Volume ）是独立于容器文件系统之外的存储空间，常用于扩展容器的存储空间并为它提供持久存储能力。Kubernetes 集群上的存储卷大体可分为临时卷 、本地卷和网络卷。临时卷和本地卷都位于 Node 本地，一旦 Pod 被调度至其他 Node，此种类型的存储卷将无法访问到，因此临时卷和本地卷通常用于数据缓存，持久化的数据则需要放置于持久卷 (persistent volume ）之上。</p><h3 id="Name-和-Namespace"><a href="#Name-和-Namespace" class="headerlink" title="Name 和 Namespace"></a>Name 和 Namespace</h3><p>名称（ Name ）是 Kubernetes 集群中资源对象的标识符，它们的作用域通常是名称空间( Namespace ）因此名称空间是名称的额外的限定机制。在同一个名称空间中，同一类型资源对象的名称必须具有唯一性。名称空间通常用于实现租户或项目的资源隔离，从而形成逻辑分组。创建资源对象未指定名称空间时 ，它们都属于默认的名称空间“ default ” 。</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>Annotation（注解）是另一种附加在对象之上的键值类型的数据，但它拥有更大的数据容量。Annotation常用于将各种非标识型元数据（ metadata ） 附加到对象上，但它不能用于标识和选择对象，通常也不会被 Kubernetes 直接使用，其主要目的是方便工具或用户的阅读及查找等</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Kubernetes 将 Pod 对象和外部网络环境进行了隔离，Pod 和 Service 等对象间的通信都使用其内部专用地址进行，如若需要开放某些 Pod 对象提供给外部用户访问，则需要为其请求流量打开一个通往 Kubernetes 集群内部的通道，除了Service之外，Ingress 也是这类通道的实现方式之一。</p><h2 id="Kubernetes集群组件"><a href="#Kubernetes集群组件" class="headerlink" title="Kubernetes集群组件"></a>Kubernetes集群组件</h2><p>一个典型的 Kubernetes 集群由多个工作节点和一个或多个Master节点，以及一个集群状态存储系统（ etcd ）组成。其中 Master 节点负责整个集群的管理工作， 为集群提供管理接口，并监控和编排集群中的各个工作节点。各个工作节点负责以 Pod 的形式运行容器，因此，各节点需要事先配置好容器运行依赖的所有服务和资源，如容器运行时环境（比如Docker）。</p><p>Master 节点主要是由 apiserver、 controller-manager 和 scheduler 三个组件，以及一个用于集群状态存储的 etcd 存储服务组成，而每个 Node 节点则主要包含 kubelet、kube-proxy 及容器引擎（ Docker是最为常用的实现）等组件。此外，完整的集群服务还依赖于一些附加组件，如 KubeDNS、Dashboard、Heapster、Ingress Controller 等。</p><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><p>API Server 负责输出 RESTful 风格的 Kubernetes API ，它是发往集群的所有 REST 操作命令的接入点，并负责接收、校验并响应所有的 REST 请求，结果状态被持久存储于 etcd 中。因此，API Server 是整个集群的网关。</p><h3 id="集群状态存储（etcd）"><a href="#集群状态存储（etcd）" class="headerlink" title="集群状态存储（etcd）"></a>集群状态存储（etcd）</h3><p>Kubernetes 集群的所有状态信息都需要持久存储于存储系统 etcd 中，不过， etcd 是由 CoreOS 基于 Raft 协议开发的分布式键值存储，可用于服务发现、共享配置以及一致性保障（如数据库主节点选择、分布式锁等）。因此，etcd 是独立的服务组件，并不隶属于 Kubernetes 集群自身。生产环境中应该以 etcd 集群的方式运行以确保其服务可用性。</p><p>etcd 不仅能够提供键值数据存储， 而且还为其提供了监昕（ watch ）机制，用于监听和推送变更。 Kubernetes 集群系统中，etcd 中的键值发生变化时会通知到 API Server ，并由其通过 watchAPI 向客户端输出。基于 watch 机制， Kubernetes 集群的各组件实现了高效协同 。</p><h3 id="控制器管理器（-Controller-Manager"><a href="#控制器管理器（-Controller-Manager" class="headerlink" title="控制器管理器（ Controller Manager )"></a>控制器管理器（ Controller Manager )</h3><p>Kubernetes 中，集群级别的大多数功能都是由几个被称为控制器的进程执行实现的，这几个进程被集成于 kube-controller-manager 守护进程中。由控制器完成的功能主要包括生命周期功能和 API 业务逻辑，具体如下。</p><ul><li>生命周期功能：包括 Namespace 创建和生命周期、 Event 垃圾回收、 Pod 终止相关的垃圾回收、级联垃圾回收及 Node 垃圾回收等 。</li><li>API业务逻辑：例如，由 ReplicaSet 执行的 Pod 扩展等 。</li></ul><h3 id="调度器（-Scheduler"><a href="#调度器（-Scheduler" class="headerlink" title="调度器（ Scheduler )"></a>调度器（ Scheduler )</h3><p>Kubernetes 是用于部署和管理大规模容器应用的平台，根据集群规模的不同，其托管运行的容器很可能会数以千计甚至更多。 API Server 确认 Pod 对象的创建请求之后， 便需要由 Scheduler 根据集群内各节点的可用资源状态，以及要运行的容器的资源需求做出调度决策。另外，Kubernetes 还支持用户自定义调度器</p><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet 是运行于工作节点之上的守护进程，它从 API Server 接收关于 Pod 对象的配置信息并确保它们处于期望的状态。 kubelet 会在 API Server 上注册当前工作节点， 定期向 Master 汇报节点资源使用情况，并通过 cAdvisor 监控容器和节点的资源占用状况 。</p><h3 id="容器运行时环境"><a href="#容器运行时环境" class="headerlink" title="容器运行时环境"></a>容器运行时环境</h3><p>每个 Node 都要提供一个容器运行时（ Container Runtime ）环境， 它负责下载镜像并运行容器。 kubelet 并未固定链接至某容器运行时环境，而是以插件的方式载入配置的容器环境。这种方式清晰地定义了各组件的边界。目前，Kubernetes 支持的容器运行环境至少包括Docker、RKT、cri-o 和 Fraki等。</p><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>每个工作节点都需要运行一个 kube-proxy 守护进程，它能够按需为 Service 资源对象生成 iptables 或 ipvs 规则，从而捕获访问当前 Service 的ClusterIP 的流量并将其转发至正确的后端 Pod 对象。</p><h3 id="KubeDNS"><a href="#KubeDNS" class="headerlink" title="KubeDNS"></a>KubeDNS</h3><p>KubeDNS 是在 Kubernetes 集群中调度运行提供 DNS 服务的 Pod，同一集群中的其他 Pod 可使用此 DNS 服务解决主机名。 Kubernetes 自 1.11 版本开始默认使用 CoreDNS 项目为集群提供服务注册和服务发现的动态名称解析服务，之前的版本中用到的是 kube-dns 项目，而 SkyDNS 则是更早一代的项目。</p><h3 id="Kubernetes-Dashboard"><a href="#Kubernetes-Dashboard" class="headerlink" title="Kubernetes Dashboard"></a>Kubernetes Dashboard</h3><p>Kubernetes 集群的全部功能都要基于 Web 的 UI，来管理集群中的应用甚至是集群自身。</p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><p>容器和节点的性能监控与分析系统，它收集并解析多种指标数据，如资源利用率、生命周期事件等。新版本的 Kubernetes 中，其功能会逐渐由 Prometheus 结合其他组件所取代。</p><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>Service 是一种工作于传统层的负载均衡器，而 Ingress 是在应用层实现的 HTTP (s）负载均衡机制。不过，Ingress 资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则需要通过 Ingress 控制器（ Ingress Controller) 发挥作用 。 目前，此类的可用项目有 Nginx、Traefik、Envoy 及 HAProxy 等。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）初识 Docker 与容器</title>
      <link href="/docker1/"/>
      <url>/docker1/</url>
      
        <content type="html"><![CDATA[<p>Docker 是基于 Go 语言实现的开源容器项目，主要用于创建、管理和编排容器。 它诞生于 2013 年年初，最初是由一家名为 dotCloud 的公司利用 Linux 容器技术开发的一套内部工具。自开源后受到业界广泛的关注与参与，dotCloud 公司也随之快速发展壮大， 在 2013 年年底直接改名为 Docker Inc，并专注于 Docker 相关技术和产品的开发，目前已经成为全球最大的 Docker 容器服务提供商。</p><p>Docker 的构想是要实现“ Build, Ship and Run Any App, Anywhere ”，即通过对应用的封装（Packaging）、分发（ Distribution ）、部署（ Deployment）、运行（ Runtime ）生命周期进行管 理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件， 既可以是一个 Web 应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。基于 Linux 平台上的多项开源技术，Docker 提供了高效、敏捷和轻量级的容器方案， 并支持部署到本地环境和多种主流云平台。可以说，Docker 首次为应用的开发、运行和部署提供了“一站式”的实用解决方案。</p><p>在 LXC 的基础上， Docker 进一步优化了容器的使用体验，让它进入寻常百姓家。首先，Docker 提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器；其次，Docker 通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大地改善了用户体验。用户操作 Docker 容器就像操作应用自身一样简单。</p><p>早期的 Docker 代码实现是直接基于 LXC 的。自 0.9 版本开始，Docker 开发了 libcontainer 项目作为更广泛的容器驱动实现，从而替换掉了 LXC 的实现。目前，Docker 还积极推动成立了 rune 标准项目，井贡献给开放容器联盟，试图让容器的支持不再局限于 Linux 操作系统，而是更安全、更开放、更具扩展性。</p><h2 id="Docker-运行时与编排引擎"><a href="#Docker-运行时与编排引擎" class="headerlink" title="Docker 运行时与编排引擎"></a>Docker 运行时与编排引擎</h2><p>多数技术人员在谈到 Docker 时，主要是指 Docker 引擎。Docker 引擎是用于运行和编排容器的基础设施工具。有 VMware 管理经验的读者可以将其类比为 ESXi。ESXi 是运行虚拟机的核心管理程序，而 Docker 引擎是运行容器的核心容器运行时。</p><p>Docker 引擎主要有两个版本:企业版 (EE) 和社区版 (CE)。<br>每个季度，企业版和社区版都会发布一一个稳定版本。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持。<br>社区版还会通过 Edge 方式发布月度版。</p><h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><p>对开发和运维（ DevOps ）人员来说，最梦寐以求的效果可能就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行，而 Docker 恰恰是可以实现这一终极目标的“瑞士军刀”。具体说来，在开发和运维过程中，Docker 具有如下几个方面的优势：</p><ul><li>更快速的交付和部署：使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。</li><li>更高效的资源利用：运行 Docker 容器不需要额外的虚拟化管理程序的支持，Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</li><li>更轻松的迁移和扩展：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。</li><li>更简单的更新管理：使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</li></ul><p>Docker 容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得“很薄的”容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。当然，在隔离性方面，传统的虚拟机方式提供的是相对封闭的隔离。但这并不意味着 Docker 不安全。 Docker利用 Linux 系统上的多种防护技术实现了严格的隔离可靠性， 并且可以整合众多安全工具。从 1.3.0 版本开始，Docker重点改善了容器的安全控制和镜像的安全机制，极大地提高了使用 Docker 的安全性。Docker 在运行应用上跟传统的虚拟机方式相比具有如下：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动速度</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">较弱</td></tr><tr><td style="text-align:center">内存代价</td><td style="text-align:center">很小</td><td style="text-align:center">较多</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为MB</td><td style="text-align:center">一般为GB</td></tr><tr><td style="text-align:center">运行密度</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr><tr><td style="text-align:center">隔离性</td><td style="text-align:center">安全隔离</td><td style="text-align:center">完全隔离</td></tr><tr><td style="text-align:center">迁移性</td><td style="text-align:center">优秀</td><td style="text-align:center">一般</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）微服务架构与 Spring Cloud 简介</title>
      <link href="/springcloud1/"/>
      <url>/springcloud1/</url>
      
        <content type="html"><![CDATA[<p>从单体应用架构发展到SOA架构，再到微服务架构，应用架构经历了多年的不断演进。微服务架构不是凭空产生的，而是技术发展的必然结果，分布式云平台的应用环境使得微服务代替单体应用成为互联网大型系统的架构选择。目前，虽然微服务架构还没有公 认的技术标准和规范草案，但业界已经有了一些很有影响力的开源微服务架构解决方案，在进行微服务化开发或改造时可以进行相应的参考。</p><p>目前软件架构有三种架构类型，分别是业务架构、应用架构、技术架构。它们之间的关系是业务架构决定应用架构，技术架构支撑应用架构。架构的发展历程是从单体架构、分布式架构、SOA架构再到微服务架构，如下图所示。</p><p><img src="http://file.yuxuan.video/15661318810425.jpg" alt=""></p><h2 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h2><p>传统的单体架构在Java领域可以理解为一个Web应用，大部分Web工程都是将所有的功能打包在一起部署和运行。按照程序调用顺序，从上到下为表示层、业务层、数据访问层、DB层。如下图所示<br><img src="http://file.yuxuan.video/15661331490382.jpg" alt=""></p><p>因为所有的功能模块都是在一个工程编写的，所以从开发和测试的角度来看，开发人员可以在短时间内就开发出单体应用，并且由于没有过多的依赖项，测试也可以节约很多时间。</p><p>但是，随着应用不断的发展，开发团队不断的扩张之后，单体应用的不足和弊端就会很明显的暴露出来，主要有以下不足点：</p><ul><li>灵活度不够：如果程序有任何修改，那么修改的不止一个点，可能需要从上到下地去修改，并且测试的时候必须等到整个程序部署完才能看出效果，并且由于整个开发工作都是在一个工程下进行的，可能需要等待其他开发人员开发完成才能完成部署，大大的降低了团队的灵活性。</li><li>可靠性：一旦出现了bug，影响的将是整个应用。因为所有的模块功能都是运行在一个进程中的。</li><li>复杂性高：单体应用的代码量可能会让团队新来的成员望而生畏，应用难以理解和迭代，从而到时开发速度大大降低。</li><li>系统扩展性差：添加新东西的时候不能针对某个点增加，要全局性增加。</li><li>系统启动慢：一个应用包含了所有功能模块，导致系统的启动时间较长。</li></ul><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>SOA的核心主体是服务，其目标是通过服务的流程化来实现业务的灵活性。服务就像一堆“元器件”，这些元器件通过封装形成标准服务，它们有相同的接口和语义表达规则。但服务要组装成一个流程和应用，还需要有效的“管理”，包括如何注册服务、如何发现服 务、如何包装服务的安全性和可靠性，这些就是SOA治理。SOA治理是将 SOA 的一堆元器件进行有效组装。这是形成一个“产品”的关键，否则那些永远是一堆元器件，而无法形成一个有机整体。<br>完整的SOA架构由五大部分组成：基础设施服务、企业服务总线、关键服务组件、开发工具、管理工具等。</p><ul><li>基础设施：为整个SOA组件和框架提供一个可靠的运行环境，以及服务组件容器，它的核心组件是应用服务器等基础软件支撑设施，提供运行期完整、可靠的软件支撑 。</li><li>企业服务总线：提供可靠消息传输、服务接入、协议转换、数据格式转换、 基于内容的路由等功能，屏蔽了服务的物理位置、协议和数据格式 。</li><li>关键服务组件：SOA在各种业务服务组件的分类。</li><li>开发工具和管理工具：提供完善的、可视化的服务开发和流程编排工具，包括服务的设计、开发、 配置、部署、监控、重构等完整的SOA项目开发生命周期 。</li></ul><p>SOA 架构中有两个主要角色：服务提供者（Provider）和服务消费者（Consumer）。<br>SOA架构的优点：</p><ul><li>把模块拆分， 使用接口通信， 降低模块之间的耦合度。</li><li>把项目拆分成若干个子项目，不同的团队负责不同的子项目。</li><li>增加功能时只需要增加一个子项目，调用其他系统的接口即可。</li><li>可以灵活地进行分布式部署。 </li></ul><p>SOA 架构的缺点：系统之间的交互需要使用远程通信， 接口开发增加工作量 。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务的概率最早是由 Martin Fowler 与 James Lewis 于 2014 年共同提出，需要了解细节的读者可以阅览 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices</a>。根据其描述，总体来说，微服务是一种架构风格， 对于一个大型复杂的业务系统，它的业务功能可以拆分为多个相互独立的微服务，各个微服务之间是松搞合的，通过各种远程协议进行同步／异步通信，各微服务均可以被独立部署、 扩／缩容以及升／降级。这些服务是基于业务逻辑和范围，通过自动 化部署的机制来独立部署的，并且服务的集中管理应该是最低限度的，即每个服务可以采用不同的编程语言编写，使用不同的数据存储技术 。<br>如今，微服务架构已经不是一个新概念了，很多业界前沿互联网公司的实践表明，微服务是一种渐进式的演进架构，是企业应对业务复杂性，支持大规模持续创新行之有效的架构手段。</p><h3 id="微服务组成"><a href="#微服务组成" class="headerlink" title="微服务组成"></a>微服务组成</h3><p>微服务架构是一种比较复杂、内涵丰富的架构模式，它包含很多支撑“微”服务的具体组件和概念，其中一些常用的组件及其概念如下：</p><ul><li>服务注册与发现：服务提供方将己方调用地址注册到服务注册中心，让服务调用方能够方便地找到自己；服务调用方从服务注册中心找到自己需要调用的服务的地址。</li><li>负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，服务节点选择的过程对服务调用方来说是透明的。</li><li>服务网关：服务网关是服务调用的唯一入口，可以在这个组件中实现用户鉴权、动态路由、灰度发布、 A/B测试、负载限流等功能。</li><li>配置中心：将本地化的配置信息（ Properties 、 XML 、 YAML 等形式）注册到配置中心，实现程序包在开发、测试、生产环境中的无差别性，方便程序包的迁移。</li><li>集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形 式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够 在统一的界面中使用系统。</li><li>调用链监控：记录完成一次请求的先后衔接和调用关系，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。</li><li>支撑平台：系统微服务化后，各个业务模块经过拆分变得更加细化，系统的部署、运维、监控等都比单体应用架构更加复杂，这就需要将大部分的工作自动化。 现在，Jenkins、Docker、Kubernetes等工具可以给微服务架构的部署带来较多的便利，例如持续集成、蓝绿 发布、健康检查、性能健康等等。如果没有合适的支撑平台或工具，微服务架构就无法发挥它最大的功效 。</li></ul><p>微服务架构模式有很多优势可以有效解决单体应用扩大之后出现的大部分问题。首先，通过将巨大单体式应用分解为多个服务的方法解决了复杂性问题。在功能不变的情况下，应用分解为多个可管理的模块或服务。每个服务都有一个用RPC或者消息驱动API定义清楚的边界。微服务架构模式为采用单体式编码方式，由此，单个服务变得很容易开发、理解和维护。<br>其次，微服务架构模式使得团队并行开发得以推进，每个服务都可以由专门开发团队来开发。不同团队的开发者可以自由选择开发技术，提供API服务。这种自由意味着开发者不需要被迫使用之前采用的过时技术，他们可以选择最新的技术。甚至于，因为服务都是相对简单的，即使用新技术重写以前的代码也不是很困难的事情。</p><p>微服务的一些想法是好的，但在实践中也会呈现出其复杂性，具体如下：</p><ul><li>运维要求较高：更多的服务意味着需要更多的运维投入。在单体架构中只需要保证一个应用的正常运行即可；而在微服务中，需要保证几十甚至几百个服务的正常运行与协作，这带来了巨大的挑战。 </li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统来说，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。</li><li>接口调整成本高：微服务之间通过接口进行通信。 如果修改某个微服务的API，可能所有使用了该接口 的微服务都需要做调整。</li><li>重复劳动：很多服务可能都会使用到相同的功能， 而这个功能并没有达到分解为一个微服务的程度， 这个时候，可能各个服务都会开发这一功能，导致代码重复。</li><li>可测试性的挑战：在动态环境下，服务间的交互会产生非常微妙的行为，难以进行可视化及全面测试。</li></ul><h2 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h2><p>Spring Cloud是一系列框架的有序集合。目前由 Spring 官方开发维护，基于 Spring Boot 开发，提供一套完整的微服务解决方案。包括服务注册与发现、配置中心、全链路监控、 API 网关、熔断器等开源组件，可以随需扩展和替换组装。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>Spring Cloud 不同于其他独立项目，它是拥有众多子项目的项目集合。因为 Spring Cloud 的子项目居多，每个子项目有自己的版本号，为了对 Spring Cloud 整体进行版本编号，确定一个可用于生产上的版本标识。这些版本采用伦敦地铁站的名字，按名称首字母排序，比如 Dalston 版、Edgware 版、Finchley 版、Greenwich 版。</p><h2 id="Spring-Cloud-组成"><a href="#Spring-Cloud-组成" class="headerlink" title="Spring Cloud 组成"></a>Spring Cloud 组成</h2><p>Spring Cloud 包含的组件众多，各个组件都有各自不同的特性和优点，为使用者提供丰富的选择 ：</p><ul><li><p>服务注册与发现组件：Eureka、Zookeeper 和 Consul 等。</p></li><li><p>服务调用组件：Hystrix、Ribbon 和 OpenFeign。其中 Hystrix 能够使系统在出现依赖服务访问不可达的情况下，通过隔离系统依赖服务的方式，防止服务雪崩，同时提供失败回滚机制，使系统能够更快地从异常中恢复。Ribbon 用于提供客户端的软件负载均衡算法，还提供了一系列完善的配置项如连接超时、重试等。OpenFeign 是一个声明式 RESTful 网络请求客户端，它使编写 Web 服务客户端变得更加方便和快捷。</p></li><li><p>路由和过滤组件：包括 Zuul 和 Spring Cloud Gateway。Spring Cloud Gateway 提供了一个构建在 Spring 生态 之上的 API 网关，其旨在提供一种简单而有效的途径来发送API，并为他们提供横切关注点。如：安全性、监控指标和弹性。</p></li><li><p>消息组件：Spring Cloud Stream 和 Spring Cloud Bus。Spring Cloud Stream 对于分布式消息的各种需求进行了抽象，包括发布订阅、分组消费和消息分区等功能，实现了微服务之间的异步通信。Spring Cloud Bus 主要提供了服务间的事件通信（比如：刷新配置 ）。</p></li><li><p>安全控制组件：Spring Cloud Security 基于 OAuth2.0 开放网络的安全标准，提供了微服务环境下的单点登录、资源授权和令牌管理等功能。</p></li><li><p>链路监控组件：Spring Cloud Sleuth 提供了全自动、可配置的数据埋点，以 收集微服务调用链路上的性能数据，并可以结合 Zipkin 进行数据存储、统计和展示。</p></li></ul><p>除了上述组件之外，Spring Cloud 还提供了命令行工具 Spring Cloud Cli 和集群工具 Spring Cloud Cluster。 Spring Cloud Cli 提供了以命令行和脚本的方式来管理微服务及 Spring Cloud 组件的方式，Spring Cloud Cluster 提供了集群选主、分布式锁和一次性令牌等分布式集群需要的技术组件。</p><table><thead><tr><th style="text-align:center">组件名称</th><th style="text-align:center">所属项目</th><th style="text-align:center">组件分类</th></tr></thead><tbody><tr><td style="text-align:center">Eureka</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Consul</td><td style="text-align:center">spring-cloud-consul</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zookeeper</td><td style="text-align:center">spring-cloud-zookeeper</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zuul</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">第一代网关</td></tr><tr><td style="text-align:center">Ribbon</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">负载均衡</td></tr><tr><td style="text-align:center">Hystrix</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">熔断器</td></tr><tr><td style="text-align:center">Turbine</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">集群监控</td></tr><tr><td style="text-align:center">Feign</td><td style="text-align:center">spring-cloud-openfeign</td><td style="text-align:center">远程调用</td></tr><tr><td style="text-align:center">Gateway</td><td style="text-align:center">spring-cloud-gateway</td><td style="text-align:center">第二代网关</td></tr><tr><td style="text-align:center">Sleuth</td><td style="text-align:center">spring-cloud-seluth</td><td style="text-align:center">链路追踪</td></tr><tr><td style="text-align:center">Bus</td><td style="text-align:center">spring-cloud-bus</td><td style="text-align:center">总线</td></tr><tr><td style="text-align:center">config</td><td style="text-align:center">spring-cloud-config</td><td style="text-align:center">配置中心</td></tr><tr><td style="text-align:center">Pipeline</td><td style="text-align:center">spring-cloud-pipeline</td><td style="text-align:center">部署管道</td></tr><tr><td style="text-align:center">Dataflow</td><td style="text-align:center">spring-cloud-dataflow</td><td style="text-align:center">数据处理</td></tr><tr><td style="text-align:center">Security</td><td style="text-align:center">spring-cloud-Security</td><td style="text-align:center">安全控制</td></tr></tbody></table><p>Spring Cloud 并不能与微服务或者微服务架构划上等号，不能误认为使用了 Spring Cloud 的应用服务就是微服务。微服务架构是一种架构的理念，重点是微服务的设计原则，从理论上为具体的技术落地提供了指导思想。Spring Cloud 是一个基于 Spring Boot 实现的服务治理工具包，关注全局的服务治理框架。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）服务注册与发现之 Spring Cloud Eureka</title>
      <link href="/springcloud2/"/>
      <url>/springcloud2/</url>
      
        <content type="html"><![CDATA[<p>在传统的单体应用中，组件之间的调用通过有规范约束的接口进行，从而实现不同模块间良好协作。在微服务架构中，原本的“巨石”应用按照业务被分割成相对独立的、提供特定功能的微服务，每一个微服务都可以通过集群或者其他方式进行动态扩展，每一个微服务实例的网络地址都可能动态变化，这使得原本通过硬编码地址的调用方式失去了作用。微服务架构中，服务地址的动态变化和数量变动，迫切需要系统建立一个中心化的组件对各个微服务实例信息进行登记和管理，同时让各个微服务实例之间能够互相发现，从而达到互相调用的结果。</p><p>通常来说服务注册与发现包括两部分一个是服务器端，另一个是客户端。Server 是一个公共服务，为 Client 提供服务注册和发现的功能，维护注册到自身的 Client 的相关信息，同时提供接口给 Client 获取注册表中其他服务的信息，使得动态变化的 Client 能够进行服务间的相互调用。Client 将自己的服务信息通过一定的方式登记到 Server 上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过 Server 获取到自己依赖的其他服务信息，完成服务调用。</p><p>Eureka Server 端采用的是 P2P 的复制模式，但是它不保证复制操作一定能成功，因此它提供的是一个最终一致性的服务实例视图。Client 端在 Server 端的注册信息有一个带期限的租约，一旦 Server 端在指定期间没有收到 Client 端发送的心跳，则 Server 端会认为 Client 端注册的服务是不健康的，定时任务会将其从注册表中删除。</p><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供用于服务发现和注册的基础组件，是搭建 Spring Cloud 微服务架构的前提之一。Eureka 作为一个开箱即用的基础组件，屏蔽了底层 Server 和 Client 交互的细节，使得开发者能够将精力更多地放在业务逻辑上，加快微服务架构的实施和项目的开发。</p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>搭建一个 Eureka Server 非常简单，创建一个maven项目，添加一个 spring-cloud-starter-netflix-eureka-server 依赖。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>    <span class="comment"># eureka server 没必要自己把自己注册上去，所以可以设置成 false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否从Eureka Server上获取注册信息，默认为true，此处建议修改成 false</span></span><br></pre></td></tr></table></figure><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，访问 <a href="http://localhost:8761" target="_blank" rel="noopener">http://localhost:8761</a> 就会看到如下界面，至此一个简单的 Eureka Server 就搭建好了。</p><p><img src="http://file.yuxuan.video/15681006514011.jpg" alt="-w1679"></p><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>Eureka Server 注册中心已经创建好了，下面我们来创建一个 Eureka Client 注册到 Eureka Server 中。 </p><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">   application:</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动程序-1"><a href="#启动程序-1" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，刷新 Eureka Server 界面，会发现服务已经注册上来了，如下图所示：</p><p><img src="http://file.yuxuan.video/15681016134485.jpg" alt="-w1669"></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、【Java并发】线程安全之synchronized的原理和应用</title>
      <link href="/thread_three/"/>
      <url>/thread_three/</url>
      
        <content type="html"><![CDATA[<p>w</p><h2 id="Synchronized的实现原理与应用"><a href="#Synchronized的实现原理与应用" class="headerlink" title="Synchronized的实现原理与应用"></a>Synchronized的实现原理与应用</h2><p>在多线程并发编程中线程安全和数据同步一直以来都是不可避免的问题，在JDK1.5版本之前，要解决这个问题需要使用synchronized关键字，synchronized提供了一种排他机制，也就是在同一时间只能有一个线程执行某些操作，很多人都会称呼它为重量级锁，但是随着JDK1.6对synchronized进行了各种优化之后，有些情况下它就并不会显得那么重了。下面我们一起来探究synchronized的实现原理，以及JDK1.6是如何对它进行优化，以及锁的存储结构和升级过程。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性问题，如果一个共享资源对多个线程是可见的，那么该资源的所有读或者写都将通过同步的方式来进行，具体表现如下：</p><ul><li>synchronized提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题得出现</li><li>synchronized在JVM中实现原理是基于进入和退出Monitor对象来实现方法的同步和代码块同步。<ul><li>同步代码块是使用monitorenter 和 monitorexit两个JVM指令实现的。monitorenter指令是在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法结束处和异常处。</li><li>在任何时候任何线程执行到monitorenter成功之前都必须从主内存中获取数据，在monitorexit运行成功之后，共享资源被更新后的值必须刷入主内存。</li></ul></li><li>synchronized的指令严格遵守java happens-before规则，一个monitorexit指令之前必定要有一个monitorenter指令。</li><li>Java中每个对象都可以作为锁，这是synchronized实现同步的基础，具体表现形式如下<ul><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，所示当前类的Class对象</li><li>对于同步方法块，锁是synchronized括号里设置的对象</li></ul></li></ul><h2 id="synchronized堆栈分析-amp-JVM指令分析"><a href="#synchronized堆栈分析-amp-JVM指令分析" class="headerlink" title="synchronized堆栈分析&amp;JVM指令分析"></a>synchronized堆栈分析&amp;JVM指令分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程:"</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadTest test = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，在test方法中使用同步代码块方式进行的线程同步，在main方法中定义了2个线程调用test方法，由于同步代码块的互斥性，只能有一个线程获取了mutex monitor的锁，其它的线程只能进入阻塞状态，等待获取mutex monitor的锁的线程释放锁，我可以用JDK自带的工具jconsole来查看堆栈信息，运行上面代码，打开jconsole会看到如下图所示：</p><p><img src="http://file.yuxuan.video/15582414008504.jpg" alt=""></p><ul><li>然后我们选中我们运行的程序连接，然后点开线程一栏查看：</li></ul><p><img src="http://file.yuxuan.video/15582414972082.jpg" alt=""><br><img src="http://file.yuxuan.video/15582415222130.jpg" alt=""></p><ul><li>我们可以很清楚看到我们创建的两个线程，Thread-0和Thread-1，此时Thread-0处于RUNNABLE状态也就是就绪状态，而Thread-1处于BLOCKED状态，并且清楚的告诉了我们锁拥有者是Thread-0线程。我们再通过jstack命令打印进程的线程的堆栈信息，截取关键的地方对其进行分析：</li></ul><p><img src="http://file.yuxuan.video/15582424874906.jpg" alt=""></p><p>Thread-0持有monitor <0x00000007976030e0> 的锁，Thread1线程进入BLOCKED状态并且等待着获取monitor <0x00000007976030e0>。</0x00000007976030e0></0x00000007976030e0></p><p>下面我们再通过JDK命令javap对ThreadTest类进行反汇编，会发现输出了大量的JVM指令，在这些指令中，会发现monitor enter和monitor exit是成对出现的（有些时候会出现一个monitor enter，多个monitor exit，但是每一个monitor exit之前必有对应的monitor enter)，运行如下的命令：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javap -c ThreadTest</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yuxuan</span>.<span class="title">thread2</span>.<span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.yuxuan.thread2.ThreadTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">10</span>: dup</span><br><span class="line">      11: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      14: ldc           #5                  // String 当前线程:</span><br><span class="line">      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      19: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      22: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">34</span>: aload_1</span><br><span class="line">      <span class="number">35</span>: monitorexit</span><br><span class="line">      <span class="number">36</span>: goto          <span class="number">44</span></span><br><span class="line">      <span class="number">39</span>: astore_2</span><br><span class="line">      <span class="number">40</span>: aload_1</span><br><span class="line">      <span class="number">41</span>: monitorexit</span><br><span class="line">      <span class="number">42</span>: aload_2</span><br><span class="line">      <span class="number">43</span>: athrow</span><br><span class="line">      <span class="number">44</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="Monitorenter"><a href="#Monitorenter" class="headerlink" title="Monitorenter"></a>Monitorenter</h3><p>一个monitor的lock的锁只会被一个线程在同一时间获得，在一个线程尝试获取monitor的所有权时会发生下面几件事：</p><ul><li>如果monitor的计数器为0，则代表该monitor的lock还没有被获得，一旦被某个线程获得之后会即将对该monitor的计数器加一，也就意味着该线程就是这个monitor的所有者了。</li><li>如果一个已经拥有该monitor所有权的线程重入，则会导致monitor计数器累加。</li><li>如果monitor已经被其他线程拥有，则其他线程尝试获取该monitor所有权时，会陷入阻塞状态直到monitor计数器变为0，才能再次尝试获取monitor的所有权</li></ul><h3 id="Monitorexit"><a href="#Monitorexit" class="headerlink" title="Monitorexit"></a>Monitorexit</h3><p>释放monitor所有权的过程相对比较简单，就是将monitor的计数器减一，如果计数器为0，那就意味着该线程不再拥有对该monitor的所有权，也就是我们常说的解锁。在此同时被该monitor block的线程将再次尝试获取该monitor的所有权。</p><h2 id="使用synchronized的注意点"><a href="#使用synchronized的注意点" class="headerlink" title="使用synchronized的注意点"></a>使用synchronized的注意点</h2><ul><li>与monitor关联的对象不能为空，也就是锁对象不能为null。</li><li>synchronized作用于太大，如果synchronized作用于越大，则代表期效率越低。</li><li>不同的monitor企图锁相同的方法或者代码块。</li><li>多个锁的交叉从而导致死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、【Java并发】线程间通信之wait,notify,notifyAll</title>
      <link href="/thread_four/"/>
      <url>/thread_four/</url>
      
        <content type="html"><![CDATA[<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>在多线程编程当中，很多时候我们需要一个线程修改了某个值之后，而另外一个线程能够感知到变化从而进行响应的操作。比较笨的方法呢就是不断轮询判断，如果条件满足进行响应的操作，反之则等待若干时间后再次轮询判断。就如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure></p><p>上面这段伪代码看似能够实现所需的功能，但是却有着很严重的问题：</p><ul><li>难以确保及时性。在休眠的时候，确实不会消耗处理器资源，但是通过睡眠机制，就不能及时的发现条件已经变化。</li><li>难以降低开销。如果降低睡眠的时间，比如1毫秒，这样确实能迅速的发现条件变化，但是却可能消耗更多的处理器资源，造成不必要的浪费。</li></ul><p>以上两个问题，看似矛盾难以取舍。但是Java通过等待/通知机制就能很好的解决问题并实现所需的功能。</p><h2 id="初识-wait-amp-notify"><a href="#初识-wait-amp-notify" class="headerlink" title="初识 wait &amp; notify"></a>初识 wait &amp; notify</h2><p>等待/通知相关方法是任意Java对象都具备的，因为这些方法是被定义在java.lang.Object对象上的，方法描述如下</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>notify()</td><td>通知一个在对象上等待的线程，使其从wait()方法返回，返回的前提是该线程重新获取到了对象的锁</td></tr><tr><td>notifyAll()</td><td>通知所有等待在改对象上的线程</td></tr><tr><td>wait()</td><td>调用该方法的线程进入阻塞状态并且会释放对象的锁，只有等待其他线程通知或被终端才会返回，</td></tr><tr><td>wait(long)</td><td>等待指定一段时间，时间一到就返回</td></tr><tr><td>wait(long,int)</td><td>等待指定一段时间，对于超时时间更加细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object  lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 开始"</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 结束"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 开始工作"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">                    <span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 开始"</span>);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 完成 开始睡眠"</span>);</span><br><span class="line">                    SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"睡眠结束即将释放锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出内容：<br><img src="http://file.yuxuan.video/15596987353536.jpg" alt=""></p><p>通过上面的示例代码，会发现使用wait/notfiy相关方法时需要注意一下细节：</p><ul><li>使用wait(),notify(),notifyAll()时需要先获取到该对象的锁。</li><li>使用wait()方法会使线程进入阻塞状态，并且会释放锁。</li><li>调用notify(),notifyAll()方法后，被通知的线程依旧不会从wait返回，需要调用notify()方法的线程释放锁之后，并且等待的线程重新获取到锁之后才会返回。</li><li>notify()方法是将等待队列中的一个等待线程从等待队列移到同步队列中，而notifyAll()方法是讲等待队列中的所有线程全部移到同步队列中</li></ul><h2 id="wait-amp-sleep-的区别"><a href="#wait-amp-sleep-的区别" class="headerlink" title="wait &amp; sleep 的区别"></a>wait &amp; sleep 的区别</h2><p>从表面上来看，wait和sleep都能使当前线程进入阻塞状态，但两者还是有着本质上的区别：</p><ul><li>wait和sleep方法都可以使线程进入阻塞状态，并且均是可中断方法，被中断后都会收到中断异常。</li><li>wait是Object方法，sleep是Thread独有的方法。</li><li>wait需要在同步方法中调用，而sleep不需要。</li><li>wait方法会释放锁，而sleep方法并不会释放锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、【Java并发】初识线程</title>
      <link href="/thread_one/"/>
      <url>/thread_one/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h2><p>对于计算机来说每一个任务就是一个进程，在进程运行过程中必须至少有一条线程实在运行中。线程本身是不会独立存在的，因为线程是进程中的一个执行路径。</p><p>操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU 分配的基本单位。在Java中，当我们启动main函数时其实就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p><blockquote><p>在单核CPU的计算机中，其实并没有真正的并行运算，一般是使用时间片轮转方式让线程轮询占用的，只不过快速的轮转调度带给你的错觉，让你产生了它们真的在同一时刻同时运行。当然如果是多核CPU,那么并行运行还是真实存在的。</p></blockquote><h2 id="2-JAVA中的线程创建和运行"><a href="#2-JAVA中的线程创建和运行" class="headerlink" title="2.JAVA中的线程创建和运行"></a>2.JAVA中的线程创建和运行</h2><p>Java中有三种线程的创建方式，分别为实现Runnable接口的run方法，集成Thread类重写run方法，使用FutureTask方式。</p><h3 id="首先来看看Thread类方式的实现"><a href="#首先来看看Thread类方式的实现" class="headerlink" title="首先来看看Thread类方式的实现"></a>首先来看看Thread类方式的实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread,重写run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出MyThread类继承了Thread类，并重写了run()方法。在 main 函数中创建了MyThread的实例并调用了start方式启动了线程。</p><p>使用继承有个不好的地方就是Java是不支持多继承的，所以如果使用了继承方式，那么就不能再继承其他类。还有就是任务与代码没有分离，当多个线程执行一样的任务时就会产生代码冗余。而Runable就没有这个限制。下面我们来看看Runnable接口的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，两个线程公用了一个代码逻辑，并且MyThread可以继承其他类。但是两种方式都有一个缺点，就是任务没有返回值。下面我们可以来看看FutureTask方式。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建任务</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;&gt;(myThread);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务执行完成,并返回结果</span></span><br><span class="line">            <span class="keyword">String</span> result = futureTask.<span class="keyword">get</span>();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的MyThread类实现了Callable接口的call()方法。在main函数中创建了一个FutrueTask对象，然后使用FutrueTask对象作为任务创建一个线程并启动。最后通过get()等待任务执行完成拿到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、【Java并发】线程生命周期以及常用方法详解</title>
      <link href="/thread_two/"/>
      <url>/thread_two/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>每个线程都有自己的生命周期，下面我们就来详细的了解一下。 </p><p><img src="http://file.yuxuan.video/15573707021512.jpg" alt=""></p><p>从上图我们可以看出线程的生命周期大致可以分为五个阶段：</p><ul><li>NEW(新建状态)</li><li>RUNNABLE(就绪状态)</li><li>RUNNING(运行状态)</li><li>BLOCKED(阻塞状态)</li><li>TERMINATED(死亡状态)</li></ul><h3 id="NEW-新建状态"><a href="#NEW-新建状态" class="headerlink" title="NEW(新建状态)"></a>NEW(新建状态)</h3><p>当我们new一个Thread对象时，此时它并不处于运行状态，因为还没有调用start方法启动线程。那么线程的NEW状态，其实只是Thread对象的状态，在没有调用start方法之前，该线程根本不存在，和new一个普通的Java对象没什么区别。NEW状态可以通过start方法进入RUNNABLE状态。</p><h3 id="RUNNABLE-就绪状态"><a href="#RUNNABLE-就绪状态" class="headerlink" title="RUNNABLE(就绪状态)"></a>RUNNABLE(就绪状态)</h3><p>线程对象进入RUNNABLE状态必须调用start方法，此时JVM进程中才会真正的创建一个线程，线程启动后并不会立即得到执行。线程是否运行和进程一样都要听从CPU的调度，为此我们把这个中间状态成为就绪状态，也称为可执行状态(RUNNABLE),也就是说它具备执行的资格，但是并没有真正的执行而是在等待CPU的调度。</p><p>由于存在Running状态，所以不会直接进人BLOCKED状态和TERMINATED状态，即使是在线程的执行逻辑中调用wait、sleep或者其他block的I0操作等，也必须先获得CPU的调度执行权才可以，严格来讲，RUNNABLE的线程只能意外终止或者进人RUNNING状态。</p><h3 id="RUNNING-运行状态"><a href="#RUNNING-运行状态" class="headerlink" title="RUNNING(运行状态)"></a>RUNNING(运行状态)</h3><p>一旦CPU通过时间片轮转或者其他方式选中了线程，那么此时它才能真正的执行自己的逻辑。这里需要注意的一点是一个正在RUNNING状态的线程其实也是RUNNABLE的，但是反过来则不成立。<br>在RUNNING状态中，线程的状态可以发生如下的状态转换：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者判断某个逻辑标识。</li><li>进人BLOCKED状态，比如调用了sleep,或者wait方法而加入了waitSet 中。</li><li>进行某个阻塞的I0操作，比如因网络数据的读写而进入了BLOCKED状态。</li><li>获取某个锁资源，从而加入到该锁的阻塞队列中而进人了BLOCKED状态。</li><li>由于CPU的调度器轮询使该线程放弃执行，进人RUNNABLE状态。</li><li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态。</li></ul><h3 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED(阻塞状态)"></a>BLOCKED(阻塞状态)</h3><p>上面列举了线程进入BLOCKED状态的原因，下面我们在列举线程在BLOCKED状态中可能切换的状态：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡(JVM Crash)。</li><li>线程阻塞的操作结束，比如读取了想要的数据字节进人到RUNNABLE状态。</li><li>线程完成了指定时间的休眠，进人到了RUNNABLE状态。</li><li>Wait中的线程被其他线程notify/notifyall唤醒，进人RUNNABLE状态。</li><li>线程获取到了某个锁资源，进人RUNNABLE状态。</li><li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进人RUNNABLE状态。</li></ul><h3 id="TERMINATED-死亡状态"><a href="#TERMINATED-死亡状态" class="headerlink" title="TERMINATED(死亡状态)"></a>TERMINATED(死亡状态)</h3><p>TERMINATED状态是线程最终状态，在该状态的线程不会再切换到其它任何状态，意味着线程的整个生命周期都结束了。</p><h2 id="Thread-API详解"><a href="#Thread-API详解" class="headerlink" title="Thread API详解"></a>Thread API详解</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><blockquote><p>sleep是一个静态方法，其有两个重载方法，其中一个需要传入毫秒，另外一个既需要毫秒数，还需要纳秒数<br>public static native void sleep(long millis) throws InterruptedException;<br>public static void sleep(long millis, int nanos) throws InterruptedException</p></blockquote><p>sleep方法会使当前线程休眠指定的毫秒数，暂停执行，其中有个要注意的点，sleep并不会释放锁资源。</p><p>JDK1.5以后，JDK引入了一个枚举TimeUnit，其对sleep做了很好的封装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一天</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一小时</span></span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一毫秒</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield也是一个静态方法，调用此方法会提醒调度器我愿意放弃当前的cpu资源，如果CPU资源不紧张的话，调度器可能会忽略这个提醒。操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度，而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片中还没有使用完的部分自己不想使用了，这暗示线程调度器现在就可以进行下一轮的线程调度。</p><blockquote><p>sleep 与 yield 方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂 起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield 方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。</p></blockquote><h3 id="setPriority-amp-getPriority-线程优先级"><a href="#setPriority-amp-getPriority-线程优先级" class="headerlink" title="setPriority()&amp;getPriority() 线程优先级"></a>setPriority()&amp;getPriority() 线程优先级</h3><p>在操作系统中，进程有优先级之分，线程同样也有优先级，理论上优先级高的线程有被CPU优先调度的机会，但真实情况往往并不会如你所愿，因为设置线程优先级也是一个hint(暗示)操作。</p><ul><li>对于root用户，它会hint操作系统你想要设置的优先级别，否则它会被忽略。</li><li>在CPU比较忙的情况下，设置优先级可能会获取更多的CPU调度机会，但是闲时优先级的高低一般不会有任何作用。</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单来看看设置优先级方法的源码</span></span><br><span class="line"><span class="keyword">public</span> final void setPriority(int <span class="keyword">new</span><span class="type">Priority</span>) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Priority</span> &gt; MAX_PRIORITY || <span class="keyword">new</span><span class="type">Priority</span> &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Priority</span> &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                <span class="keyword">new</span><span class="type">Priority</span> = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = <span class="keyword">new</span><span class="type">Priority</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析如上代码，可以看出线程的优先级必须是1~10，如果指定的线程优先级大于线程所在的group的优先级，那么会忽略指定的优先级从而获取group的最大优先级。线程默认的优先级和创建它的那个线程保持一致，一般情况下都是5.</p><h3 id="获取线程ID-getId"><a href="#获取线程ID-getId" class="headerlink" title="获取线程ID getId()"></a>获取线程ID getId()</h3><p>getId()获取线程的唯一ID,线程的ID在整个JVM进程中都是唯一的。</p><h3 id="线程-interrupt相关方法"><a href="#线程-interrupt相关方法" class="headerlink" title="线程 interrupt相关方法"></a>线程 interrupt相关方法</h3><ul><li><p>interrupt()方法<br>在线程内部存在着名为interrupt flag的标识，如果一个线程调用了interrupt方法，flag会被设置，但是如果当前线程正处于阻塞状态时，调用interrupt，线程将会中断阻塞，并且会抛出InterruptedException异常，这个异常就像是一个signal(信号)一样通知当前线程被打断了，并且flag会被清除。</p></li><li><p>isInterrupted()方法<br>此方法是Thread类的实例方法，主要判断当前线程是否被中断。</p></li><li><p>interrupted()方法<br>此方法是Thread中的一个静态方法，也是主要用于判断当前线程是否被中断，但是它和isInterrupted()方法有个区别就是该方法会直接清除掉该线程的interrupt标识</p></li></ul><h3 id="线程join方法"><a href="#线程join方法" class="headerlink" title="线程join方法"></a>线程join方法</h3><p>join方法会使当前线程永远的等待下去，直到期间被另外的线程中断，或者join的线程执行结束，也可以使用另外两个重载方法，指定等待毫秒数，在指定的时间到达之后，当前线程也回退出阻塞。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">join</span><span class="params">()</span></span> 一直等待</span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">(long millis)</span></span> 等待指定毫秒数</span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">(long millis, int nanos)</span></span> 等待指定毫秒数</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 简单工厂模式</title>
      <link href="/pattern_simple_factory/"/>
      <url>/pattern_simple_factory/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>简单工厂模式又称之为静态工厂方法(Static Factory Method), 属于创建型模式。简单工厂模式是根据传递的参数不同, 返回不同实现类的实例对象.（这些类都依赖一个父类或接口） </p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看简单工厂模式的组成"><a href="#我们先简单的来看看简单工厂模式的组成" class="headerlink" title="我们先简单的来看看简单工厂模式的组成:"></a>我们先简单的来看看简单工厂模式的组成:</h3><blockquote><ol><li>工厂类角色(Factory): 工厂类是工厂模式的最重要的组成部分. 向外提供一个创建方法,该方法会根据传递的参数来返回对应的实现类的实例对象。</li><li>抽象产品角色(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现角色(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    car = <span class="keyword">new</span> RedCar();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象Car类"><a href="#抽象Car类" class="headerlink" title="抽象Car类"></a>抽象Car类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> RedCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Car实现类"><a href="#Car实现类" class="headerlink" title="Car实现类"></a>Car实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"red car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 黑色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"black car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>明确了各自的职责和权利，有利于整个软件体系结构的优化</li><li>使用方无须知道创建类的过程,只需要提供对应的参数即可.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于工厂集中了所有对象的创建逻辑,一旦工厂出了问题,就会导致整个系统受到影响.</li><li>系统扩展受限,一旦添加新的对象就需要修改工厂逻辑,在对象类型过多时,势必会导致工厂逻辑过于复杂和臃肿,不利于系统的扩展和维护</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>简单工厂的好处就在于你需要什么,只需要传递一个规则内的参数,就可以获取到所需要的对象.</li><li>简单工厂的核心理念就是把对象的创建和对象的使用分离开来.为此当对象类型过多时势必会导致创建环节的臃肿</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 工厂方法模式</title>
      <link href="/pattern_factory_method/"/>
      <url>/pattern_factory_method/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂方法模式又称工厂模式,也叫多态工厂模式,属于类创建型模式<br>工厂方法模式实质就是: 把创建对象的过程抽象出来不实现,让其子类或实现类来决定实例化那个类.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看工厂模式的组成"><a href="#我们先简单的来看看工厂模式的组成" class="headerlink" title="我们先简单的来看看工厂模式的组成:"></a>我们先简单的来看看工厂模式的组成:</h3><blockquote><ol><li>抽象工厂(abstract factory): 抽象对象.</li><li>具体工厂实现(real factory): 实际创建对象的工厂,负责创建一个或多个对象。</li><li>抽象产品(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="抽象Car"><a href="#抽象Car" class="headerlink" title="抽象Car"></a>抽象Car</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* car抽象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 车俩启动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体Car实现"><a href="#具体Car实现" class="headerlink" title="具体Car实现"></a>具体Car实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BMW run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"QQ run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体工厂实现"><a href="#具体工厂实现" class="headerlink" title="具体工厂实现"></a>具体工厂实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BMWCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QQCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a>工厂方法模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在工厂方法模式中，使用方只需要知道所要对象的具体工厂，无须关心具体的创建过程，甚至不需要具体类的类名</li><li>在系统增加新的对象时，我们只需要添加一个具体实现类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次增加一个对象时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式完全符合“开闭原则”。</li><li>工厂方法模式使用继承，将对象的创建交给子类，通过子类实现工厂方法来创建对象。</li><li>工厂方法让子类决定要实例化的类是哪一个。</li><li>在工厂方法模式中，创建者通常会包含依赖于抽象产品的代码，而这些抽象产品是、由子类创建的，创建者不需要真的知道在制作哪种具体产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 单例模式</title>
      <link href="/pattern_singleton/"/>
      <url>/pattern_singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序在运行时，通常都会生成很多实例。例如，表示字符串的 String 类的实例与字符串是一一对应的关系，所以当有 1000 个字符串的时候，会生成 1000 个实例。</p><p>但是，当我们想在程序中表示某个东西只会存在一个时，就会有“只能创建-一个实例”的需求。典型的例子有表示程序所运行于的那台计算机的类、表示软件系统相关设置的类，以及表示视窗系统（window system）的类。<br>当然，只要我们在编写程序时多加注意，确保只调用一次 new MyClass（），就可以达到只生成一个实例的目的。但是，如果我们不想“必须多加注意才能确保生成一个实例”，而是要达到如下目的时，应当怎么做呢？</p><ul><li>想确保任何情况下都绝对只有 1 个实例</li><li>想在程序上表现出“只存在一个实例”</li></ul><p>像这样的确保只生成-一个实例的模式被称作 Singleton 模式。Singleton 是指只含有一个元素的集合。因为本模式只能生成一个实例，因此以 Singleton 命名。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>众所周知,一个类的实例对象产生是通过构造函数来完成的. 因此如果不想让外界随意新建对象的话我们可以通过把构造函数私有化. 当然为了让类保证可用, 就需要自己提供一个可以返回自己的实例对象的通道, 一般我们使用静态方法来暴露实例对象.</p><p>实现单例模式的方式有很多种,不同的方式都有不同的优缺点,下面我们就来一一讲解:</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--饿汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的单例实现,一般称之为饿汉式.为何叫饿汉式,这个比喻很形象,可以看出上面的对象其实在类第一次被加载后就被创建了.这样有个好处就是避免了线程安全问题.但是这样另外一个问题,因为对象实在类被第一次加载后就被创建了,可能会造成不必要的消耗,因为有可能这个实力不会被用到.基于这个原因从而引出另一个实现方式: <code>懒汉式</code>,下面我们来看看:</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象被使用时才初始化</span></span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">             lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式就叫做懒汉式。懒汉，顾名思义就是不会提前把实例对象创建出来，而是将创建的动作放在了第一次使用的时候.</p><p>但是,仔细一看就会发现上面的实现方式存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时需要使用此对象,从而存在同时进入if语句中，最后在两个线程执行完方法后创建了两个不同的对象. 针对这个问题, 我们尝试做出如下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 私有构造</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> lazy;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过修改之后,我们发现可以通过加锁的方式来解决了线程同步的问题.</p><p>但是熟悉Java内存模式的同学会发现还是会存在潜在的危险.</p><blockquote><p>在J2SE1.5版本之前使用双重锁检查时会有潜在的危险,有时会正常工作,有时候会因为线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。此问题在J2SE 5.0中被处理了.我们可以通过volatile关键字来处理</p></blockquote><p>我们只需要在我们声明的对象上加上<code>volatile</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy lazy;</span><br></pre></td></tr></table></figure><p>好了,到此关于线程安全的问题我们解决了.</p><p>现在我们再来考虑一个问题, 做过java的同学,想必对反射和序列化不陌生.为什么在这里提这两个呢? 因为这两个可能会破坏我们的单例.(具体什么原因,后面我会有详细的文章介绍).针对这个问题我们可以做出如下修改就可以解决:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们只需要在单例类里定义此方法就能解决</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lazy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
