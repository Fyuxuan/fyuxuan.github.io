<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>（一）Kubernetes简介：Kubernetes架构</title>
      <link href="/kubernetes/k8s1/"/>
      <url>/kubernetes/k8s1/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。<br>Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。<br>Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p><h2 id="Borg简介"><a href="#Borg简介" class="headerlink" title="Borg简介"></a>Borg简介</h2><p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。</p><p>Borg主要由BorgMaster、Borglet、borgcfg和Scheduler组成，如下图所示</p><p>  <img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662939314245.jpg" alt="-w572"><br>  <img src="https://upload-images.jianshu.io/upload_images/1455014-5262ffd168735d45.jpg" alt="-w572"></p><ul><li>BorgMaster 是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中；</li><li>Scheduer 负责任务的调度，根据应用的特点将其调度到具体的机器上去；</li><li>Borglet 负责真正运行任务（在容器中）；</li><li>borgcfg 是 Borg 的命令行工具，用于跟 Borg 系统交互，一般通过一个配置文件来提交任务。</li></ul><h2 id="Kubernetes-特性"><a href="#Kubernetes-特性" class="headerlink" title="Kubernetes 特性"></a>Kubernetes 特性</h2><p>Kubernetes 是一种用于在一组主机上运行和协同容器化应用程序的系统，旨在提供可预测性、可扩展性与高可用性的方法来完全管理容器化应用程序和服务的生命周期的平台。用户可以定义应用程序的运行方式，以及与其他应用程序或外部世界交互的途径，并能实现服务的扩容和缩容，执行平滑滚动更新，以及在不同版本的应用程序之间调度流量以测试功能或回滚有问题的部署。 Kubernetes 提供了接口和可组合的平台原语，使得用户能够以高度的灵活性和可靠性定义及管理应用程序。简单总结起来，它具有以下几个重要特性 。</p><h3 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1. 自动装箱"></a>1. 自动装箱</h3><p>建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并 通过调度机制混合关键型应用和非关键型应用的工作负载于同一节点以提升资源利用率。</p><h3 id="2-自我修复（自愈）"><a href="#2-自我修复（自愈）" class="headerlink" title="2. 自我修复（自愈）"></a>2. 自我修复（自愈）</h3><p>支持容器故障后自动重启、节点故障后重新调度容器，以及其他可用节点、健康状态 检查失败后关闭容器并重新创建等自我修复机制。</p><h3 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3. 水平扩展"></a>3. 水平扩展</h3><p>支持通过简单命令或 UI 手动水平扩展，以及基于 CPU 等资源负载率的自动水平扩展机制 。</p><h3 id="4-服务发现和负载均衡"><a href="#4-服务发现和负载均衡" class="headerlink" title="4. 服务发现和负载均衡"></a>4. 服务发现和负载均衡</h3><p>Kubernetes 通过其附加组件之一的 KubeDNS （或 CoreDNS ）为系统内置了服务发现功能，它会为每个 Service 配置 DNS 名称，并允许集群内的客户端直接使用此名称发出访问请求，而 Service 则通过 iptables 或 ipvs 内建了负载均衡机制 。</p><h3 id="5-自动发布和回滚"><a href="#5-自动发布和回滚" class="headerlink" title="5. 自动发布和回滚"></a>5. 自动发布和回滚</h3><p>Kubernetes 支持“灰度”更新应用程序或其配置信息，它会监控更新过程中应用程序的健康状态，以确保它不会在同一时刻杀掉所有实例，而此过程中一旦有故障发生，就会立即自动执行回滚操作 。</p><h3 id="6-密钥和配置管理"><a href="#6-密钥和配置管理" class="headerlink" title="6. 密钥和配置管理"></a>6. 密钥和配置管理</h3><p>Kubernetes 的 ConfigMap 实现了配置数据与 Docker 镜像解稠，需要时，仅对配置做出变更而无须重新构建 Docker 镜像，这为应用开发部署带来了很大的灵活性。此外，对于应用所依赖的一些敏感数据，如用户名和密码、令牌、密钥等信息， Kubernetes 专门提供了 Secret 对象为其解耦，既便利了应用的快速开发和交付，又提供了一定程度上的安全保障。</p><h3 id="7-存储编排"><a href="#7-存储编排" class="headerlink" title="7. 存储编排"></a>7. 存储编排</h3><p>Kubernetes 支持 Pod 对象按需自动挂载不同类型的存储系统 ，这包括节点本地存储、公有云服务商的云存储（如 AWS 和 GCP 等），以及网络存储系统（例如， NFS、iSCSI、GlusterFS、Ceph、Cinder 和 Flocker 等）。</p><h3 id="8-批量处理执行"><a href="#8-批量处理执行" class="headerlink" title="8. 批量处理执行"></a>8. 批量处理执行</h3><p>除了服务型应用，Kubernetes 还支持批处理作业及 CI（持续集成），如果需要， 一样可以实现容器故障后恢复。</p><h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><p>Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Labels 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像，如下图所示</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662946967695.jpg" alt=""></p><p>Kubernetes 主要由以下几个核心组件组成：</p><ul><li>etcd 保存了整个集群的状态；</li><li>kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li><li>kube-controller-manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>kube-scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li><li>kubelet 负责维持容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），默认的容器运行时为 Docker；</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的 Add-ons：</p><ul><li>CoreDNS 负责为整个集群提供 DNS 服务</li><li>Ingress Controller 为服务提供外网入口</li><li>Heapster 提供资源监控</li><li>Dashboard 提供 GUI</li><li>Federation 提供跨可用区的集群</li><li>Fluentd-elasticsearch 提供集群日志采集、存储与查询</li></ul><h2 id="Kubernetes架构示意图"><a href="#Kubernetes架构示意图" class="headerlink" title="Kubernetes架构示意图"></a>Kubernetes架构示意图</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>下图清晰表明了Kubernetes的架构设计以及组件之间的通信协议。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663927970976.jpg" alt="Kuberentes架构（图片来自于网络）"></p><p>下面是更抽象的一个视图：</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928276452.jpg" alt="kubernetes整体架构示意图"></p><h3 id="Master架构"><a href="#Master架构" class="headerlink" title="Master架构"></a>Master架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928485300.jpg" alt="Kubernetes master架构示意图"></p><h3 id="Node架构"><a href="#Node架构" class="headerlink" title="Node架构"></a>Node架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928706968.jpg" alt="kubernetes node架构示意图"></p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928960235.jpg" alt="Kubernetes分层架构示意图"></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li><li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</li><li>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</li><li>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）Kubernetes简介：核心资源对象&amp;核心组件</title>
      <link href="/kubernetes/k8s2/"/>
      <url>/kubernetes/k8s2/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群是配置 Kubernetes 的所有组件、功能和工作负载的物理平台。 集群中一台服务器（或高可用部署中的一组服务器）用作 Master ，负责管理整个集群，余下的其他机器用作 Worker Node ，它们是使用本地和外部资源接收和运行工作负载的服务器。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>Master 是集群的网关和中枢，负责为用户和客户端暴露 API ，跟踪其他服务器的健 康状态、以最优方式调度工作负载，以及编排其他组件之间的通信等任务，它是用户或客户端与集群之间的核心联络点，并负责 Kubernetes 系统的大多数集中式管控逻辑。 单个 Master 节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是 Kubernetes 集群的工作节点，负责接收来自 Master 的工作指令并根据指令相应地创建或销毁 Pod 对象，以及调整网络规则以合理地路由和转发流量等。 理论上讲，Node 可以是任何形式的计算设备，不过 Master 会统一将其抽象为 Node 对象进行管理。</p><p>Kubernetes 将所有 Node 的资源集结于一处形成一台更加强大的“服务器”，在用户将应用部署于其上时，Master 会使用调度算法将其自动指派至某个特定的 Node 运行。在 Node 加入集群或从集群中移除时 Master 也会按需重新编排影响到的 Pod（容器）。于是，用户无须关心其应用究竟运行于何处。</p><p>从抽象的视角来讲， Kubernetes 还有着众多的组件来支撑其内部的业务逻辑，包括运行应用、应用编排、服务暴露、应用恢复等，它们在 Kubernetes 中被抽象为Pod、Label、Annotation、Ingress、Service、Controller等资源对象。</p><h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Kubernetes 并不直接运行容器，而是使用一个抽象的资源对象来封装一个或者多个容器，这个抽象为 Pod ，它也是 Kubernetes 的最小调度单元。同一 Pod 中的容器共享网络名称空间和存储资源，这些容器可经由本地回环接口 lineout 直接通信，但彼此之间又在 Mount、User 及 PID 等名称空间上保持了隔离。尽管 Pod 中可以包含多个容器，但是作为最小调度单元，它应该尽可能地保持“小”，即通常只应该包含一个主容器。</p><h3 id="Label-资源标签"><a href="#Label-资源标签" class="headerlink" title="Label 资源标签"></a>Label 资源标签</h3><p>标签（ Label ）是将资源进行分类的标识符，资源标签其实就是一个键值型（ key/values) 数据。标签旨在指定对象（如 Pod 等）辨识性的属性，这些属性仅对用户存在特定的意义，对 Kubernetes 集群来说并不直接表达核心系统语义。标签可以在对象创建时附加其上，并能够在创建后的任意时间进行添加和修改。一个对象可以拥有多个标签，一个标签也可以附加于多个对象（通常是同一类对象）之上</p><h3 id="标签选择器（-Selector-）"><a href="#标签选择器（-Selector-）" class="headerlink" title="标签选择器（ Selector ）"></a>标签选择器（ Selector ）</h3><p>标签选择器（ Selector ）全称为 “ Label Selector” 它是一种根据 Label 来过滤符合条件的资源对象的机制。 例如，将附有标签“ role:backend ”的所有 Pod 对象挑选出来归为一组就是标签选择器的一种应用，用户通常使用标签对资源对象进行分类，而后使用标签选择器挑选出它们，直接批量给挑选出来的资源对象做相应的操作。</p><h3 id="Pod-控制器"><a href="#Pod-控制器" class="headerlink" title="Pod 控制器"></a>Pod 控制器</h3><p>尽管 Pod 是 Kubernetes 的最小调度单元，但用户通常并不会直接部署及管理 Pod 对象，而是要借助于另一类抽象——控制器（Controller）对其进行管理。 用于工作负载的控制器是一种管理 Pod 生命周期的资源抽象，它们是 Kubernetes 上的一类对象，而非单个资源对象，包 括 ReplicationController、ReplicaSet、 Deployment、StatefulSet、Job 等 。 以 Deployment 控制器为例，它负责确保指定的 Pod 对象的副本数量精确符合定义，否则“多退少补”。使用控制器之后就不再需要手动管理 Pod 对象了，用户只需要声明应用的期望状态，控制器就会自动对其进行进程管理。</p><h3 id="服务资源（-Service"><a href="#服务资源（-Service" class="headerlink" title="服务资源（ Service )"></a>服务资源（ Service )</h3><p>Service 是建立在一组 Pod 对象之上的资源抽象，它通过标签选择器选定一组 Pod 对象， 并为这组 Pod 对象定义一个统一的固定访问入口（通常是一个 IP 地址），若 Kubernetes 集群存在 DNS 附件，它就会在 Service 创建时为其自动配置一个 DNS 名称以便客户端进行服务发现。 到达 Service IP 的请求将被负载均衡至其后的端点——各个 Pod 对象之上，因此 Service 从本质上来讲是一个四层代理服务。 另外， Service 还可以将集群外部流量引入到集群中来 。</p><h3 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h3><p>存储卷（ Volume ）是独立于容器文件系统之外的存储空间，常用于扩展容器的存储空间并为它提供持久存储能力。Kubernetes 集群上的存储卷大体可分为临时卷 、本地卷和网络卷。临时卷和本地卷都位于 Node 本地，一旦 Pod 被调度至其他 Node，此种类型的存储卷将无法访问到，因此临时卷和本地卷通常用于数据缓存，持久化的数据则需要放置于持久卷 (persistent volume ）之上。</p><h3 id="Name-和-Namespace"><a href="#Name-和-Namespace" class="headerlink" title="Name 和 Namespace"></a>Name 和 Namespace</h3><p>名称（ Name ）是 Kubernetes 集群中资源对象的标识符，它们的作用域通常是名称空间( Namespace ）因此名称空间是名称的额外的限定机制。在同一个名称空间中，同一类型资源对象的名称必须具有唯一性。名称空间通常用于实现租户或项目的资源隔离，从而形成逻辑分组。创建资源对象未指定名称空间时 ，它们都属于默认的名称空间“ default ” 。</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>Annotation（注解）是另一种附加在对象之上的键值类型的数据，但它拥有更大的数据容量。Annotation常用于将各种非标识型元数据（ metadata ） 附加到对象上，但它不能用于标识和选择对象，通常也不会被 Kubernetes 直接使用，其主要目的是方便工具或用户的阅读及查找等</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Kubernetes 将 Pod 对象和外部网络环境进行了隔离，Pod 和 Service 等对象间的通信都使用其内部专用地址进行，如若需要开放某些 Pod 对象提供给外部用户访问，则需要为其请求流量打开一个通往 Kubernetes 集群内部的通道，除了Service之外，Ingress 也是这类通道的实现方式之一。</p><h2 id="Kubernetes集群组件"><a href="#Kubernetes集群组件" class="headerlink" title="Kubernetes集群组件"></a>Kubernetes集群组件</h2><p>一个典型的 Kubernetes 集群由多个工作节点和一个或多个Master节点，以及一个集群状态存储系统（ etcd ）组成。其中 Master 节点负责整个集群的管理工作， 为集群提供管理接口，并监控和编排集群中的各个工作节点。各个工作节点负责以 Pod 的形式运行容器，因此，各节点需要事先配置好容器运行依赖的所有服务和资源，如容器运行时环境（比如Docker）。</p><p>Master 节点主要是由 apiserver、 controller-manager 和 scheduler 三个组件，以及一个用于集群状态存储的 etcd 存储服务组成，而每个 Node 节点则主要包含 kubelet、kube-proxy 及容器引擎（ Docker是最为常用的实现）等组件。此外，完整的集群服务还依赖于一些附加组件，如 KubeDNS、Dashboard、Heapster、Ingress Controller 等。</p><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><p>API Server 负责输出 RESTful 风格的 Kubernetes API ，它是发往集群的所有 REST 操作命令的接入点，并负责接收、校验并响应所有的 REST 请求，结果状态被持久存储于 etcd 中。因此，API Server 是整个集群的网关。</p><h3 id="集群状态存储（etcd）"><a href="#集群状态存储（etcd）" class="headerlink" title="集群状态存储（etcd）"></a>集群状态存储（etcd）</h3><p>Kubernetes 集群的所有状态信息都需要持久存储于存储系统 etcd 中，不过， etcd 是由 CoreOS 基于 Raft 协议开发的分布式键值存储，可用于服务发现、共享配置以及一致性保障（如数据库主节点选择、分布式锁等）。因此，etcd 是独立的服务组件，并不隶属于 Kubernetes 集群自身。生产环境中应该以 etcd 集群的方式运行以确保其服务可用性。</p><p>etcd 不仅能够提供键值数据存储， 而且还为其提供了监昕（ watch ）机制，用于监听和推送变更。 Kubernetes 集群系统中，etcd 中的键值发生变化时会通知到 API Server ，并由其通过 watchAPI 向客户端输出。基于 watch 机制， Kubernetes 集群的各组件实现了高效协同 。</p><h3 id="控制器管理器（-Controller-Manager"><a href="#控制器管理器（-Controller-Manager" class="headerlink" title="控制器管理器（ Controller Manager )"></a>控制器管理器（ Controller Manager )</h3><p>Kubernetes 中，集群级别的大多数功能都是由几个被称为控制器的进程执行实现的，这几个进程被集成于 kube-controller-manager 守护进程中。由控制器完成的功能主要包括生命周期功能和 API 业务逻辑，具体如下。</p><ul><li>生命周期功能：包括 Namespace 创建和生命周期、 Event 垃圾回收、 Pod 终止相关的垃圾回收、级联垃圾回收及 Node 垃圾回收等 。</li><li>API业务逻辑：例如，由 ReplicaSet 执行的 Pod 扩展等 。</li></ul><h3 id="调度器（-Scheduler"><a href="#调度器（-Scheduler" class="headerlink" title="调度器（ Scheduler )"></a>调度器（ Scheduler )</h3><p>Kubernetes 是用于部署和管理大规模容器应用的平台，根据集群规模的不同，其托管运行的容器很可能会数以千计甚至更多。 API Server 确认 Pod 对象的创建请求之后， 便需要由 Scheduler 根据集群内各节点的可用资源状态，以及要运行的容器的资源需求做出调度决策。另外，Kubernetes 还支持用户自定义调度器</p><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet 是运行于工作节点之上的守护进程，它从 API Server 接收关于 Pod 对象的配置信息并确保它们处于期望的状态。 kubelet 会在 API Server 上注册当前工作节点， 定期向 Master 汇报节点资源使用情况，并通过 cAdvisor 监控容器和节点的资源占用状况 。</p><h3 id="容器运行时环境"><a href="#容器运行时环境" class="headerlink" title="容器运行时环境"></a>容器运行时环境</h3><p>每个 Node 都要提供一个容器运行时（ Container Runtime ）环境， 它负责下载镜像并运行容器。 kubelet 并未固定链接至某容器运行时环境，而是以插件的方式载入配置的容器环境。这种方式清晰地定义了各组件的边界。目前，Kubernetes 支持的容器运行环境至少包括Docker、RKT、cri-o 和 Fraki等。</p><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>每个工作节点都需要运行一个 kube-proxy 守护进程，它能够按需为 Service 资源对象生成 iptables 或 ipvs 规则，从而捕获访问当前 Service 的ClusterIP 的流量并将其转发至正确的后端 Pod 对象。</p><h3 id="KubeDNS"><a href="#KubeDNS" class="headerlink" title="KubeDNS"></a>KubeDNS</h3><p>KubeDNS 是在 Kubernetes 集群中调度运行提供 DNS 服务的 Pod，同一集群中的其他 Pod 可使用此 DNS 服务解决主机名。 Kubernetes 自 1.11 版本开始默认使用 CoreDNS 项目为集群提供服务注册和服务发现的动态名称解析服务，之前的版本中用到的是 kube-dns 项目，而 SkyDNS 则是更早一代的项目。</p><h3 id="Kubernetes-Dashboard"><a href="#Kubernetes-Dashboard" class="headerlink" title="Kubernetes Dashboard"></a>Kubernetes Dashboard</h3><p>Kubernetes 集群的全部功能都要基于 Web 的 UI，来管理集群中的应用甚至是集群自身。</p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><p>容器和节点的性能监控与分析系统，它收集并解析多种指标数据，如资源利用率、生命周期事件等。新版本的 Kubernetes 中，其功能会逐渐由 Prometheus 结合其他组件所取代。</p><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>Service 是一种工作于传统层的负载均衡器，而 Ingress 是在应用层实现的 HTTP (s）负载均衡机制。不过，Ingress 资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则需要通过 Ingress 控制器（ Ingress Controller) 发挥作用 。 目前，此类的可用项目有 Nginx、Traefik、Envoy 及 HAProxy 等。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）Kubernetes 之 pod</title>
      <link href="/kubernetes/k8s3/"/>
      <url>/kubernetes/k8s3/</url>
      
        <content type="html"><![CDATA[<p>pod 是一组并置的容器，代表了 Kubernetes 中的基本构建模块。在实际应用中我们并不会单独部署容器，更多的是针对一组 pod 的容器进行部署和操作。然而这并不意味着一个 pod 总是要包含多个容器，实际上只包含一个单独容器的 pod 也是非常常见的。值得注意的是，当一个 pod 包含多个容器时，这些容器总是运行于同一个工作节点上，一个 pod 绝不会跨越多个工作节点。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670631091472.jpg" alt="-w688"></p><p>在包含容器的 pod 下，我们可以同时运行一些密切相关的进程，并为它们提供几乎相同的环境，此时这些进程就好像全部运行于单个容器中一样，同时又保持着一定的隔离。这样一来，我们便能全面地利用容器所提供的特性，同时对这些进程来说它们就像运行在一起一样，实现两全其美 。</p><p>容器之间彼此是完全隔离的，但此时我们期望的是隔离容器组，而不是单个容器，并让每个容器组内的容器共享一些资源，而不是完全隔离。Kubernetes 通过配置 Docker 来让一个 pod 内的所有容器共享相同的 Linux 命名空间，而不是每个容器都有自己的一组命名空间。</p><p>由于一个 pod 中的所有容器都在相同的 network 和 UTS 命名空间下运行，所以它们都共享相同的主机名和网络接口。同样这些容器也都在相同的 IPC 命名空间下运行，因此能够通过 IPC 进行通信。在最新的 Kubernetes 和 Docker 版本中，它们也能够共享相同的 PID 命名空间，但是该特征默认是未激活的。</p><blockquote><p>当同一个 pod 中的容器使用单独的 PID 命名空间时，在容器中执行 ps aux 就只会看到容器自己的进程。</p></blockquote><p>但是当涉及文件系统时，情况就有所不同。由于大多数容器的文件系统来自容器镜像，因此默认情况下，每个容器的文件系统与其他容器完全隔离。但我们可 以使用 Volume 的 Kubernetes 资源来共享文件目录。</p><p>由于一个 pod 中的容器运行于相同的 Network 命名空间中，因此它们共享相同的 IP 地址和端口空间。这意味着在同－ pod 中的容器运行的多个进程需要注意不能绑定到相同的端口号，否则会导致端口冲突，但这只涉及同一 pod 中的容器。 由于每个 pod 都有独立的端口空间，对于不同 pod 中的容器来说永远不会遇到端口冲突。此外，一个 pod 中的所有容器也都具有相同的网络接口，因此容器可以通过 localhost 与同一 pod 中的其他容器进行通信。</p><p>Kubernetes 集群中的所有 pod 都在同一个共享网络地址空间中，这意味着每个 pod 都可以通过其他 pod 的 IP 地址来实现相互访问。它们之间没有 NAT（网络地址转换）网关。当两个 pod 彼此之间发送网络数据包时，它们都会将对方的实际 IP 地址看作数据包中的源 IP。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670648371662.jpg" alt="-w616"></p><h2 id="在-Kubernetes-中运行一个简单的-pod"><a href="#在-Kubernetes-中运行一个简单的-pod" class="headerlink" title="在 Kubernetes 中运行一个简单的 pod"></a>在 Kubernetes 中运行一个简单的 pod</h2><p>我们可以通过 kubectl run 命令， 该命令可以创建所有资源组件而无需 JSON 或 YAML 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl run yx-nginx --image=nginx  --port=80 --generator=run/v1</span><br></pre></td></tr></table></figure><ul><li>–image=nginx 指定运行的镜像</li><li>–port=80 告诉kubernetes应用正在监听80端口</li><li>–generator 一般来说不会使用它，这里使用是为了让kubernetes创建一个 ReplicationController而不是Deployment</li></ul><h3 id="列出-pod"><a href="#列出-pod" class="headerlink" title="列出 pod"></a>列出 pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   0/1     Pending   0          9m28s</span><br></pre></td></tr></table></figure><p>可以看到 pod 处于挂起状态，READY 列显示 0/1 代表 pod 的容器还未就绪。pod 还没有运行的 原因是：该 pod 被分配到的工作节点正在下载容器镜像，完成之后才可以运行。下载完成后，将创建 pod 的容器， 然后 pod 会变为运行状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   1/1     Running   0          9m28s</span><br></pre></td></tr></table></figure><p>再次列出 pod，可以发现 pod的状态已经发生改变了。</p><h3 id="查看pod详细信息"><a href="#查看pod详细信息" class="headerlink" title="查看pod详细信息"></a>查看pod详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod yx-nginx-2r4xf</span><br></pre></td></tr></table></figure><h2 id="使用描述文件创建-pod"><a href="#使用描述文件创建-pod" class="headerlink" title="使用描述文件创建 pod"></a>使用描述文件创建 pod</h2><p>YAML 格式的 Pod 定义文件的完整内容:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment">## 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">## 元数据 </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>  <span class="comment">## Pod 名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span> <span class="comment">## Pod 所属的命名空间 默认值为 default</span></span><br><span class="line"><span class="attr">  labels:</span> <span class="comment">## 自定义标签列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  annotations:</span> <span class="comment">## 自定义注解列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">##pod 中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span> <span class="comment">## 容器列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span> <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">string</span> <span class="comment">## 容器镜像名称</span></span><br><span class="line">    <span class="comment">## 镜像拉取策略: </span></span><br><span class="line">    <span class="comment">## Always(默认值): 表示每次都尝试重新拉取镜像。</span></span><br><span class="line">    <span class="comment">## IfNotPresent: 表示 如果本地有该镜像，则使用本地的镜像，本地不存在时拉取镜像。</span></span><br><span class="line">    <span class="comment">## Never: 表示仅使用本地镜像。</span></span><br><span class="line">    <span class="comment">## 下面几种情况系统将默认设置 imagePullPolicy=Always。</span></span><br><span class="line">    <span class="comment">## 1. 不设置 imagePullPolicy，也未指定镜像的 tag</span></span><br><span class="line">    <span class="comment">## 2. 不设置 imagePullPolicy，镜像 tag 为 latest</span></span><br><span class="line">    <span class="comment">## 3. 启用名为 AlwaysPullImages 的准入控制器（Admission Controller）</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never |IfNotPresent]</span></span><br><span class="line"><span class="string">command: [string] ## 容器的启动命令列表，如果不指定，则使用镜像打包时使用的启动命令。</span></span><br><span class="line"><span class="string">args: [string]  ## 容器的启动命令参数列表</span></span><br><span class="line"><span class="string">workingDir: string ## 容器的工作目录</span></span><br><span class="line"><span class="string">volumeMounts: ## 挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="string">- name: string ## 引用 pod 定义的共享存储卷的名称，需使用 volumes[]部分定义的共享存储卷名称</span></span><br><span class="line"><span class="string">  mountPath: string ## 存储卷在容器内 Mount 的绝对路径，应少于 512 个字符</span></span><br><span class="line"><span class="string">  readOnly: boolean ## 是否为只读模式，默认为读写模式</span></span><br><span class="line"><span class="string">ports: ## 容器需要暴露的端口号列表</span></span><br><span class="line"><span class="string">- name: string ## 端口的名称</span></span><br><span class="line"><span class="string">  containerPort: int ## 容器需要监听的端口号</span></span><br><span class="line"><span class="string">  hostPort: int ## 容器所在主机需要监听的端口号，默认与 containerPort 相同。设置 hostPort 时，同一台宿主机将无法启动该容器的第 2 份副本</span></span><br><span class="line"><span class="string">  protocol: string ## 端口协议，支持 TCP 和 UDP, 默认值为 TCP</span></span><br><span class="line"><span class="string">env:  ## 容器运行前需设置的环境变量列表</span></span><br><span class="line"><span class="string">- name: string ## 环境变量的名称</span></span><br><span class="line"><span class="string">  value: string ## 环境变量的值</span></span><br><span class="line"><span class="string">resources: ## 资源限制和资源请求的设置</span></span><br><span class="line"><span class="string">   limits: </span></span><br><span class="line"><span class="string">     cpu: string ## CPU 限制，单位为 core 数，将用于 docker run --cpu-shares 参数</span></span><br><span class="line"><span class="string">memory: string ## 内存限制，单位可以为 MiB、GiB等，将用于 docker run --memory 参数</span></span><br><span class="line"><span class="string">  requests :</span></span><br><span class="line"><span class="string">cpu: string ## CPU 请求，单位为 core 数，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">memory: string ## 内存请求，单位可以为 MiB、GiB等，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">livenessProbe :</span></span><br><span class="line"><span class="string">  exec:</span></span><br><span class="line"><span class="string">command: [string]</span></span><br><span class="line"><span class="string">  httpGet:</span></span><br><span class="line"><span class="string">path: string</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string">host: string</span></span><br><span class="line"><span class="string">scheme: string </span></span><br><span class="line"><span class="string">httpHeaders:</span></span><br><span class="line"><span class="string">- name: string</span></span><br><span class="line"><span class="string">  value: string</span></span><br><span class="line"><span class="string">  tcpSocket:</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string"></span><span class="attr">      initialDelaySeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      successThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]</span></span><br><span class="line"><span class="string"></span><span class="attr">  nodeSelector:</span> <span class="string">object</span></span><br><span class="line"><span class="attr">  imagePullSecrets:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  hostNetwork:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  volumes:</span> <span class="comment">## 在该 Pod 上定义的共享存储卷列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">emptyDir:</span> <span class="string">&#123;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="attr">hostPath:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">secret:</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">configMap:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure></p><h3 id="pod定义的主要几个部分"><a href="#pod定义的主要几个部分" class="headerlink" title="pod定义的主要几个部分"></a>pod定义的主要几个部分</h3><p>pod定义由这么几个部分组成：首先是YAML中使用的 kubernetes API 版本和 YAML 描述的资源类型，其次就是几乎在所有 kubernetes 资源中都可以找到的三大重要部分：</p><ul><li>metadata：包括名称，命名空间，标签和关于该容器的其他信息。</li><li>spec：包含 pod 内容的实际说明，例如 pod 的容器，卷和其他数据。</li><li>status：包含运行中的 pod 的当前信息，例如 pod 所处的条件，每个容器的描述和状态，以及内部IP和其他基本信息。</li></ul><h3 id="编写一个简单的-YAML-描述文件创建-pod"><a href="#编写一个简单的-YAML-描述文件创建-pod" class="headerlink" title="编写一个简单的 YAML 描述文件创建 pod"></a>编写一个简单的 YAML 描述文件创建 pod</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx</span> <span class="comment">##pod名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span> <span class="comment">## pod里运行那些容器</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span>  <span class="comment">## 镜像名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span>    <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">80</span> <span class="comment">## 容器运行监听的端口</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 kubectl explain 查找资源对象的属性<br>kubectl explain pod<br>kubectl explain pod.spec</p></blockquote><h4 id="使用-kubectl-create-来创建-pod"><a href="#使用-kubectl-create-来创建-pod" class="headerlink" title="使用 kubectl create 来创建 pod"></a>使用 kubectl create 来创建 pod</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f test-nginx.yaml</span><br><span class="line">``` </span><br><span class="line">&gt; kubectl create -f 命令用于从YAML或JOSN文件创建任何资源，不只是pod。</span><br><span class="line"></span><br><span class="line">#### 获取运行中 pod 的完整定义</span><br><span class="line">```shell</span><br><span class="line">kubectl get po test-nginx -o yaml</span><br><span class="line">kubectl get po test-nginx -o json</span><br></pre></td></tr></table></figure><h4 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h4><p>使用 kubectl logs 命令获取 pod 日志<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx</span><br></pre></td></tr></table></figure></p><p>获取多容器 pod 的日志时指定容器名称<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx -c test</span><br></pre></td></tr></table></figure></p><blockquote><p>kubectl logs 命令将显示当前容器的日志。 当你想知道为什么前一个容器终止时，你想看到的是前一个容器的日志，而不是当前容器的。可以通过添加 –previous 选项来完成：<br>kubectl logs test-nginx –previous</p></blockquote><h3 id="停止和移除-pod"><a href="#停止和移除-pod" class="headerlink" title="停止和移除 pod"></a>停止和移除 pod</h3><ul><li>按名称删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods test-nginx</span><br></pre></td></tr></table></figure><ul><li>使用标签选择器删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods -l env=debug</span><br></pre></td></tr></table></figure><ul><li>删除指定命名空间下的所有 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods --all -n test-namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（四）Kubernetes之标签-注解-命名空间</title>
      <link href="/kubernetes/k8s4/"/>
      <url>/kubernetes/k8s4/</url>
      
        <content type="html"><![CDATA[<h1 id="Label-标签"><a href="#Label-标签" class="headerlink" title="Label 标签"></a>Label 标签</h1><p>标签是一种简单却功能强大的 kubernetes 特性，不仅可以组织 pod，也可以组织所有其他的 kubernetes 资源。详细来讲 ，标签是可以附加到资源的任意键值对，用以选择具有该确切标签的资源（这是通过标签选择器完成的）。只要标签的 key 在资源内是唯一的，一个资源便可以拥有多个标签。通常在我们创建资源时就会将标签附加到资源上，但之后我们也可以再添加其他标签，或者修改现有标签的值，而无须重新创建资源。</p><h2 id="创建-pod-时指定标签"><a href="#创建-pod-时指定标签" class="headerlink" title="创建 pod 时指定标签"></a>创建 pod 时指定标签</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx-label</span></span><br><span class="line">    <span class="comment">## 添加标签</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">        auth:</span> <span class="string">yuxuan</span></span><br><span class="line"><span class="attr">        env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 创建 pod</span><br><span class="line">kubectl create -f test-nginx-labels.ymal</span><br><span class="line">## 列出pod 并列出label</span><br><span class="line">kubectl get pods --show-labels</span><br><span class="line">## 只列出感兴趣的标签 可以使用 -L 指定并显示在单独的列中</span><br><span class="line">kubectl get pods -L auth</span><br></pre></td></tr></table></figure><h2 id="修改现有-pod-的标签"><a href="#修改现有-pod-的标签" class="headerlink" title="修改现有 pod 的标签"></a>修改现有 pod 的标签</h2><p>标签也可以在现有的 pod 上进行添加和修改。现在来给前面创建的 test-nginx pod来添加标签吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 添加标签</span><br><span class="line">kubectl label pods test-nginx env=test</span><br><span class="line">## 修改现有的标签 需要使用--overwrite</span><br><span class="line">kubectl label pods test-nginx env=debug --overwrite</span><br></pre></td></tr></table></figure></p><h2 id="通过标签选择器列出-pod-子集"><a href="#通过标签选择器列出-pod-子集" class="headerlink" title="通过标签选择器列出 pod 子集"></a>通过标签选择器列出 pod 子集</h2><p>标签要与标签选择器结合在一起。标签选择器允许我们选择标记有特定标签的 pod 子集，并对这些 pod 执行操作。可以说标签选择器是一种能够根据是否包含具有特定值的特定标签来过滤资源的准则。标签选择器根据资源的以下条件来选择资源：</p><ul><li>包含（或不包含〉使用特定键的标签 </li><li>包含具有特定键和值的标签 </li><li>包含具有特定键的标签，但其值与我们指定的不同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 列出指定标签的 pod </span><br><span class="line">kubectl get pods --show-labels -l env</span><br><span class="line">## 列出指定标签,指定标签值的 pod </span><br><span class="line">kubectl get pods --show-labels -l env=prod</span><br><span class="line">## 列出没有指定标签的 pod</span><br><span class="line">kubectl get pods --show-labels -l &apos;!env&apos;</span><br><span class="line">## 列出标签值不等于某个值的 pod</span><br><span class="line">get pods --show-labels -l &apos;env!=prod&apos;</span><br><span class="line">## in</span><br><span class="line">get pods --show-labels -l &apos;env in (prod,debug)&apos;</span><br><span class="line">## notin</span><br><span class="line">get pods --show-labels -l &apos;env notin (prod,debug)&apos;</span><br><span class="line">## 多个条件用逗号分隔</span><br><span class="line">get pods --show-labels -l &apos;env in (prod,debug),auth=yuxuan&apos;</span><br></pre></td></tr></table></figure><h2 id="使用标签和选择器来约束-pod-调度"><a href="#使用标签和选择器来约束-pod-调度" class="headerlink" title="使用标签和选择器来约束 pod 调度"></a>使用标签和选择器来约束 pod 调度</h2><p>pod 并不是唯一可以附加标签的 Kubernetes 资源。标签可以附加到任何 Kubernetes 对象上，包括节点。我们可以通过标签来控制 pod 调度到特定的节点。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 列出集群node</span><br><span class="line">kc get nodes --show-labels</span><br><span class="line"><span class="meta">#</span># 给指点节点打上标签</span><br><span class="line">kc label node 192.168.1.230 env=test</span><br></pre></td></tr></table></figure></p><p>在yaml里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: pod</span><br><span class="line">metadata:</span><br><span class="line">    name: test-nginx-label</span><br><span class="line">    ## 添加标签</span><br><span class="line">    labels:</span><br><span class="line">        auth: yuxuan</span><br><span class="line">        env: prod</span><br><span class="line">spec:</span><br><span class="line">    ## 控制该pod 只调度在标签 env=test的节点上</span><br><span class="line">    nodeSelector:</span><br><span class="line">        env: &quot;test&quot;</span><br><span class="line">    containers:</span><br><span class="line">    - image: nginx</span><br><span class="line">      name: test</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br><span class="line">        protocol: TCP</span><br></pre></td></tr></table></figure></p><h1 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations 注解"></a>Annotations 注解</h1><p>除标签外，pod 和其他对象还可以包含注解。注解也是键值对，所以它们本质上与标签非常相似。但与标签不同，注解并不是为了保存标识信息而存在的，它们不能像标签一样用于对对象进行分组。当我们可以通过标签选择器选择对象时，就不存在注解选择器这样的东西。</p><p>另一方面，注解可以容纳更多的信息，并且主要用于工具使用。Kubernetes 也会将一些注解自动添加到对象，但其他的注解则需要由用户手动添加。</p><p>向 kubernetes 引入新特性时，通常也会使用注解。一般来说，新功能的 alpha 和 beta 版本不会向 API 对象引入任何新字段，因此使用的是注解而不是字段，一旦所需的 API 更改变得清晰并得到所有相关人员的认可，就会引入新的字段并废弃相关注解。</p><h2 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h2><p>和标签一样，注解可以在创建时就添加到 pod 中，也可以在之后再对现有的 pod 进行添加或修改。其中将注解添加到现有对象的最简单的方法是通过 kubectl annotate 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 添加注解</span><br><span class="line">kc annotate pod test-nginx test.annotations="test"</span><br><span class="line"><span class="meta">#</span># 修改注解</span><br><span class="line">kc annotate pod test-nginx test.annotations="pro" --overwrite</span><br></pre></td></tr></table></figure></p><h1 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a>namespace 命名空间</h1><p>我们已经看到标签是如何将 pod 和其他对象组织成组的。由于每个对象都可以有多个标签，因 此这些对象组可以重叠。另外，当在集群中工作（例如通过 kubectl ）时，如果没有明确指定标签选择器，我们总能看到所有对象 。</p><p>但是，当你想将对象分割成完全独立且不重叠的组时，又该如何呢？可能你每次只想在一个小组内进行操作，因此 kubernetes 也能将对象分组到命名空间中。Kubernetes 命名空间简单地为对象名称提供了一个作用域。此时我们并不会将所有资源都放在同一个命名空间中，而是将它们组织到多个命名空间中，这样可以允许我们多次使用相同的资源名称（跨不同的命名空间〉。</p><h2 id="列出命名空间及其-pod"><a href="#列出命名空间及其-pod" class="headerlink" title="列出命名空间及其 pod"></a>列出命名空间及其 pod</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>#列出集群中的所有命名空间</span><br><span class="line">kc get ns</span><br></pre></td></tr></table></figure><p>当使用 kubectl get 命令列出资源时，我们从未明确指定命名空间，因此 kubectl 总是默认为 default 命名空间，只显示该命名空间下的对象。但从列表中我们可以看到还存在 kube -public 和 kube-system 命名空间。接下来可以使用 kubectl 命令指定命名空间来列出只属于该命名空间的 pod<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc get pods --namespace kube-system</span><br></pre></td></tr></table></figure></p><blockquote><p>可以使用 -n 代替 –namespace</p></blockquote><h2 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h2><ul><li>通过yaml文件创建</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-namespace</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc create -f test-namespace.yaml</span><br></pre></td></tr></table></figure><ul><li>通过命令创建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace test-namespace</span><br></pre></td></tr></table></figure><blockquote><p>尽管大多数对象的名称必须符合 RFC 1035 （域名）中规定的命名规范，这意味着它们可能只包含字母、数字、横杠（－）和点号， 但命名空间不允许包含点号。</p></blockquote><h2 id="删除命名空间"><a href="#删除命名空间" class="headerlink" title="删除命名空间"></a>删除命名空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete ns test-namespace</span><br></pre></td></tr></table></figure><h2 id="删除命名空间中（几乎）所有的资源"><a href="#删除命名空间中（几乎）所有的资源" class="headerlink" title="删除命名空间中（几乎）所有的资源"></a>删除命名空间中（几乎）所有的资源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete all --all -n test-namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（五）Kubernetes 之 存活探针</title>
      <link href="/kubernetes/k8s5/"/>
      <url>/kubernetes/k8s5/</url>
      
        <content type="html"><![CDATA[<h2 id="保持pod健康"><a href="#保持pod健康" class="headerlink" title="保持pod健康"></a>保持pod健康</h2><p>使用 Kubernetes 的一个主要好处是，可以给 Kubernetes －个容器列表来由其保持容器在集群中的运行。可以通过让 Kubernetes 创建 pod 资源，为其选择一个工作节点并在该节点上运行该 pod 的容器来完成此操作。但是，如果其中一个容器终止，或一个 pod 的所有容器都终止，怎么办？</p><p>只要将 pod 调度到某个节点，该节点上的 Kubelet 就会运行 pod 的容器， 从此只要该 pod 存在，就会保持运行。如果容器的主进程崩溃，Kubelet 将重启容器。如果应用程序中有一个导致它每隔一段时间就会崩溃的 bug, Kubernetes 会自动重启应用程序，所以即使应用程序本身没有做任何特殊的事，在Kubernetes 中运行也能自动获得自我修复的能力。</p><p>即使进程没有崩溃，有时应用程序也会停止正常工作。例如，具有内存泄漏的 Java 应用程序将开始抛出 OutOfMemoryErrors，但 JVM 进程会一直运行。如果有一种方法，能让应用程序向 Kubernetes 发出信号，告诉 Kubernetes 它运行异常并让 Kubernetes 重新启动，那就很棒了。</p><p>我们已经说过，一个崩溃的容器会自动重启，所以也许你会想到，可以在应用中捕获这类错误， 并在错误发生时退出该进程。当然可以这样做，但这仍然不能解决所有的问题。</p><p>例如，你的应用因为无限循环或死锁而停止响应。为确保应用程序在这种情况下可以重新启动，必须从外部检查应用程序的运行状况，而不是依赖于应用的内部检测。</p><h3 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h3><p>Kubernetes 可以通过存活探针（liveness probe）检查容器是否还在运行。可以为 pod 中的每个容器单独指定存活探针。如果探测失败，Kubernetes 将定期执行探针并重新启动容器。</p><p>Kubernetes 有以下三种探测容器的机制：</p><ul><li>HTTP GET 探针对容器的 IP 地址（指定的端口和路径）执行 HTTP GET 请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果 HTTP 响应状态码是 2xx 或 3xx ），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。</li><li>TCP 套接字探针尝试与容器指定端口建立 TCP 连接。如果连接成功建立，则探测成功。 否则，容器重新启动。</li><li>Exec 探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 0，则探测成功。所有其他状态码都被认为失败。</li></ul><h4 id="创建-HTTP-的存活探针"><a href="#创建-HTTP-的存活探针" class="headerlink" title="创建 HTTP 的存活探针"></a>创建 HTTP 的存活探针</h4><p>创建一个包含 HTTP GET 存活探针的新 pod</p><pre><code>apiVersion: v1kind: Podmetadata:    name: test-nginx-liveness-probespec:    containers:    - image: nginx      name: test      ## 存活探针      livenessProbe:        ## 初始延迟        initiaDelaySeconds: 20        ## HTTP GET 存活探针        httpGet:            ## HTTP 请求路径            path: /            ## 端口            port: 8080      ports:      - containerPort: 80        protocol: TCP</code></pre><p>该 pod 的描述文件定义了一个 HTTP Get 存活探针，该探针告诉 Kubernetes 定期在端口 8080 路径上执行 HTTP GET 请求，已确定该容器是否健康，请求在容器运行后立即开始。</p><p>上面指定8080，但其实容器没有在8080端口上运行http程序，所以会一直请求失败，Kubernete 会认为探测失败并重启容器。</p><blockquote><p>当容器被强行终止时会创建一个全新的容器，而不是重启原来的容器 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（六）Kubernetes 之 控制器</title>
      <link href="/kubernetes/k8s6/"/>
      <url>/kubernetes/k8s6/</url>
      
        <content type="html"><![CDATA[<h2 id="ReplicationController-控制器"><a href="#ReplicationController-控制器" class="headerlink" title="ReplicationController 控制器"></a>ReplicationController 控制器</h2><p>ReplicationController 是一种 Kubernetes 资源，可确保它的 pod 始终保持运行状态。如果 pod 因任何原因消失（例如节点从集群中消失或由于该 pod 己从节点中逐出），则 ReplicationController 会注意到缺少了 pod 并创建替代 pod。</p><p>ReplicationController 的工作是确保 pod 的数量始终与其标签选择器匹配。如果不匹配，则 ReplicationController 将根据所需 ， 采取适当的操作来协调 pod 的数量。 </p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15813380153549.jpg" alt="-w713"></p><h3 id="ReplicationController-的组成部分"><a href="#ReplicationController-的组成部分" class="headerlink" title="ReplicationController 的组成部分"></a>ReplicationController 的组成部分</h3><p>一个 ReplicationController 有三个主要部分：</p><ul><li>label selector:标签选择器，用于确定 ReplicationController 作用域中有哪些 pod</li><li>replica count: 副本个数，指定应运行的 pod 数量</li><li>pod template：pod模板，用于创建新的 pod 副本</li></ul><p>ReplicationController 的副本个数、标签选择器，甚至是 pod 模板都可以随时修改，但只有副本数目的变更会影响现有的 pod。</p><p>更改标签选择器和 pod 模板对现有 pod 没有影响。更改标签选择器会使现有的 pod 脱离ReplicationController 的范围，因此控制器会停止关注它们。在创建 pod 后， ReplicationController 也不关心其 pod 的实际“内容”（容器镜像、环境变量及其他）。 因此，该模板仅影响由此 ReplicationController 创建的新 pod。</p><h3 id="使用ReplicationController-的好处"><a href="#使用ReplicationController-的好处" class="headerlink" title="使用ReplicationController 的好处"></a>使用ReplicationController 的好处</h3><p>像 Kubernetes 中的许多事物一样， ReplicationController 尽管是一个令人难以置信的简单概念，却提供或启用了以下强大功能：</p><ul><li>确保一个或多个pod持续运行，方法是在现有 pod 丢失时启动一个新的 pod。</li><li>集群节点发生故障时，它将为故障节点上运行的所有 pod（受ReplicationController 控制的节点上的pod） 创建替代副本。</li><li>它能轻松实现 pod 的水平伸缩。</li></ul><blockquote><p>pod 实例永远不会重新安置到另一个节点。 相反，ReplicationController 会创建一个全新的 pod 实例，它与正在替换的实例无关。</p></blockquote><h3 id="创建一个-ReplactionController"><a href="#创建一个-ReplactionController" class="headerlink" title="创建一个 ReplactionController"></a>创建一个 ReplactionController</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rc-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment">## 标签选择器，决定rc控制器的操作对象</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rc-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc create -f test-nginx-replication-controller.yaml --validate=false</span><br></pre></td></tr></table></figure><p>Kubernetes 会创建一个名为 rc-test 的新 ReplicationController， 它确保符合标签选择器 app=nginx 的 pod 实例始终是三个。 当没有足够的 pod 时，根据提供的 pod 模板创建新的 pod 。</p><p>模板中的 pod 标签显然必须和 ReplicationController 的标签选择器匹配， 否则控制器将无休止地创建新的容器。因为启动新 pod 不会使实际的副本数量接近期望的副本数量。为了防止出现这种情况，API 服务会校验 ReplicationController 的定义，不会接收错误配置。</p><p>不指定选择器也是一种选择。在这种情况下，它会自动根据 pod 模板中的标签自动配置。</p><blockquote><p>定义 ReplicationController 时不要指定 pod 选择器，让 kubernetes 从 pod 模板中提取它。这样 YAML 更简短。</p></blockquote><h3 id="使用-ReplicationController"><a href="#使用-ReplicationController" class="headerlink" title="使用 ReplicationController"></a>使用 ReplicationController</h3><p>由于没有任何 pod 有 app=nginx 标签，ReplicationController 会根据 pod 模板启动三个新的 pod。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># kc get pods --show-labels</span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">rc-test-5g8cz      1/1     Running   0          23m   app=nginx</span><br><span class="line">rc-test-dcsdb      1/1     Running   0          23m   app=nginx</span><br><span class="line">rc-test-fmh2q      1/1     Running   0          23m   app=nginx</span><br></pre></td></tr></table></figure></p><p>删除其中一个 pod 看会发生什么<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># kc delete pods rc-test-mzcqc</span><br><span class="line"><span class="meta">#</span># kc get pods --show-labels</span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE     LABELS</span><br><span class="line">rc-test-6b69p      1/1     Running             0          2m31s   app=nginx</span><br><span class="line">rc-test-89hqk      0/1     ContainerCreating   0          1s      app=nginx</span><br><span class="line">rc-test-mzcqc      0/1     Terminating         0          3m11s   app=nginx</span><br><span class="line">rc-test-sfc8r      1/1     Running             0          2m50s   app=nginx</span><br></pre></td></tr></table></figure></p><p>重新列出pod会显示四个，删除的 pod 在终止中，新创建的 pod 在创建中</p><h3 id="获取有关-ReplicationController-的信息"><a href="#获取有关-ReplicationController-的信息" class="headerlink" title="获取有关 ReplicationController 的信息"></a>获取有关 ReplicationController 的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 列出所有 rc 控制器</span><br><span class="line">kc get rc</span><br><span class="line">## 查看某个 rc 详细信息</span><br><span class="line">kc describe rc rc-test</span><br></pre></td></tr></table></figure><p>控制器通过创建一个新的替代 pod 来响应 pod 的删除操作。从技术上讲，它并没有对删除本身做出反应，而是针对由此产生的状态：pod 数量不足。<br>虽然 ReplicationController 会立即收到删除 pod 的通知 ( API 服务器允许客户端 监听资源和资源列表的更改 ），但这不是它创建替代 pod 的原因。该通知会触发控制器检查实际的 pod 数量并采取适当的措施。</p><h3 id="将-pod-移入或移出-ReplicationController-的作用域"><a href="#将-pod-移入或移出-ReplicationController-的作用域" class="headerlink" title="将 pod 移入或移出 ReplicationController 的作用域"></a>将 pod 移入或移出 ReplicationController 的作用域</h3><p>由 ReplicationController 创建的 pod 并不是绑定到 ReplicationController。在任何时刻，ReplicationController 管理与标签选择器匹配的 pod。通过更改 pod 的标签，可以将它从 ReplicationController 的作用域中添加或删除。它甚至可以从一个ReplicationController移动到另一个。</p><blockquote><p>尽管一个 pod 没有绑定到一个 ReplicationController，但该 pod 在metadata.ownerReferences 字段中引用它，可以轻松使用它来找到一个 pod 属于哪个 ReplicationController</p></blockquote><p>如果你更改了一个 pod 的标签，使它不再与 ReplicationController 的标签选择器相匹配，那么该 pod 就变得和其他手动创建的 pod 一样了。它不再被任何东西管理。如果运行该节点的 pod 异常终止，它显然不会被重新调度。 但请记住，当你更改 pod 的标签时，ReplicationController 发现一个 pod 丢失了，并启动一个新的 pod 替换它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 给其中的一个pod 添加标签</span><br><span class="line">kc label pods rc-test-89hqk auth=yuxuan</span><br><span class="line">kc get pods --show-labels</span><br><span class="line">rc-test-6b69p      1/1     Running   0          29m   app=nginx</span><br><span class="line">rc-test-89hqk      1/1     Running   0          27m   app=nginx,auth=yuxuan</span><br><span class="line">rc-test-sfc8r      1/1     Running   0          29m   app=nginx</span><br></pre></td></tr></table></figure><p>给其中一个 pod 添加了 auth=yuxuan 标签，再次列出所有 pod 会显示和以前一样的三个 pod。因为从 ReplicationController 角度而言，没发生任何更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 修改其中一个pod的 app 标签值</span><br><span class="line">kc label pod rc-test-89hqk app=nginx2 --overwrite</span><br><span class="line">kc get pods --show-labels</span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE   LABELS</span><br><span class="line">rc-test-6b69p      1/1     Running             0          35m   app=nginx</span><br><span class="line">rc-test-89hqk      1/1     Running             0          33m   app=nginx2,auth=yuxuan</span><br><span class="line">rc-test-mpf76      0/1     ContainerCreating   0          2s    app=nginx</span><br><span class="line">rc-test-sfc8r      1/1     Running             0          36m   app=nginx</span><br></pre></td></tr></table></figure><p>列出 pod，会发现有四个pod，其中一个 app=nginx2 已经不由 ReplicationController管理了，其他三个是。</p><h3 id="更改-ReplicationControlle-的标签选择器"><a href="#更改-ReplicationControlle-的标签选择器" class="headerlink" title="更改 ReplicationControlle 的标签选择器"></a>更改 ReplicationControlle 的标签选择器</h3><p>如果修改了 ReplicationController 的标签选择器，它会让所有的 pod 脱离 ReplicationController 的管理，导致它 创建三个新的 pod。</p><h3 id="修改-ReplicationControlle-的-pod-模板"><a href="#修改-ReplicationControlle-的-pod-模板" class="headerlink" title="修改 ReplicationControlle 的 pod 模板"></a>修改 ReplicationControlle 的 pod 模板</h3><p>ReplicationController 的 pod 模板可以随时修改。更改 pod 模板就像用一个 pod 替换另－个。它只会影响你之后创建的pod，并且不会影响你已经创建的 pod。要修改旧的 pod，你需要删除它们，并让 ReplicationController 根据新模板将其替换为新的 pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 将在你的默认文本编辑器中打开 ReplicationController 的 YAML 配置</span><br><span class="line">kc edit rc rc-test</span><br></pre></td></tr></table></figure><blockquote><p>配置 kubectl edit 使用不同的文本编辑器<br>可以通过设直 KUBE_EDITOR 环境变量来告诉 kubectl 使用你期望的文本编辑器。例如：<br>export KUBE_EDITOR=”/usr/bin/nano”</p></blockquote><h3 id="调整-rc-的-scale-来水平伸缩-pod"><a href="#调整-rc-的-scale-来水平伸缩-pod" class="headerlink" title="调整 rc 的 scale 来水平伸缩 pod"></a>调整 rc 的 scale 来水平伸缩 pod</h3><p>伸缩 pod 的数量规模就和在ReplicationController 资源中更改 Replicas 宇段的值一样简单。更改之后， ReplicationController 将会看到存在太多 的 pod 并删除其中的一部分（缩容时），或者看到它们数目太少并创建 pod（扩容时）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 使用 kubectl scale 命令</span><br><span class="line">kc scale rc rc-test --replicas=8</span><br><span class="line">## 也可以使用 kc edit 来修改</span><br><span class="line">kc edit rc rc-test</span><br></pre></td></tr></table></figure><h3 id="删除一个-ReplicationController"><a href="#删除一个-ReplicationController" class="headerlink" title="删除一个 ReplicationController"></a>删除一个 ReplicationController</h3><p>当你通过 kubectl delete 删除ReplicationController 时，pod 也会被删除。但是由于由 ReplicationController 创建的 pod 不是 ReplicationController 的组成部分，只是由其进行管理，因此可以只删除 ReplicationController 并保持 pod 运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete rc rc-test --cascade=false</span><br></pre></td></tr></table></figure></p><h2 id="ReplicaSet-控制器"><a href="#ReplicaSet-控制器" class="headerlink" title="ReplicaSet 控制器"></a>ReplicaSet 控制器</h2><p>最初，ReplicationController 是用于复制和在异常时重新调度节点的唯一 Kubernetes 组件，后来又引入了一个名为 ReplicaSet 的类似资源。它是新一代的 ReplicationController，并且将其完全替换掉， ReplicationController 最终将被弃用。</p><h3 id="ReplicaSet-和-ReplicationController-区别"><a href="#ReplicaSet-和-ReplicationController-区别" class="headerlink" title="ReplicaSet 和 ReplicationController 区别"></a>ReplicaSet 和 ReplicationController 区别</h3><p>ReplicaSet 的行为与 ReplicationController 完全相同，但 pod 选择器的表达能力更强。虽然 ReplicationController 的标签选择器只允许包含某个标签的匹配 pod，但 ReplicaSet的选择器还允许匹配缺少某个标签的 pod ，或包含特定标签名的 pod，不管其值如何。</p><p>同样，无论 ReplicationController 的值如何，ReplicationController 都无法仅基于标签名的存在来匹配 pod，而 ReplicaSet 则可以。例如，ReplicaSet 可匹配所有包含 名为 env 的标签的 pod，无论 ReplicaSet 的实际值是什么（可以理解为 env＝* ）。</p><h2 id="定义-ReplicaSet"><a href="#定义-ReplicaSet" class="headerlink" title="定义 ReplicaSet"></a>定义 ReplicaSet</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rs-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 使用简单的matchLabels选择器</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rs-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>首先要注意的是 ReplicaSet 不是 v1 API 的一部分，因此你需要确保在创建资源时指定正确的 apiVersion。你正在创建一个类型为ReplicaSet 的资源，它的内容与之前创建的 ReplicationController 的内容大致相同。</p><p>唯一的区别在选择器中。不必在 selector 属性中直接列出 pod 需要的标签，而是在 selector.matchLabels 下指定它们。这是在 ReplicaSet 中定义标签选择器的更简单的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 列出所有rs</span><br><span class="line">kc get rs</span><br><span class="line">## 查看指定rs的详情</span><br><span class="line">kc describe rs rs-test</span><br></pre></td></tr></table></figure><h3 id="使用-ReplicaSet-的更富表达力的标签选择器"><a href="#使用-ReplicaSet-的更富表达力的标签选择器" class="headerlink" title="使用 ReplicaSet 的更富表达力的标签选择器"></a>使用 ReplicaSet 的更富表达力的标签选择器</h3><p>ReplicaSet 相对于 ReplicationController 的主要改进是它更具表达力的标签选择器。上面用了较简单的 matchLabels 选择器。现在，将用更强大的matchExpressions 属性来重写选择器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rs-test-matchexpressions</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        matchExpressions:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">app</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">            values:</span></span><br><span class="line"><span class="bullet">              -</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rs-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>可以给选择器添加额外的表达式。如上面所写， 每个表达式都必须包含一个 key、一个 operator（运算符〉，并且可能还有一个 values 的列表（取决于运算符）。你会看到四个有效的运算符：</p><ul><li>In：Label 的值必须与其中一个指定的 values 匹配。</li><li>NotIn：Label 的值与任何指定的 values 不匹配。</li><li>Exists：pod 必须包含一个指定名称的标签,值不重要。使用此运算符时，不应指定 values 字段。</li><li>DoesNotExist：pod 不得包含有指定名称的标签。values 属性不得指定。</li></ul><p>如果指定了多个表达式，则所有这些表达式都必须为 true 才能使选择器与 pod 匹配。如果同时指定 matchLabels 和 matchExpressions，则所有标签都必须匹配， 并且所有表达式必须计算为 true 以使该 pod 与选择器匹配。</p><h2 id="DaemonSet-在每个节点上运行一个pod"><a href="#DaemonSet-在每个节点上运行一个pod" class="headerlink" title="DaemonSet 在每个节点上运行一个pod"></a>DaemonSet 在每个节点上运行一个pod</h2><p>Replicationcontroller 和 ReplicaSet 都用于在 Kubernetes 集群上运行部署特定数量的 pod。但是，当你希望 pod 在集群中的每个节点上运行时，例如，希望在每个节点上运行日志收集器和资源监控器。</p><p>要在所有集群节点上运行一个 pod，需要创建一个 DaemonSet 对象。DaemonSet 确保创建足够的 pod，并在自己的节点上部署每个 pod。</p><p>尽管 ReplicaSet 或 ReplicationController 确保集群中存在期望数量的 pod 副本，但 DaemonSet 并没有期望的副本数的概念。它不需要，因为它的工作是确保一个 pod 匹配它的选择器并在每个节点上运行。</p><p>如果节点下线，DaemonSet 不会在其他地方重新创建 pod。但是，当将一个新节点添加到集群中时，DaemonSet 会立刻部署一个新的 pod 实例。如果删除了一个 pod，那么它也会重新 创建一个新的 pod。与 ReplicaSet 一样， DaemonSet 从配置的 pod 模板创建 pod。</p><p>默认情况下 DaemonSet 是将 pod 部署到集群中的所有节点上，如果想要指定 pod 只在部分节点上运行。可以通过 pod 模板中的 nodeSelector 属性指定。</p><blockquote><p>节点可以被设置为不可调度的，防止 pod 被部署到节点上。 DaemonSet 甚至会将 pod 部署到这些节点上，因为无法调度的属性只会被调度器使用，而 DaemonSet 管理 的 pod 则 完全绕过调度器。这是预期的，因为 DaemonSet 的目的是运行系统服务，即使是在不可调度的节点上，系统服务通常也需要运行。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ds-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 使用简单的matchLabels选择器</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line">            <span class="comment">## 节点选择器，只会在满足条件的 node 上部署 pod</span></span><br><span class="line"><span class="attr">            nodeSelector:</span></span><br><span class="line"><span class="attr">                cpu:</span> <span class="string">gpu</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-ds-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 创建 ds</span><br><span class="line">kc create -f test-nginx-daemon-set-controller.yaml --validate=false</span><br><span class="line"><span class="meta">#</span># 列出 ds</span><br><span class="line">kc get ds</span><br><span class="line">NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">ds-test   1         1         1       1            1           cpu=gpu         2m50s</span><br><span class="line"><span class="meta">#</span># 如果把节点上的标签修改了 pod 会立即停止</span><br><span class="line">kc label node 192.168.1.230 cpu=no --overwrite</span><br><span class="line"><span class="meta">#</span># 再次列出 ds</span><br><span class="line">kc get ds</span><br><span class="line">NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">ds-test   0         0         0       0            0           cpu=gpu         5m34s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（七）Kubernetes 之 服务 Service</title>
      <link href="/kubernetes/k8s7/"/>
      <url>/kubernetes/k8s7/</url>
      
        <content type="html"><![CDATA[<p>kubernetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源。当服务存在时，它的 IP 地址和端口不会改变。客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上。通过这种方式，客户端不需要知道每个单独的提供服务的 pod 的地址，这样这些 pod 就可以在集群中随时被创建或移除。</p><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><h3 id="通过-kubectl-expose-快速创建"><a href="#通过-kubectl-expose-快速创建" class="headerlink" title="通过 kubectl expose 快速创建"></a>通过 kubectl expose 快速创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose rc yx-nginx</span><br></pre></td></tr></table></figure><p>执行此命令，就是会根据 rc 控制器 yx-nginx 创建一个同名的 service。</p><h3 id="通过-yaml-配置文件创建"><a href="#通过-yaml-配置文件创建" class="headerlink" title="通过 yaml 配置文件创建"></a>通过 yaml 配置文件创建</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>创建了一个名叫 yx-nginx 的服务，它将在端口 8000 接受请求并将连接路由到具有 app=nginx 标签的 pod 的 80 端口上。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f test-nginx-service.yaml</span><br></pre></td></tr></table></figure></p><h2 id="列出命名空间下所有服务资源"><a href="#列出命名空间下所有服务资源" class="headerlink" title="列出命名空间下所有服务资源"></a>列出命名空间下所有服务资源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br><span class="line"></span><br><span class="line">NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes              ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          3d20h</span><br><span class="line">yx-nginx                ClusterIP      10.109.90.148   &lt;none&gt;        8000/TCP         18h</span><br></pre></td></tr></table></figure><p>列表显示分配给服务的 IP 地址是 10.109.90.148。因为只是集群的 iP 地址，只能在集群内部可以被访问。</p><h2 id="配置服务上的会话亲和性"><a href="#配置服务上的会话亲和性" class="headerlink" title="配置服务上的会话亲和性"></a>配置服务上的会话亲和性</h2><p>如果多次请求同一个服务，每次调用执行应该在不同的 pod 上。因为在默认情况下， Kubernetes 采用 RoundRobin 模式对客户端请求进行负载分发。</p><p>如果希望特定客户端产生的所有请求每次都指向同一个 pod，可以设置服务的sessionAffinity 属性为ClientIP，默认值为 None。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">    ## 服务名称</span><br><span class="line">    name: yx-nginx</span><br><span class="line">spec:</span><br><span class="line">    sessionAffinity: ClientIP</span><br><span class="line">    ports:</span><br><span class="line">    ## 服务访问端口</span><br><span class="line">    - port: 8000</span><br><span class="line">    ## 目标 pod 访问端口</span><br><span class="line">      targetPort: 80</span><br><span class="line">    selector:</span><br><span class="line">        ## 具有 app=nginx 标签的 pod 都属于该服务</span><br><span class="line">        app: nginx</span><br></pre></td></tr></table></figure></p><h2 id="同一个服务暴露多个端口"><a href="#同一个服务暴露多个端口" class="headerlink" title="同一个服务暴露多个端口"></a>同一个服务暴露多个端口</h2><p>创建的服务可以暴露一个端口，也可以暴露多个端口。比如，你的 pod 监昕两个端口，比如 HTTP 监听 80 端口、 HTTPS 监听 443 端口，可以使用一个服务从端口 80 和 443 转发至 pod 端口 80 和 443。在这种情况下，无须创建两个不同的服务。通过一个集群 IP，使用一个服务就可以将多个端口全部暴露出来。</p><blockquote><p>在创建一个有多个端口的服务的时候，必须给每个端口指定名字。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>标签选择器应用于整个服务，不能对每个端口做单独的配置。如果不同的 pod 有不同的端口映射关系，需要创建两个服务。</p></blockquote><h2 id="使用命名的端口"><a href="#使用命名的端口" class="headerlink" title="使用命名的端口"></a>使用命名的端口</h2><p>我们可以在定义 pod 端口的时候给端口命名，然后在服务 spec 中按名称引入端口。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx</span> <span class="comment">##pod名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span> <span class="comment">## pod里运行那些容器</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span>  <span class="comment">## 镜像名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span>    <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>为什么要采用命名端口的方式？最大的好处就是即使更换端口号也无须更改服务 spec。你的 pod 现在对 http 服务用的是 80，但是假设过段时间你决定将端口更换为 8080 呢？<br>如果你采用了命名的端口，仅仅需要做的就是改变 spec pod 中的端口号（当然你的端口号的名称没有改变）。在你的 pod 向新端口更新时，根据 pod 收到的连接 (80 端口在旧的 pod 上、 8080 端口在新的 pod 上 ），用户连接将会转发到对应的端口。</p><h2 id="连接集群外部的服务"><a href="#连接集群外部的服务" class="headerlink" title="连接集群外部的服务"></a>连接集群外部的服务</h2><p>通过 Kubernetes 服务特性暴露外部服务的情况。不要让服务将连接重定向到集群中的 pod，而是让它重定向到外部 IP 和端口。<br>这样做可以让你充分利用服务负载平衡和服务发现。在集群中运行的客户端 pod 可以像连接到内部服务一样连接到外部服务 。</p><h3 id="介绍服务-endpoint"><a href="#介绍服务-endpoint" class="headerlink" title="介绍服务 endpoint"></a>介绍服务 endpoint</h3><p>服务并不是和 pod 直接相连的。相反，有一种资源介于两者之间，它就是 Endpoint 资源。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl describe svc yx-nginx</span><br><span class="line">Name:              yx-nginx</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.108.146.21</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         100.108.201.68:80,100.73.43.204:80,100.98.112.72:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>Endpoint 资源就是暴露一个服务的 IP 地址和端口的列表，Endpoint 资源和其他 Kubernetes 资源一样，所以可以使用 kubectl info 来获取它的基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl get endpoints yx-nginx</span><br><span class="line">NAME       ENDPOINTS                                            AGE</span><br><span class="line">yx-nginx   100.73.43.204:80,100.73.43.205:80,100.73.43.206:80   23h</span><br></pre></td></tr></table></figure><p>尽管在 spec 服务中定义了 pod 选择器，但在重定向传入连接时不会直接使用它。相反，选择器用于构建 IP 和端口列表，然后存储在 Endpoint 资源中。 当客户端连接到服务时，服务代理选择这些 IP 和端口对中的一个，并将传入连接重定向到在该 位置监昕的服务器。</p><h3 id="手动配置服务的-endpoint"><a href="#手动配置服务的-endpoint" class="headerlink" title="手动配置服务的 endpoint"></a>手动配置服务的 endpoint</h3><p>服务的 endpoint 与服务解稍后，可以分别手动配置和更新它们。</p><p>如果创建了不包含 pod 选择器的服务，Kubernetes 将不会创建 Endpoint 资源（毕竟，缺少选择器，将不会知道服务中包含哪些 pod ）。这样就需要创建 Endpoint 资源来指定该服务的 endpoint 列表。</p><h4 id="创建没有选择器的服务"><a href="#创建没有选择器的服务" class="headerlink" title="创建没有选择器的服务"></a>创建没有选择器的服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">manual-endponit-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>定义一个名为 manual-endponit-service 的服务， 它将接收端口 80 上的传入连接。并没有为服务定义一个 pod 选择器 。</p><h4 id="为没有选择器的服务创建-Endpoint-资源"><a href="#为没有选择器的服务创建-Endpoint-资源" class="headerlink" title="为没有选择器的服务创建 Endpoint 资源"></a>为没有选择器的服务创建 Endpoint 资源</h4><p>Endpoint 是一个单独的资源并不是服务的一个属性。由于创建的服务中并不包 含选择器，相关的 Endpoints 资源并没有自动创建，所以必须手动创建。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## endpoint 的名称必须和服务名称一致</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">manual-endponit-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.239</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8090</span></span><br></pre></td></tr></table></figure></p><p>Endpoint 对象需要与服务具有相同的名称，并包含该服务的目标 IP 地址和端口列表。服务和 Endpoint 资源都发布到服务器后，这样服务就可以像具有 pod 选择器那样的服务正常使用。在服务创建后创建的容器将包含服务的环境变量，并且与其 ip : port 对的所有连接都将在服务端点之间进行负载均衡。</p><h2 id="将服务暴露给外部访问"><a href="#将服务暴露给外部访问" class="headerlink" title="将服务暴露给外部访问"></a>将服务暴露给外部访问</h2><p>上面只讨论了集群内服务如何被 pod 使用；但是，还需要向外部公开某些服务。例如前端 web 服务器，以便外部客户端可以访问它们。<br>有几种方式可以在外部访问服务 ：</p><ul><li>将服务的类型设置成 NodePort：每个集群节点都会在节点上打开一个端口，对于 NodePort 服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。该服务仅在内部集群 IP 和端口上才可访问，但也可通过所有节点上的专用端口访问。</li><li>将服务的类型设置成 LoadBalance：NodePort 类型的一种扩展，这使得 服务可以通过一个专用的负载均衡器来访问，这是由 Kubernetes 中正在运行的云基础设施提供的。负载均衡器将流量重定向到跨所有节点的节点端口。 客户端通过负载均衡器的 IP 连接到服务。</li><li>创建一个 Ingress 资源，这是一个完全不同的机制，通过一个 IP 地址公开多个服务，它运行在 HTTP 层（ 网络协议第 7 层）上，因此可以提供比工作在第 4 层的服务更多的功能。</li></ul><h3 id="创建-NodePort-类型的服务"><a href="#创建-NodePort-类型的服务" class="headerlink" title="创建 NodePort 类型的服务"></a>创建 NodePort 类型的服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="comment">## 集群节点端口，通过该端口访问服务，如果不设置，kubernetes 会随机一个端口</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30123</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>将类型设置为 NodePort 并指定该服务应该绑定到的所有集群节点的节点端口。指定端口不是强制性的。如果忽略它，Kubernetes 将选择一个随机端口。</p><h3 id="创建-LoadBalance-负载均衡器服务"><a href="#创建-LoadBalance-负载均衡器服务" class="headerlink" title="创建 LoadBalance 负载均衡器服务"></a>创建 LoadBalance 负载均衡器服务</h3><p>kubernetes 集群通常支持从云基础架构自动提供负载平衡器。所有需要做的就是设置服务的类型为 LoadBadancer 而不是 NodePort。负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 可以通过负载均衡器的 IP 地址访问服务。</p><p>如果 kubernetes 在不支持 LoadBadancer 服务的环境中运行，则不会调 配负载平衡器，但该服务仍将表现得像一个 NodePort 服务。这是因为 LoadBadancer 服务是 Node Port 服务的扩展<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx-loadbalancer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30124</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure></p><h2 id="了解外部连接的特性"><a href="#了解外部连接的特性" class="headerlink" title="了解外部连接的特性"></a>了解外部连接的特性</h2><h3 id="防止不必要的网络跳数"><a href="#防止不必要的网络跳数" class="headerlink" title="防止不必要的网络跳数"></a>防止不必要的网络跳数</h3><p>当外部客户端通过节点端口连接到服务时，随机选择的 pod 并不一定在接收连接的同一节点上运行。可能需要额外的网络跳转才能到达 pod，但这种行为并不符合期望。</p><p>可以通过将服务配置为仅将外部通信重定向到接收连接的节点上运行的 pod 来阻止此额外跳数。这是通过在服务的 spec 部分中设置 externalTrafficPolicy 字段来完成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    externalTrafficPolicy:</span> <span class="string">Local</span></span><br></pre></td></tr></table></figure><p>如果服务定义包含此设置，并且通过服务的节点端口打开外部连接，则服务代理将选择本地运行的 pod。如果没有本地 pod 存在，则连接将挂起。因此，需要确保负载平衡器将连接转发给至少具有一个 pod 的节点。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（八）Kubernetes 之 就绪探针</title>
      <link href="/kubernetes/k8s8/"/>
      <url>/kubernetes/k8s8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>现在我们知道了，服务（service）可以通过服务的 pod 选择器来匹配具有相应标签的 pod。匹配成功后， pod 将作为服务的后端，它将成为服务的一部分，并且请求开始被重定向到 pod。但是，如果 pod 没有完全启动好，比如改 pod 可能需要时间来加载配置或数据，或者可能需要执行预热过程以防止第一个用户请求时间太长影响了用户体验。 在这种情况下，不希望该 pod 立即开始接 收请求，尤其是在有其他运行的 pod 可以正确快速地处理请求的情况下。 不要将请求转发到正在启动的 pod 中，直到完全准备就绪。</p><h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><p>前面我们了解了存活探针，以及它们如何通过确保异常容器自动重启来保持应用程序的正常运行。与存活探针类似，Kubernetes 还允许为容器定义准备就绪探针 。</p><p>就绪探测器会定期调用，并确定特定的 pod 是否接收客户端请求。当容器的准备就绪探测返回成功时，表示容器己准备好接收请求。</p><p>这个准备就绪的概念显然是每个容器特有的东西。 Kubernetes 只能检查在容器中运行的应用程序是否响应一个简单的 GET 请求，或者它可以响应特定的 URL 路径（该 URL 导致应用程序执行一系列检查以确定它是否准备就绪）。考虑到应用程序的具体情况，这种确切的准备就绪的判定是应用程序开发人员的 责任。</p><p>像存活探针一样，就绪探针有三种类型：</p><ul><li>HTTP GET 探针对容器的 IP 地址（指定的端口和路径）执行 HTTP GET 请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果 HTTP 响应状态码是 2xx 或 3xx ），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的。</li><li>TCP 套接字探针尝试与容器指定端口建立 TCP 连接。如果连接成功建立，则探测成功。反之失败。</li><li>Exec 探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 0，则探测成功。所有其他状态码都被认为失败。</li></ul><h2 id="了解就绪探针的流程"><a href="#了解就绪探针的流程" class="headerlink" title="了解就绪探针的流程"></a>了解就绪探针的流程</h2><p>启动容器时，可以为 Kubernetes 配置一个等待时间，经过等待时间后才可以执行第 一次准备就绪检查。之后，它会周期性地调用探针，并根据就绪探针的结果采取行动。如果某个 pod 报告它尚未准备就绪，则会从该服务(Service)中删除该 pod。如果 pod 再次准备就绪，则重新添加 pod。</p><p>与存活探针不同，如果容器未通过准备检查，则不会被终止或重新启动。这是存活探针与就绪探针之间的重要区别。存活探针通过杀死异常的容器并用新的正常容器替代它们来保持 pod 正常工作，而就绪探针确保只有准备好处理请求的 pod 才可以接收请求。这在容器启动时最为必要，当然在容器运行一段时间后也是有用的。</p><p>如下图所示，如果一个容器的就绪探测失败， 则将该容器从端点对象中移除。连接到该服务的客户端不会被重定向到 pod。这和 pod 与服务的标签选择器完全不匹配的效果相同。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-0a4e696f494b4a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="就绪失败的 pod 将从服务的 endpoint 中移除"></p><h2 id="pod-添加就绪探针"><a href="#pod-添加就绪探针" class="headerlink" title="pod 添加就绪探针"></a>pod 添加就绪探针</h2><p>我们可以在定义 pod 模板的时候添加好探针，也可以通过 kubectl edit 命令来修改已存在的 pod 模板。下面我们就来修改之前创建的 ReplicationController中的 pod 模板。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc rc-test</span><br></pre></td></tr></table></figure></p><p>当在文本编辑器中打开 ReplicationController 的 YAML 时，就将以下就绪探针定义添加到 spec.template.spec.containers 下的容器模板中。修改后的 YAML 大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="string">.....</span> <span class="comment">##省略其它</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="string">.....</span> <span class="comment">##省略其它</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rc-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line">              <span class="comment">## 添加就绪探针</span></span><br><span class="line"><span class="attr">              readinessProbe:</span></span><br><span class="line"><span class="attr">                exec:</span></span><br><span class="line"><span class="attr">                    command:</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">ls</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">/var/test</span> </span><br><span class="line">    <span class="string">.....</span> <span class="comment">##省略其它</span></span><br></pre></td></tr></table></figure><p>就绪探针将定期在容器内执行 ls /var/test 命令。 如果文件存在，则 ls 命令返回退出码 0，否则返回非零的退出码。如果文件存在，则就绪探针为成功，反之失败。</p><p>修改 rc 之后，现有的所有 pod 仍没有定义准备就绪探针。我们需要删除现有 pod 并让它们通过修改之后的 ReplicationController 重新创建。新的 pod 将进行就绪检查会一直失败，并且不会将其作为服务的端点，直到在每个 pod 中创建 /var/test 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 列出 pod  会发现所有的 pod 都处于 NO READY 状态</span><br><span class="line">[root@h249 test]# kc get pods</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">rc-test-nxg74   0/1     Running   0          9m55s</span><br><span class="line">rc-test-pztvx   0/1     Running   0          6m58s</span><br><span class="line">rc-test-svkzp   0/1     Running   0          6m58s</span><br></pre></td></tr></table></figure><p>使用 kubecl exec 命令为 pod 创建 /var/test 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@h249 home]# kc exec rc-test-nxg74 -- touch /var/test</span><br></pre></td></tr></table></figure><p>准备就绪探针会定期检查，默认情况下每 10 秒检查一次。可能不是马上就会调用就绪探针，因此容器可能还是未准备好。但是最晚 10 秒钟内，该 pod 就会准备就绪。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）初识 Docker 与容器</title>
      <link href="/docker/docker1/"/>
      <url>/docker/docker1/</url>
      
        <content type="html"><![CDATA[<p>Docker 是基于 Go 语言实现的开源容器项目，主要用于创建、管理和编排容器。 它诞生于 2013 年年初，最初是由一家名为 dotCloud 的公司利用 Linux 容器技术开发的一套内部工具。自开源后受到业界广泛的关注与参与，dotCloud 公司也随之快速发展壮大， 在 2013 年年底直接改名为 Docker Inc，并专注于 Docker 相关技术和产品的开发，目前已经成为全球最大的 Docker 容器服务提供商。</p><p>Docker 的构想是要实现“ Build, Ship and Run Any App, Anywhere ”，即通过对应用的封装（Packaging）、分发（ Distribution ）、部署（ Deployment）、运行（ Runtime ）生命周期进行管 理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件， 既可以是一个 Web 应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。基于 Linux 平台上的多项开源技术，Docker 提供了高效、敏捷和轻量级的容器方案， 并支持部署到本地环境和多种主流云平台。可以说，Docker 首次为应用的开发、运行和部署提供了“一站式”的实用解决方案。</p><p>在 LXC 的基础上， Docker 进一步优化了容器的使用体验，让它进入寻常百姓家。首先，Docker 提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器；其次，Docker 通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大地改善了用户体验。用户操作 Docker 容器就像操作应用自身一样简单。</p><p>早期的 Docker 代码实现是直接基于 LXC 的。自 0.9 版本开始，Docker 开发了 libcontainer 项目作为更广泛的容器驱动实现，从而替换掉了 LXC 的实现。目前，Docker 还积极推动成立了 rune 标准项目，井贡献给开放容器联盟，试图让容器的支持不再局限于 Linux 操作系统，而是更安全、更开放、更具扩展性。</p><h2 id="Docker-运行时与编排引擎"><a href="#Docker-运行时与编排引擎" class="headerlink" title="Docker 运行时与编排引擎"></a>Docker 运行时与编排引擎</h2><p>多数技术人员在谈到 Docker 时，主要是指 Docker 引擎。Docker 引擎是用于运行和编排容器的基础设施工具。有 VMware 管理经验的读者可以将其类比为 ESXi。ESXi 是运行虚拟机的核心管理程序，而 Docker 引擎是运行容器的核心容器运行时。</p><p>Docker 引擎主要有两个版本:企业版 (EE) 和社区版 (CE)。<br>每个季度，企业版和社区版都会发布一一个稳定版本。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持。<br>社区版还会通过 Edge 方式发布月度版。</p><h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><p>对开发和运维（ DevOps ）人员来说，最梦寐以求的效果可能就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行，而 Docker 恰恰是可以实现这一终极目标的“瑞士军刀”。具体说来，在开发和运维过程中，Docker 具有如下几个方面的优势：</p><ul><li>更快速的交付和部署：使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。</li><li>更高效的资源利用：运行 Docker 容器不需要额外的虚拟化管理程序的支持，Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</li><li>更轻松的迁移和扩展：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。</li><li>更简单的更新管理：使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</li></ul><p>Docker 容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得“很薄的”容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。当然，在隔离性方面，传统的虚拟机方式提供的是相对封闭的隔离。但这并不意味着 Docker 不安全。 Docker利用 Linux 系统上的多种防护技术实现了严格的隔离可靠性， 并且可以整合众多安全工具。从 1.3.0 版本开始，Docker重点改善了容器的安全控制和镜像的安全机制，极大地提高了使用 Docker 的安全性。Docker 在运行应用上跟传统的虚拟机方式相比具有如下：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动速度</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">较弱</td></tr><tr><td style="text-align:center">内存代价</td><td style="text-align:center">很小</td><td style="text-align:center">较多</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为MB</td><td style="text-align:center">一般为GB</td></tr><tr><td style="text-align:center">运行密度</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr><tr><td style="text-align:center">隔离性</td><td style="text-align:center">安全隔离</td><td style="text-align:center">完全隔离</td></tr><tr><td style="text-align:center">迁移性</td><td style="text-align:center">优秀</td><td style="text-align:center">一般</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）微服务架构与 Spring Cloud 简介</title>
      <link href="/springcloud/springcloud1/"/>
      <url>/springcloud/springcloud1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>从单体应用架构发展到SOA架构，再到微服务架构，应用架构经历了多年的不断演进。微服务架构不是凭空产生的，而是技术发展的必然结果，分布式云平台的应用环境使得微服务代替单体应用成为互联网大型系统的架构选择。目前，虽然微服务架构还没有公 认的技术标准和规范草案，但业界已经有了一些很有影响力的开源微服务架构解决方案，在进行微服务化开发或改造时可以进行相应的参考。</p><p>目前软件架构有三种架构类型，分别是业务架构、应用架构、技术架构。它们之间的关系是业务架构决定应用架构，技术架构支撑应用架构。架构的发展历程是从单体架构、分布式架构、SOA架构再到微服务架构，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-3a3ff2c6224b631b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h2><p>传统的单体架构在Java领域可以理解为一个Web应用，大部分Web工程都是将所有的功能打包在一起部署和运行。按照程序调用顺序，从上到下为表示层、业务层、数据访问层、DB层。如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/1455014-2fa28cd5b928fbb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为所有的功能模块都是在一个工程编写的，所以从开发和测试的角度来看，开发人员可以在短时间内就开发出单体应用，并且由于没有过多的依赖项，测试也可以节约很多时间。</p><p>但是，随着应用不断的发展，开发团队不断的扩张之后，单体应用的不足和弊端就会很明显的暴露出来，主要有以下不足点：</p><ul><li>灵活度不够：如果程序有任何修改，那么修改的不止一个点，可能需要从上到下地去修改，并且测试的时候必须等到整个程序部署完才能看出效果，并且由于整个开发工作都是在一个工程下进行的，可能需要等待其他开发人员开发完成才能完成部署，大大的降低了团队的灵活性。</li><li>可靠性：一旦出现了bug，影响的将是整个应用。因为所有的模块功能都是运行在一个进程中的。</li><li>复杂性高：单体应用的代码量可能会让团队新来的成员望而生畏，应用难以理解和迭代，从而到时开发速度大大降低。</li><li>系统扩展性差：添加新东西的时候不能针对某个点增加，要全局性增加。</li><li>系统启动慢：一个应用包含了所有功能模块，导致系统的启动时间较长。</li></ul><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>SOA的核心主体是服务，其目标是通过服务的流程化来实现业务的灵活性。服务就像一堆“元器件”，这些元器件通过封装形成标准服务，它们有相同的接口和语义表达规则。但服务要组装成一个流程和应用，还需要有效的“管理”，包括如何注册服务、如何发现服 务、如何包装服务的安全性和可靠性，这些就是SOA治理。SOA治理是将 SOA 的一堆元器件进行有效组装。这是形成一个“产品”的关键，否则那些永远是一堆元器件，而无法形成一个有机整体。<br>完整的SOA架构由五大部分组成：基础设施服务、企业服务总线、关键服务组件、开发工具、管理工具等。</p><ul><li>基础设施：为整个SOA组件和框架提供一个可靠的运行环境，以及服务组件容器，它的核心组件是应用服务器等基础软件支撑设施，提供运行期完整、可靠的软件支撑 。</li><li>企业服务总线：提供可靠消息传输、服务接入、协议转换、数据格式转换、 基于内容的路由等功能，屏蔽了服务的物理位置、协议和数据格式 。</li><li>关键服务组件：SOA在各种业务服务组件的分类。</li><li>开发工具和管理工具：提供完善的、可视化的服务开发和流程编排工具，包括服务的设计、开发、 配置、部署、监控、重构等完整的SOA项目开发生命周期 。</li></ul><p>SOA 架构中有两个主要角色：服务提供者（Provider）和服务消费者（Consumer）。<br>SOA架构的优点：</p><ul><li>把模块拆分， 使用接口通信， 降低模块之间的耦合度。</li><li>把项目拆分成若干个子项目，不同的团队负责不同的子项目。</li><li>增加功能时只需要增加一个子项目，调用其他系统的接口即可。</li><li>可以灵活地进行分布式部署。 </li></ul><p>SOA 架构的缺点：系统之间的交互需要使用远程通信， 接口开发增加工作量 。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务的概率最早是由 Martin Fowler 与 James Lewis 于 2014 年共同提出，需要了解细节的读者可以阅览 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices</a>。根据其描述，总体来说，微服务是一种架构风格， 对于一个大型复杂的业务系统，它的业务功能可以拆分为多个相互独立的微服务，各个微服务之间是松搞合的，通过各种远程协议进行同步／异步通信，各微服务均可以被独立部署、 扩／缩容以及升／降级。这些服务是基于业务逻辑和范围，通过自动 化部署的机制来独立部署的，并且服务的集中管理应该是最低限度的，即每个服务可以采用不同的编程语言编写，使用不同的数据存储技术 。<br>如今，微服务架构已经不是一个新概念了，很多业界前沿互联网公司的实践表明，微服务是一种渐进式的演进架构，是企业应对业务复杂性，支持大规模持续创新行之有效的架构手段。</p><h3 id="微服务组成"><a href="#微服务组成" class="headerlink" title="微服务组成"></a>微服务组成</h3><p>微服务架构是一种比较复杂、内涵丰富的架构模式，它包含很多支撑“微”服务的具体组件和概念，其中一些常用的组件及其概念如下：</p><ul><li>服务注册与发现：服务提供方将己方调用地址注册到服务注册中心，让服务调用方能够方便地找到自己；服务调用方从服务注册中心找到自己需要调用的服务的地址。</li><li>负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，服务节点选择的过程对服务调用方来说是透明的。</li><li>服务网关：服务网关是服务调用的唯一入口，可以在这个组件中实现用户鉴权、动态路由、灰度发布、 A/B测试、负载限流等功能。</li><li>配置中心：将本地化的配置信息（ Properties 、 XML 、 YAML 等形式）注册到配置中心，实现程序包在开发、测试、生产环境中的无差别性，方便程序包的迁移。</li><li>集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形 式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够 在统一的界面中使用系统。</li><li>调用链监控：记录完成一次请求的先后衔接和调用关系，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。</li><li>支撑平台：系统微服务化后，各个业务模块经过拆分变得更加细化，系统的部署、运维、监控等都比单体应用架构更加复杂，这就需要将大部分的工作自动化。 现在，Jenkins、Docker、Kubernetes等工具可以给微服务架构的部署带来较多的便利，例如持续集成、蓝绿 发布、健康检查、性能健康等等。如果没有合适的支撑平台或工具，微服务架构就无法发挥它最大的功效 。</li></ul><p>微服务架构模式有很多优势可以有效解决单体应用扩大之后出现的大部分问题。首先，通过将巨大单体式应用分解为多个服务的方法解决了复杂性问题。在功能不变的情况下，应用分解为多个可管理的模块或服务。每个服务都有一个用RPC或者消息驱动API定义清楚的边界。微服务架构模式为采用单体式编码方式，由此，单个服务变得很容易开发、理解和维护。<br>其次，微服务架构模式使得团队并行开发得以推进，每个服务都可以由专门开发团队来开发。不同团队的开发者可以自由选择开发技术，提供API服务。这种自由意味着开发者不需要被迫使用之前采用的过时技术，他们可以选择最新的技术。甚至于，因为服务都是相对简单的，即使用新技术重写以前的代码也不是很困难的事情。</p><p>微服务的一些想法是好的，但在实践中也会呈现出其复杂性，具体如下：</p><ul><li>运维要求较高：更多的服务意味着需要更多的运维投入。在单体架构中只需要保证一个应用的正常运行即可；而在微服务中，需要保证几十甚至几百个服务的正常运行与协作，这带来了巨大的挑战。 </li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统来说，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。</li><li>接口调整成本高：微服务之间通过接口进行通信。 如果修改某个微服务的API，可能所有使用了该接口 的微服务都需要做调整。</li><li>重复劳动：很多服务可能都会使用到相同的功能， 而这个功能并没有达到分解为一个微服务的程度， 这个时候，可能各个服务都会开发这一功能，导致代码重复。</li><li>可测试性的挑战：在动态环境下，服务间的交互会产生非常微妙的行为，难以进行可视化及全面测试。</li></ul><h2 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h2><p>Spring Cloud是一系列框架的有序集合。目前由 Spring 官方开发维护，基于 Spring Boot 开发，提供一套完整的微服务解决方案。包括服务注册与发现、配置中心、全链路监控、 API 网关、熔断器等开源组件，可以随需扩展和替换组装。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>Spring Cloud 不同于其他独立项目，它是拥有众多子项目的项目集合。因为 Spring Cloud 的子项目居多，每个子项目有自己的版本号，为了对 Spring Cloud 整体进行版本编号，确定一个可用于生产上的版本标识。这些版本采用伦敦地铁站的名字，按名称首字母排序，比如 Dalston 版、Edgware 版、Finchley 版、Greenwich 版。</p><h2 id="Spring-Cloud-组成"><a href="#Spring-Cloud-组成" class="headerlink" title="Spring Cloud 组成"></a>Spring Cloud 组成</h2><p>Spring Cloud 包含的组件众多，各个组件都有各自不同的特性和优点，为使用者提供丰富的选择 ：</p><ul><li><p>服务注册与发现组件：Eureka、Zookeeper 和 Consul 等。</p></li><li><p>服务调用组件：Hystrix、Ribbon 和 OpenFeign。其中 Hystrix 能够使系统在出现依赖服务访问不可达的情况下，通过隔离系统依赖服务的方式，防止服务雪崩，同时提供失败回滚机制，使系统能够更快地从异常中恢复。Ribbon 用于提供客户端的软件负载均衡算法，还提供了一系列完善的配置项如连接超时、重试等。OpenFeign 是一个声明式 RESTful 网络请求客户端，它使编写 Web 服务客户端变得更加方便和快捷。</p></li><li><p>路由和过滤组件：包括 Zuul 和 Spring Cloud Gateway。Spring Cloud Gateway 提供了一个构建在 Spring 生态 之上的 API 网关，其旨在提供一种简单而有效的途径来发送API，并为他们提供横切关注点。如：安全性、监控指标和弹性。</p></li><li><p>消息组件：Spring Cloud Stream 和 Spring Cloud Bus。Spring Cloud Stream 对于分布式消息的各种需求进行了抽象，包括发布订阅、分组消费和消息分区等功能，实现了微服务之间的异步通信。Spring Cloud Bus 主要提供了服务间的事件通信（比如：刷新配置 ）。</p></li><li><p>安全控制组件：Spring Cloud Security 基于 OAuth2.0 开放网络的安全标准，提供了微服务环境下的单点登录、资源授权和令牌管理等功能。</p></li><li><p>链路监控组件：Spring Cloud Sleuth 提供了全自动、可配置的数据埋点，以 收集微服务调用链路上的性能数据，并可以结合 Zipkin 进行数据存储、统计和展示。</p></li></ul><p>除了上述组件之外，Spring Cloud 还提供了命令行工具 Spring Cloud Cli 和集群工具 Spring Cloud Cluster。 Spring Cloud Cli 提供了以命令行和脚本的方式来管理微服务及 Spring Cloud 组件的方式，Spring Cloud Cluster 提供了集群选主、分布式锁和一次性令牌等分布式集群需要的技术组件。</p><table><thead><tr><th style="text-align:center">组件名称</th><th style="text-align:center">所属项目</th><th style="text-align:center">组件分类</th></tr></thead><tbody><tr><td style="text-align:center">Eureka</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Consul</td><td style="text-align:center">spring-cloud-consul</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zookeeper</td><td style="text-align:center">spring-cloud-zookeeper</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zuul</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">第一代网关</td></tr><tr><td style="text-align:center">Ribbon</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">负载均衡</td></tr><tr><td style="text-align:center">Hystrix</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">熔断器</td></tr><tr><td style="text-align:center">Turbine</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">集群监控</td></tr><tr><td style="text-align:center">Feign</td><td style="text-align:center">spring-cloud-openfeign</td><td style="text-align:center">远程调用</td></tr><tr><td style="text-align:center">Gateway</td><td style="text-align:center">spring-cloud-gateway</td><td style="text-align:center">第二代网关</td></tr><tr><td style="text-align:center">Sleuth</td><td style="text-align:center">spring-cloud-seluth</td><td style="text-align:center">链路追踪</td></tr><tr><td style="text-align:center">Bus</td><td style="text-align:center">spring-cloud-bus</td><td style="text-align:center">总线</td></tr><tr><td style="text-align:center">config</td><td style="text-align:center">spring-cloud-config</td><td style="text-align:center">配置中心</td></tr><tr><td style="text-align:center">Pipeline</td><td style="text-align:center">spring-cloud-pipeline</td><td style="text-align:center">部署管道</td></tr><tr><td style="text-align:center">Dataflow</td><td style="text-align:center">spring-cloud-dataflow</td><td style="text-align:center">数据处理</td></tr><tr><td style="text-align:center">Security</td><td style="text-align:center">spring-cloud-Security</td><td style="text-align:center">安全控制</td></tr></tbody></table><p>Spring Cloud 并不能与微服务或者微服务架构划上等号，不能误认为使用了 Spring Cloud 的应用服务就是微服务。微服务架构是一种架构的理念，重点是微服务的设计原则，从理论上为具体的技术落地提供了指导思想。Spring Cloud 是一个基于 Spring Boot 实现的服务治理工具包，关注全局的服务治理框架。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）服务注册与发现之 Spring Cloud Eureka</title>
      <link href="/springcloud/eureka/springcloud2/"/>
      <url>/springcloud/eureka/springcloud2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在传统的单体应用中，组件之间的调用通过有规范约束的接口进行，从而实现不同模块间良好协作。在微服务架构中，原本的“巨石”应用按照业务被分割成相对独立的、提供特定功能的微服务，每一个微服务都可以通过集群或者其他方式进行动态扩展，每一个微服务实例的网络地址都可能动态变化，这使得原本通过硬编码地址的调用方式失去了作用。微服务架构中，服务地址的动态变化和数量变动，迫切需要系统建立一个中心化的组件对各个微服务实例信息进行登记和管理，同时让各个微服务实例之间能够互相发现，从而达到互相调用的结果。</p><p>通常来说服务注册与发现包括两部分一个是服务器端，另一个是客户端。Server 是一个公共服务，为 Client 提供服务注册和发现的功能，维护注册到自身的 Client 的相关信息，同时提供接口给 Client 获取注册表中其他服务的信息，使得动态变化的 Client 能够进行服务间的相互调用。Client 将自己的服务信息通过一定的方式登记到 Server 上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过 Server 获取到自己依赖的其他服务信息，完成服务调用。</p><p>Eureka Server 端采用的是 P2P 的复制模式，但是它不保证复制操作一定能成功，因此它提供的是一个最终一致性的服务实例视图。Client 端在 Server 端的注册信息有一个带期限的租约，一旦 Server 端在指定期间没有收到 Client 端发送的心跳，则 Server 端会认为 Client 端注册的服务是不健康的，定时任务会将其从注册表中删除。</p><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供用于服务发现和注册的基础组件，是搭建 Spring Cloud 微服务架构的前提之一。Eureka 作为一个开箱即用的基础组件，屏蔽了底层 Server 和 Client 交互的细节，使得开发者能够将精力更多地放在业务逻辑上，加快微服务架构的实施和项目的开发。</p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>搭建一个 Eureka Server 非常简单，创建一个maven项目，添加一个 spring-cloud-starter-netflix-eureka-server 依赖。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>    <span class="comment"># eureka server 没必要自己把自己注册上去，所以可以设置成 false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否从Eureka Server上获取注册信息，默认为true，此处建议修改成 false</span></span><br></pre></td></tr></table></figure><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，访问 <a href="http://localhost:8761" target="_blank" rel="noopener">http://localhost:8761</a> 就会看到如下界面，至此一个简单的 Eureka Server 就搭建好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-bdab176bd8d6e083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>Eureka Server 注册中心已经创建好了，下面我们来创建一个 Eureka Client 注册到 Eureka Server 中。 </p><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">   application:</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动程序-1"><a href="#启动程序-1" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，刷新 Eureka Server 界面，会发现服务已经注册上来了，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-c24668ad0aeaa041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Eureka-Server-的-REST-API"><a href="#Eureka-Server-的-REST-API" class="headerlink" title="Eureka Server 的 REST API"></a>Eureka Server 的 REST API</h2><p>Eureka 使用的是 JAVA 语言开发的，但是 Eureka Server 提供 REST API，可以让非 JAVA 语言的其它语言开发的应用服务通过 HTTP REST 的方式注册到 Eureka Server 中。</p><h3 id="REST-API-列表"><a href="#REST-API-列表" class="headerlink" title="REST API 列表"></a>REST API 列表</h3><table><thead><tr><th>功能</th><th>API</th></tr></thead><tbody><tr><td>注册新的应用实例</td><td>POST /eureka/apps/{appId}</td></tr><tr><td>注销应用实例</td><td>DELETE /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>应用实例发送心跳</td><td>PUT /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>查询所有实例</td><td>GET /eureka/apps</td></tr><tr><td>查询指定appId的实例</td><td>GET /eureka/apps/{appId}</td></tr><tr><td>根据指定appId和instanceId查询</td><td>GET /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>根据指定instanceId查询</td><td>GET /eureka/instances/{instanceId}</td></tr><tr><td>暂停应用实例</td><td>PUT /eureka/apps/ {appId}/ {instanceId}/status?value=OUT_OF_SERVICE</td></tr><tr><td>恢复应用实例</td><td>DELETE /eureka/apps/{appId}/{instanceld}/status?value=UP (value参数可不传)</td></tr><tr><td>更新元数据</td><td>PUT /eureka/apps/{appId}/{instanceId}/metadata?key=value</td></tr><tr><td>根据vip地址查询</td><td>GET /eureka/vips/{vipAddress}</td></tr><tr><td>根据svip地址查询</td><td>GET /eureka/svips/{svipAddress}</td></tr></tbody></table><h2 id="Spring-Cloud-Eureka-的核心类"><a href="#Spring-Cloud-Eureka-的核心类" class="headerlink" title="Spring Cloud Eureka 的核心类"></a>Spring Cloud Eureka 的核心类</h2><h3 id="InstanceInfo"><a href="#InstanceInfo" class="headerlink" title="InstanceInfo"></a>InstanceInfo</h3><p>Instancelnfo 类代表注册的服务实例，主要有如下字段：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>instanceId</td><td>实例id</td></tr><tr><td>app</td><td>应用名</td></tr><tr><td>appGroupName</td><td>应用所属群组</td></tr><tr><td>ipAddr</td><td>ip 地址</td></tr><tr><td>port</td><td>端口号</td></tr><tr><td>securePort</td><td>https 的端口号</td></tr><tr><td>homePageUrl</td><td>应用实例的首页 url</td></tr><tr><td>statusPageUrl</td><td>应用实例的状态页 url</td></tr><tr><td>healthCheckUrl</td><td>应用实例健康检查的 url</td></tr><tr><td>secureHealthCheckUrl</td><td>应用实例健康检查的 https 的 url</td></tr><tr><td>vipAddress</td><td>虚拟 ip 地址</td></tr><tr><td>secureVipAddress</td><td>https 的虚拟 ip 地址</td></tr><tr><td>hostName</td><td>主机名称</td></tr><tr><td>status</td><td>实例状态，如 UP、DOWN、STARTING、OUT_OF_SERVICE、UNKNOWN</td></tr><tr><td>overriddenstatus</td><td>外界需要强制覆盖的状态值，默认为 UNKNOWN</td></tr><tr><td>leaselnfo</td><td>租约信息</td></tr><tr><td>metadata</td><td>应用实例的元数据信息</td></tr><tr><td>lastUpdatedTimestamp</td><td>状态信息最后更新时间</td></tr><tr><td>lastDirtyTimestamp</td><td>实例信息最新的过期时间，在 Client 端用于标识该实例信息是否与 Eureka Server 一致，在 Server 端则用于多个 Eureka Server 之间的信息同步处理</td></tr><tr><td>actionType</td><td>标识 Eureka Server 对该实例执行的操作 ，包括 ADDED 、 MODIFIED 、 DELETED 这三类</td></tr><tr><td>asgName</td><td>在 AWS 的 autoscaling group 的名称</td></tr></tbody></table><h3 id="Leaselnfo"><a href="#Leaselnfo" class="headerlink" title="Leaselnfo"></a>Leaselnfo</h3><p>Leaselnfo 类标识应用实例的租约信息，用于标识应用实例的心跳情况，比如约定的心跳周期，租约有效期，最近一次续约的时间，主要有一下字段：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>renewalintervalinSecs</td><td>Client 端续约的间隔周期</td></tr><tr><td>durationlnSecs</td><td>Client 端需要设定的租约的有效时长</td></tr><tr><td>registrationTimestamp</td><td>Server 端设置的该租约的第一次注册时间</td></tr><tr><td>lastRenewalTimestamp</td><td>Server 端设置的该租约的最后一次续约时间</td></tr><tr><td>evictionTimestamp</td><td>Server 端设置的该租约被剔除的时间</td></tr><tr><td>serviceUpTimestamp</td><td>Server 端设置的该服务实例标记为 UP 的时间</td></tr></tbody></table><h3 id="ServiceInstance"><a href="#ServiceInstance" class="headerlink" title="ServiceInstance"></a>ServiceInstance</h3><p>ServiceInstance 是 Spring Cloud 对服务发现的实例信息的抽象接口，因为 Spring Cloud Discovery 适配了 Zookeeper，Consul，Netfix Eureka 等注册中心，所以 ServiceInstance 定义更为抽象和通用。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>getServiceId()</td><td>服务ID</td></tr><tr><td>getHost()</td><td>实例的host</td></tr><tr><td>getPort()</td><td>实例的端口</td></tr><tr><td>isSecure()</td><td>实例是否开启https</td></tr><tr><td>getUri()</td><td>实例的 uri 地址</td></tr><tr><td>getMetadata()</td><td>实例的元数据信息</td></tr><tr><td>getScheme()</td><td>实例的 scheme</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、【Java并发】初识线程</title>
      <link href="/javaThread/thread1/"/>
      <url>/javaThread/thread1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h2><p>对于计算机来说每一个任务就是一个进程，在进程运行过程中必须至少有一条线程实在运行中。线程本身是不会独立存在的，因为线程是进程中的一个执行路径。</p><p>操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU 分配的基本单位。在Java中，当我们启动main函数时其实就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p><blockquote><p>在单核CPU的计算机中，其实并没有真正的并行运算，一般是使用时间片轮转方式让线程轮询占用的，只不过快速的轮转调度带给你的错觉，让你产生了它们真的在同一时刻同时运行。当然如果是多核CPU,那么并行运行还是真实存在的。</p></blockquote><h2 id="2-JAVA中的线程创建和运行"><a href="#2-JAVA中的线程创建和运行" class="headerlink" title="2.JAVA中的线程创建和运行"></a>2.JAVA中的线程创建和运行</h2><p>Java中有三种线程的创建方式，分别为实现Runnable接口的run方法，集成Thread类重写run方法，使用FutureTask方式。</p><h3 id="首先来看看Thread类方式的实现"><a href="#首先来看看Thread类方式的实现" class="headerlink" title="首先来看看Thread类方式的实现"></a>首先来看看Thread类方式的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//继承Thread,重写run方法</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        //创建线程</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        //启动线程</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出MyThread类继承了Thread类，并重写了run()方法。在 main 函数中创建了MyThread的实例并调用了start方式启动了线程。</p><p>使用继承有个不好的地方就是Java是不支持多继承的，所以如果使用了继承方式，那么就不能再继承其他类。还有就是任务与代码没有分离，当多个线程执行一样的任务时就会产生代码冗余。而Runable就没有这个限制。下面我们来看看Runnable接口的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//实现Runnable接口</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        </span><br><span class="line">        new Thread(myThread).start();</span><br><span class="line">        new Thread(myThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，两个线程公用了一个代码逻辑，并且MyThread可以继承其他类。但是两种方式都有一个缺点，就是任务没有返回值。下面我们可以来看看FutureTask方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//实现Callable接口</span><br><span class="line">class MyThread implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        //创建任务</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myThread);</span><br><span class="line">        </span><br><span class="line">        //启动线程</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            //等待任务执行完成,并返回结果</span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的MyThread类实现了Callable接口的call()方法。在main函数中创建了一个FutrueTask对象，然后使用FutrueTask对象作为任务创建一个线程并启动。最后通过get()等待任务执行完成拿到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、【Java并发】线程生命周期以及常用方法详解</title>
      <link href="/javaThread/thread2/"/>
      <url>/javaThread/thread2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>每个线程都有自己的生命周期，下面我们就来详细的了解一下。 </p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-34eb0171effba7ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>从上图我们可以看出线程的生命周期大致可以分为五个阶段：</p><ul><li>NEW(新建状态)</li><li>RUNNABLE(就绪状态)</li><li>RUNNING(运行状态)</li><li>BLOCKED(阻塞状态)</li><li>TERMINATED(死亡状态)</li></ul><h3 id="NEW-新建状态"><a href="#NEW-新建状态" class="headerlink" title="NEW(新建状态)"></a>NEW(新建状态)</h3><p>当我们new一个Thread对象时，此时它并不处于运行状态，因为还没有调用start方法启动线程。那么线程的NEW状态，其实只是Thread对象的状态，在没有调用start方法之前，该线程根本不存在，和new一个普通的Java对象没什么区别。NEW状态可以通过start方法进入RUNNABLE状态。</p><h3 id="RUNNABLE-就绪状态"><a href="#RUNNABLE-就绪状态" class="headerlink" title="RUNNABLE(就绪状态)"></a>RUNNABLE(就绪状态)</h3><p>线程对象进入RUNNABLE状态必须调用start方法，此时JVM进程中才会真正的创建一个线程，线程启动后并不会立即得到执行。线程是否运行和进程一样都要听从CPU的调度，为此我们把这个中间状态成为就绪状态，也称为可执行状态(RUNNABLE),也就是说它具备执行的资格，但是并没有真正的执行而是在等待CPU的调度。</p><p>由于存在Running状态，所以不会直接进人BLOCKED状态和TERMINATED状态，即使是在线程的执行逻辑中调用wait、sleep或者其他block的I0操作等，也必须先获得CPU的调度执行权才可以，严格来讲，RUNNABLE的线程只能意外终止或者进人RUNNING状态。</p><h3 id="RUNNING-运行状态"><a href="#RUNNING-运行状态" class="headerlink" title="RUNNING(运行状态)"></a>RUNNING(运行状态)</h3><p>一旦CPU通过时间片轮转或者其他方式选中了线程，那么此时它才能真正的执行自己的逻辑。这里需要注意的一点是一个正在RUNNING状态的线程其实也是RUNNABLE的，但是反过来则不成立。<br>在RUNNING状态中，线程的状态可以发生如下的状态转换：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者判断某个逻辑标识。</li><li>进人BLOCKED状态，比如调用了sleep,或者wait方法而加入了waitSet 中。</li><li>进行某个阻塞的I0操作，比如因网络数据的读写而进入了BLOCKED状态。</li><li>获取某个锁资源，从而加入到该锁的阻塞队列中而进人了BLOCKED状态。</li><li>由于CPU的调度器轮询使该线程放弃执行，进人RUNNABLE状态。</li><li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态。</li></ul><h3 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED(阻塞状态)"></a>BLOCKED(阻塞状态)</h3><p>上面列举了线程进入BLOCKED状态的原因，下面我们在列举线程在BLOCKED状态中可能切换的状态：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡(JVM Crash)。</li><li>线程阻塞的操作结束，比如读取了想要的数据字节进人到RUNNABLE状态。</li><li>线程完成了指定时间的休眠，进人到了RUNNABLE状态。</li><li>Wait中的线程被其他线程notify/notifyall唤醒，进人RUNNABLE状态。</li><li>线程获取到了某个锁资源，进人RUNNABLE状态。</li><li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进人RUNNABLE状态。</li></ul><h3 id="TERMINATED-死亡状态"><a href="#TERMINATED-死亡状态" class="headerlink" title="TERMINATED(死亡状态)"></a>TERMINATED(死亡状态)</h3><p>TERMINATED状态是线程最终状态，在该状态的线程不会再切换到其它任何状态，意味着线程的整个生命周期都结束了。</p><h2 id="Thread-API详解"><a href="#Thread-API详解" class="headerlink" title="Thread API详解"></a>Thread API详解</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><blockquote><p>sleep是一个静态方法，其有两个重载方法，其中一个需要传入毫秒，另外一个既需要毫秒数，还需要纳秒数<br>public static native void sleep(long millis) throws InterruptedException;<br>public static void sleep(long millis, int nanos) throws InterruptedException</p></blockquote><p>sleep方法会使当前线程休眠指定的毫秒数，暂停执行，其中有个要注意的点，sleep并不会释放锁资源。</p><p>JDK1.5以后，JDK引入了一个枚举TimeUnit，其对sleep做了很好的封装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一天</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一小时</span></span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一毫秒</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield也是一个静态方法，调用此方法会提醒调度器我愿意放弃当前的cpu资源，如果CPU资源不紧张的话，调度器可能会忽略这个提醒。操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度，而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片中还没有使用完的部分自己不想使用了，这暗示线程调度器现在就可以进行下一轮的线程调度。</p><blockquote><p>sleep 与 yield 方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂 起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield 方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。</p></blockquote><h3 id="setPriority-amp-getPriority-线程优先级"><a href="#setPriority-amp-getPriority-线程优先级" class="headerlink" title="setPriority()&amp;getPriority() 线程优先级"></a>setPriority()&amp;getPriority() 线程优先级</h3><p>在操作系统中，进程有优先级之分，线程同样也有优先级，理论上优先级高的线程有被CPU优先调度的机会，但真实情况往往并不会如你所愿，因为设置线程优先级也是一个hint(暗示)操作。</p><ul><li>对于root用户，它会hint操作系统你想要设置的优先级别，否则它会被忽略。</li><li>在CPU比较忙的情况下，设置优先级可能会获取更多的CPU调度机会，但是闲时优先级的高低一般不会有任何作用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//简单来看看设置优先级方法的源码</span><br><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        if((g = getThreadGroup()) != null) &#123;</span><br><span class="line">            if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析如上代码，可以看出线程的优先级必须是1~10，如果指定的线程优先级大于线程所在的group的优先级，那么会忽略指定的优先级从而获取group的最大优先级。线程默认的优先级和创建它的那个线程保持一致，一般情况下都是5.</p><h3 id="获取线程ID-getId"><a href="#获取线程ID-getId" class="headerlink" title="获取线程ID getId()"></a>获取线程ID getId()</h3><p>getId()获取线程的唯一ID,线程的ID在整个JVM进程中都是唯一的。</p><h3 id="线程-interrupt相关方法"><a href="#线程-interrupt相关方法" class="headerlink" title="线程 interrupt相关方法"></a>线程 interrupt相关方法</h3><ul><li><p>interrupt()方法<br>在线程内部存在着名为interrupt flag的标识，如果一个线程调用了interrupt方法，flag会被设置，但是如果当前线程正处于阻塞状态时，调用interrupt，线程将会中断阻塞，并且会抛出InterruptedException异常，这个异常就像是一个signal(信号)一样通知当前线程被打断了，并且flag会被清除。</p></li><li><p>isInterrupted()方法<br>此方法是Thread类的实例方法，主要判断当前线程是否被中断。</p></li><li><p>interrupted()方法<br>此方法是Thread中的一个静态方法，也是主要用于判断当前线程是否被中断，但是它和isInterrupted()方法有个区别就是该方法会直接清除掉该线程的interrupt标识</p></li></ul><h3 id="线程join方法"><a href="#线程join方法" class="headerlink" title="线程join方法"></a>线程join方法</h3><p>join方法会使当前线程永远的等待下去，直到期间被另外的线程中断，或者join的线程执行结束，也可以使用另外两个重载方法，指定等待毫秒数，在指定的时间到达之后，当前线程也回退出阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join() 一直等待</span><br><span class="line">join(long millis) 等待指定毫秒数</span><br><span class="line">join(long millis, int nanos) 等待指定毫秒数</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、【Java并发】线程间通信之wait,notify,notifyAll</title>
      <link href="/javaThread/thread4/"/>
      <url>/javaThread/thread4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>在多线程编程当中，很多时候我们需要一个线程修改了某个值之后，而另外一个线程能够感知到变化从而进行响应的操作。比较笨的方法呢就是不断轮询判断，如果条件满足进行响应的操作，反之则等待若干时间后再次轮询判断。就如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断)&#123; </span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure></p><p>上面这段伪代码看似能够实现所需的功能，但是却有着很严重的问题：</p><ul><li>难以确保及时性。在休眠的时候，确实不会消耗处理器资源，但是通过睡眠机制，就不能及时的发现条件已经变化。</li><li>难以降低开销。如果降低睡眠的时间，比如1毫秒，这样确实能迅速的发现条件变化，但是却可能消耗更多的处理器资源，造成不必要的浪费。</li></ul><p>以上两个问题，看似矛盾难以取舍。但是Java通过等待/通知机制就能很好的解决问题并实现所需的功能。</p><h2 id="初识-wait-amp-notify"><a href="#初识-wait-amp-notify" class="headerlink" title="初识 wait &amp; notify"></a>初识 wait &amp; notify</h2><p>等待/通知相关方法是任意Java对象都具备的，因为这些方法是被定义在java.lang.Object对象上的，方法描述如下</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>notify()</td><td>通知一个在对象上等待的线程，使其从wait()方法返回，返回的前提是该线程重新获取到了对象的锁</td></tr><tr><td>notifyAll()</td><td>通知所有等待在改对象上的线程</td></tr><tr><td>wait()</td><td>调用该方法的线程进入阻塞状态并且会释放对象的锁，只有等待其他线程通知或被终端才会返回，</td></tr><tr><td>wait(long)</td><td>等待指定一段时间，时间一到就返回</td></tr><tr><td>wait(long,int)</td><td>等待指定一段时间，对于超时时间更加细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object  lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 开始"</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 结束"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 开始工作"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">                    <span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 开始"</span>);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 完成 开始睡眠"</span>);</span><br><span class="line">                    SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"睡眠结束即将释放锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出内容：<br><img src="https://upload-images.jianshu.io/upload_images/1455014-d2bb1f5e464ca80f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>通过上面的示例代码，会发现使用wait/notfiy相关方法时需要注意一下细节：</p><ul><li>使用wait(),notify(),notifyAll()时需要先获取到该对象的锁。</li><li>使用wait()方法会使线程进入阻塞状态，并且会释放锁。</li><li>调用notify(),notifyAll()方法后，被通知的线程依旧不会从wait返回，需要调用notify()方法的线程释放锁之后，并且等待的线程重新获取到锁之后才会返回。</li><li>notify()方法是将等待队列中的一个等待线程从等待队列移到同步队列中，而notifyAll()方法是讲等待队列中的所有线程全部移到同步队列中</li></ul><h2 id="wait-amp-sleep-的区别"><a href="#wait-amp-sleep-的区别" class="headerlink" title="wait &amp; sleep 的区别"></a>wait &amp; sleep 的区别</h2><p>从表面上来看，wait和sleep都能使当前线程进入阻塞状态，但两者还是有着本质上的区别：</p><ul><li>wait和sleep方法都可以使线程进入阻塞状态，并且均是可中断方法，被中断后都会收到中断异常。</li><li>wait是Object方法，sleep是Thread独有的方法。</li><li>wait需要在同步方法中调用，而sleep不需要。</li><li>wait方法会释放锁，而sleep方法并不会释放锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、【Java并发】JMM之happens-before</title>
      <link href="/javaThread/thread5/"/>
      <url>/javaThread/thread5/</url>
      
        <content type="html"><![CDATA[<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><blockquote><p>happens-before是Java内存模型最核心的概念，因此理解happens-before是理解Java内存模型的关键。</p></blockquote><p>在Java语言中有个happens-before(先行发生)的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依据，依靠这个原则，我们就可以解决在并发环境中两个操作之间可能存在冲突的所有问题。下面我们来看个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>; <span class="comment">//A线程执行</span></span><br><span class="line">j = i; <span class="comment">//B线程执行</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">//C线程执行</span></span><br></pre></td></tr></table></figure></p><p>这里我们分两个情况来分析：</p><ul><li>线程C不执行<br>  假设A线程先行发生于线程B，根据先行发生原则那么就可以确定线程B执行完后，j一定等于1。</li><li>线程C执行<br>  我们依然保持线程A先行与B线程，但此时线程C出现在线程A,B之间,假设线程C与线程B之间没有先行发生原则的话，此时j的值就不确定了！！！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就可能读取到过期数据的风险，不具备多线程安全性。</li></ul><h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>Java内存模型下自带了写先行发生原则，这些先行发现原则无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在其中，并且无法从下面的规则推导出来的话，它们就没有顺序性保障，因为虚拟机可以对它们随意的进行重排序。</p><ul><li><p>程序次序规则：一个线程内，按照代码编写顺序，写在前面的操作happens-before写在后面的操作。但还是有可能指令重排，但随便怎么排，最后的结果应该和重排前代码顺序的结果是一致的。</p></li><li><p>管程锁定规则：对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。(管程是一种通用的同步术语，synchronized就是管程的实现)</p></li><li><p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果对读的这个线程是可见的。对一个volatile变量的写操作happens-before后面对这个变量的读操作(这里针对的是指令重排)；</p></li><li><p>线程启动规则：Thread对象的start()方法happens-before此线程的每一个动作；在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p></li><li><p>线程终止规则：线程中所有的操作都happens-before线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p></li><li><p>线程中断规则：对线程interrupt()方法的调用happens-before被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p></li><li><p>传递规则：就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p></li><li><p>对象终结规则：就是一个对象的初始化的完成，也就是构造函数执行的结束一定happens-before它的finalize()方法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、【Java 并发】ThreadGroup 详解</title>
      <link href="/javaThread/thread6/"/>
      <url>/javaThread/thread6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="ThreadGroup-与-Thread"><a href="#ThreadGroup-与-Thread" class="headerlink" title="ThreadGroup 与 Thread"></a>ThreadGroup 与 Thread</h2><p>默认情况下，新的线程都会加入到创建它的线程（也就是父线程）所在的 group 中。如同线程存在父子关系一样，ThreadGroup 同样也存在父子关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-8c2d07205b753673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="创建-ThreadGroup"><a href="#创建-ThreadGroup" class="headerlink" title="创建 ThreadGroup"></a>创建 ThreadGroup</h2><p>创建 ThreadGroup 非常简单，可通过两个构造函数来创建。</p><ul><li>public ThreadGroup(String name) </li><li>public ThreadGroup(ThreadGroup parent, String name) </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定名称不指定父线程组  (默认父线程组为创建线程组的线程的线程组,也就是当前线程的父线程组)</span></span><br><span class="line">    ThreadGroup myGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"myGroup"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定名称  指定父线程组</span></span><br><span class="line">    ThreadGroup myGroup2 = <span class="keyword">new</span> ThreadGroup(myGroup, <span class="string">"myGroup2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制-Thread"><a href="#复制-Thread" class="headerlink" title="复制 Thread"></a>复制 Thread</h2><ul><li>public int enumerate(Thread list[]) </li><li>public int enumerate(Thread list[], boolean recurse)</li></ul><p>两个方法，都可以讲 Thread 中的 active 线程全部复制到 Thread 数组中，其中 recurse 参数如果为 true，则会将所有的自 group 中的 active 线程都递归到 Thread 数组中，enumerate(Thread list[])等价于enumerate(Thread list[], true)，如果为 false，只会复制调用此方法的线程组中的 active 线程，其子线程组中的 active 线程不会复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定名称不指定父线程组  (默认父线程组为创建线程组的线程的线程组,也就是当前线程的父线程组)</span></span><br><span class="line">        ThreadGroup myGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"myGroup"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myGroup,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定名称  指定父线程组</span></span><br><span class="line">        ThreadGroup myGroup2 = <span class="keyword">new</span> ThreadGroup(myGroup, <span class="string">"myGroup2"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myGroup2,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myGroup2,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"activecount: "</span>+myGroup.activeCount());</span><br><span class="line">        <span class="comment">//myGroup.activeCount() 获取线程组中的 active 线程数,包括子线程组中的</span></span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[myGroup.activeCount()];</span><br><span class="line"><span class="comment">//        int size = myGroup.enumerate(t,true);</span></span><br><span class="line">        <span class="keyword">int</span> size = myGroup.enumerate(t,<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">"size: "</span>+size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>enumerate 方法获取的线程仅仅是个预估值，并不能百分之百地保证当前 group 的活跃线程，比如在调用复制之后，某个线程结束了声明周期或者新的线程加入了进来，都会导致数据不准确。<br>enumerate 方法返回值是本次复制，active 线程真实的数量。</p></blockquote><h2 id="复制-ThreadGroup-数组"><a href="#复制-ThreadGroup-数组" class="headerlink" title="复制 ThreadGroup 数组"></a>复制 ThreadGroup 数组</h2><ul><li>public int enumerate(ThreadGroup list[]) </li><li>public int enumerate(ThreadGroup list[], boolean recurse) </li></ul><p>和复制 Thread 数组类似，上面两个方法主要用于复制当前 ThreadGroup 的子 Group，同样 recurse 会决定是否复制子 Group 中的子 Group。</p><h2 id="ThreadGroup-操作"><a href="#ThreadGroup-操作" class="headerlink" title="ThreadGroup 操作"></a>ThreadGroup 操作</h2><p>ThreadGroup 并不能提供对线程的管理，ThreadGroup 的主要功能是对线程进行组织。</p><ul><li>activeCount() 用于获取 group 中活跃的线程，这只是个估计值，并不能百分之百的保证正确。</li><li>activeGroupCount() 获取 group 中活跃的子 group，这也是一个估值，方法方法会递归获取所有子 group。</li><li>getMaxPriority() 用于获取 group 的优先级，默认情况下，Group 的优先级为 10，在group 中，所有线程的优先级都不能大于 group 的优先级</li><li>getName() 获取 group 的名字</li><li>getParent() 用于获取 group 的父 group，如果父 group 不存在，则会返回 null，比如 system group 的父 group 就为 null。</li><li>list() 该方法没有返回值，调用该方法会将 group 中所有的活跃线程信息全部输出到控制台，也就是 System.out</li><li>parentOf(ThreadGroup g) 会判当前 group 是不是传入 group 的父 group。如果传入的 group 就是自己本身，该方法也回返回 true。</li><li>setMaxPriority(int pri) 指定 group 的最大优先级，最大优先级不能超过父 group 的最大优先级，执行该方法不仅会改变当前 group 的最大优先级，还会改变所有子 group 的最大优先级</li></ul><h2 id="ThreadGroup-的-interrupt"><a href="#ThreadGroup-的-interrupt" class="headerlink" title="ThreadGroup 的 interrupt"></a>ThreadGroup 的 interrupt</h2><p>interrupt 一个 ThreadGroup 会导致该 group 中所有的 active 线程都被 interrupt，也就是说该 group 中所有子线程的 interrupt 标识都被设置了。</p><h2 id="ThreadGroup-的-destroy"><a href="#ThreadGroup-的-destroy" class="headerlink" title="ThreadGroup 的 destroy"></a>ThreadGroup 的 destroy</h2><p>destroy 用于销毁 ThreadGroup，该方法只是针对一个没有任何 active 线程的 group 进行一次 destroy 标记，调用该方法的直接结果是在父 group 中将自己移除，调用 destroy 方法的前提是该 ThreadGroup 中所有的线程必须是空的，也就是说所有线程包括子 group 中所有线程都已经停止运行，如果有 active 线程存在，调用 destroy 方法则会抛出异常。</p><h2 id="守护-ThreadGroup"><a href="#守护-ThreadGroup" class="headerlink" title="守护 ThreadGroup"></a>守护 ThreadGroup</h2><p>线程可以设置为守护线程，ThreadGroup 也可以设置为守护 ThreadGroup，但是将一个 ThreadGroup 设置为 daemon，并不会影响线程的 daemon 属性，如果一个 ThreadGroup 被设置为守护，那么在该 group 中没有任何 active 线程的时候该 group 将自动 destroy。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、【Java并发】线程安全之synchronized的原理和应用</title>
      <link href="/javaThread/thread3/"/>
      <url>/javaThread/thread3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Synchronized的实现原理与应用"><a href="#Synchronized的实现原理与应用" class="headerlink" title="Synchronized的实现原理与应用"></a>Synchronized的实现原理与应用</h2><p>在多线程并发编程中线程安全和数据同步一直以来都是不可避免的问题，在JDK1.5版本之前，要解决这个问题需要使用synchronized关键字，synchronized提供了一种排他机制，也就是在同一时间只能有一个线程执行某些操作，很多人都会称呼它为重量级锁，但是随着JDK1.6对synchronized进行了各种优化之后，有些情况下它就并不会显得那么重了。下面我们一起来探究synchronized的实现原理，以及JDK1.6是如何对它进行优化，以及锁的存储结构和升级过程。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性问题，如果一个共享资源对多个线程是可见的，那么该资源的所有读或者写都将通过同步的方式来进行，具体表现如下：</p><ul><li>synchronized提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题得出现</li><li>synchronized在JVM中实现原理是基于进入和退出Monitor对象来实现方法的同步和代码块同步。<ul><li>同步代码块是使用monitorenter 和 monitorexit两个JVM指令实现的。monitorenter指令是在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法结束处和异常处。</li><li>在任何时候任何线程执行到monitorenter成功之前都必须从主内存中获取数据，在monitorexit运行成功之后，共享资源被更新后的值必须刷入主内存。</li></ul></li><li>synchronized的指令严格遵守java happens-before规则，一个monitorexit指令之前必定要有一个monitorenter指令。</li><li>Java中每个对象都可以作为锁，这是synchronized实现同步的基础，具体表现形式如下<ul><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，所示当前类的Class对象</li><li>对于同步方法块，锁是synchronized括号里设置的对象</li></ul></li></ul><h2 id="synchronized堆栈分析-amp-JVM指令分析"><a href="#synchronized堆栈分析-amp-JVM指令分析" class="headerlink" title="synchronized堆栈分析&amp;JVM指令分析"></a>synchronized堆栈分析&amp;JVM指令分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;当前线程:&quot;+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ThreadTest test = new ThreadTest();</span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，在test方法中使用同步代码块方式进行的线程同步，在main方法中定义了2个线程调用test方法，由于同步代码块的互斥性，只能有一个线程获取了mutex monitor的锁，其它的线程只能进入阻塞状态，等待获取mutex monitor的锁的线程释放锁，我可以用JDK自带的工具jconsole来查看堆栈信息，运行上面代码，打开jconsole会看到如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-5262ffd168735d45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>然后我们选中我们运行的程序连接，然后点开线程一栏查看：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1455014-319ed4f8b251044e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/1455014-2e4c0ec5e0ce92aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>我们可以很清楚看到我们创建的两个线程，Thread-0和Thread-1，此时Thread-0处于RUNNABLE状态也就是就绪状态，而Thread-1处于BLOCKED状态，并且清楚的告诉了我们锁拥有者是Thread-0线程。我们再通过jstack命令打印进程的线程的堆栈信息，截取关键的地方对其进行分析：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1455014-1c1be84c051de7de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>Thread-0持有monitor <0x00000007976030e0> 的锁，Thread1线程进入BLOCKED状态并且等待着获取monitor <0x00000007976030e0>。</0x00000007976030e0></0x00000007976030e0></p><p>下面我们再通过JDK命令javap对ThreadTest类进行反汇编，会发现输出了大量的JVM指令，在这些指令中，会发现monitor enter和monitor exit是成对出现的（有些时候会出现一个monitor enter，多个monitor exit，但是每一个monitor exit之前必有对应的monitor enter)，运行如下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c ThreadTest</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yuxuan</span>.<span class="title">thread2</span>.<span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.yuxuan.thread2.ThreadTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">10</span>: dup</span><br><span class="line">      11: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      14: ldc           #5                  // String 当前线程:</span><br><span class="line">      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      19: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      22: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">34</span>: aload_1</span><br><span class="line">      <span class="number">35</span>: monitorexit</span><br><span class="line">      <span class="number">36</span>: goto          <span class="number">44</span></span><br><span class="line">      <span class="number">39</span>: astore_2</span><br><span class="line">      <span class="number">40</span>: aload_1</span><br><span class="line">      <span class="number">41</span>: monitorexit</span><br><span class="line">      <span class="number">42</span>: aload_2</span><br><span class="line">      <span class="number">43</span>: athrow</span><br><span class="line">      <span class="number">44</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="Monitorenter"><a href="#Monitorenter" class="headerlink" title="Monitorenter"></a>Monitorenter</h3><p>一个monitor的lock的锁只会被一个线程在同一时间获得，在一个线程尝试获取monitor的所有权时会发生下面几件事：</p><ul><li>如果monitor的计数器为0，则代表该monitor的lock还没有被获得，一旦被某个线程获得之后会即将对该monitor的计数器加一，也就意味着该线程就是这个monitor的所有者了。</li><li>如果一个已经拥有该monitor所有权的线程重入，则会导致monitor计数器累加。</li><li>如果monitor已经被其他线程拥有，则其他线程尝试获取该monitor所有权时，会陷入阻塞状态直到monitor计数器变为0，才能再次尝试获取monitor的所有权</li></ul><h3 id="Monitorexit"><a href="#Monitorexit" class="headerlink" title="Monitorexit"></a>Monitorexit</h3><p>释放monitor所有权的过程相对比较简单，就是将monitor的计数器减一，如果计数器为0，那就意味着该线程不再拥有对该monitor的所有权，也就是我们常说的解锁。在此同时被该monitor block的线程将再次尝试获取该monitor的所有权。</p><h2 id="使用synchronized的注意点"><a href="#使用synchronized的注意点" class="headerlink" title="使用synchronized的注意点"></a>使用synchronized的注意点</h2><ul><li>与monitor关联的对象不能为空，也就是锁对象不能为null。</li><li>synchronized作用于太大，如果synchronized作用于越大，则代表期效率越低。</li><li>不同的monitor企图锁相同的方法或者代码块。</li><li>多个锁的交叉从而导致死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 工厂方法模式</title>
      <link href="/designPattern/pattern_factory_method/"/>
      <url>/designPattern/pattern_factory_method/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂方法模式又称工厂模式,也叫多态工厂模式,属于类创建型模式<br>工厂方法模式实质就是: 把创建对象的过程抽象出来不实现,让其子类或实现类来决定实例化那个类.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看工厂模式的组成"><a href="#我们先简单的来看看工厂模式的组成" class="headerlink" title="我们先简单的来看看工厂模式的组成:"></a>我们先简单的来看看工厂模式的组成:</h3><blockquote><ol><li>抽象工厂(abstract factory): 抽象对象.</li><li>具体工厂实现(real factory): 实际创建对象的工厂,负责创建一个或多个对象。</li><li>抽象产品(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="抽象Car"><a href="#抽象Car" class="headerlink" title="抽象Car"></a>抽象Car</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* car抽象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 车俩启动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体Car实现"><a href="#具体Car实现" class="headerlink" title="具体Car实现"></a>具体Car实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BMW run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"QQ run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体工厂实现"><a href="#具体工厂实现" class="headerlink" title="具体工厂实现"></a>具体工厂实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BMWCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QQCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a>工厂方法模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在工厂方法模式中，使用方只需要知道所要对象的具体工厂，无须关心具体的创建过程，甚至不需要具体类的类名</li><li>在系统增加新的对象时，我们只需要添加一个具体实现类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次增加一个对象时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式完全符合“开闭原则”。</li><li>工厂方法模式使用继承，将对象的创建交给子类，通过子类实现工厂方法来创建对象。</li><li>工厂方法让子类决定要实例化的类是哪一个。</li><li>在工厂方法模式中，创建者通常会包含依赖于抽象产品的代码，而这些抽象产品是、由子类创建的，创建者不需要真的知道在制作哪种具体产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 简单工厂模式</title>
      <link href="/designPattern/pattern_simple_factory/"/>
      <url>/designPattern/pattern_simple_factory/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>简单工厂模式又称之为静态工厂方法(Static Factory Method), 属于创建型模式。简单工厂模式是根据传递的参数不同, 返回不同实现类的实例对象.（这些类都依赖一个父类或接口） </p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看简单工厂模式的组成"><a href="#我们先简单的来看看简单工厂模式的组成" class="headerlink" title="我们先简单的来看看简单工厂模式的组成:"></a>我们先简单的来看看简单工厂模式的组成:</h3><blockquote><ol><li>工厂类角色(Factory): 工厂类是工厂模式的最重要的组成部分. 向外提供一个创建方法,该方法会根据传递的参数来返回对应的实现类的实例对象。</li><li>抽象产品角色(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现角色(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    car = <span class="keyword">new</span> RedCar();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象Car类"><a href="#抽象Car类" class="headerlink" title="抽象Car类"></a>抽象Car类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> RedCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Car实现类"><a href="#Car实现类" class="headerlink" title="Car实现类"></a>Car实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"red car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 黑色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"black car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>明确了各自的职责和权利，有利于整个软件体系结构的优化</li><li>使用方无须知道创建类的过程,只需要提供对应的参数即可.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于工厂集中了所有对象的创建逻辑,一旦工厂出了问题,就会导致整个系统受到影响.</li><li>系统扩展受限,一旦添加新的对象就需要修改工厂逻辑,在对象类型过多时,势必会导致工厂逻辑过于复杂和臃肿,不利于系统的扩展和维护</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>简单工厂的好处就在于你需要什么,只需要传递一个规则内的参数,就可以获取到所需要的对象.</li><li>简单工厂的核心理念就是把对象的创建和对象的使用分离开来.为此当对象类型过多时势必会导致创建环节的臃肿</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式 —— 单例模式</title>
      <link href="/designPattern/pattern_singleton/"/>
      <url>/designPattern/pattern_singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序在运行时，通常都会生成很多实例。例如，表示字符串的 String 类的实例与字符串是一一对应的关系，所以当有 1000 个字符串的时候，会生成 1000 个实例。</p><p>但是，当我们想在程序中表示某个东西只会存在一个时，就会有“只能创建-一个实例”的需求。典型的例子有表示程序所运行于的那台计算机的类、表示软件系统相关设置的类，以及表示视窗系统（window system）的类。<br>当然，只要我们在编写程序时多加注意，确保只调用一次 new MyClass（），就可以达到只生成一个实例的目的。但是，如果我们不想“必须多加注意才能确保生成一个实例”，而是要达到如下目的时，应当怎么做呢？</p><ul><li>想确保任何情况下都绝对只有 1 个实例</li><li>想在程序上表现出“只存在一个实例”</li></ul><p>像这样的确保只生成-一个实例的模式被称作 Singleton 模式。Singleton 是指只含有一个元素的集合。因为本模式只能生成一个实例，因此以 Singleton 命名。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>众所周知,一个类的实例对象产生是通过构造函数来完成的. 因此如果不想让外界随意新建对象的话我们可以通过把构造函数私有化. 当然为了让类保证可用, 就需要自己提供一个可以返回自己的实例对象的通道, 一般我们使用静态方法来暴露实例对象.</p><p>实现单例模式的方式有很多种,不同的方式都有不同的优缺点,下面我们就来一一讲解:</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--饿汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的单例实现,一般称之为饿汉式.为何叫饿汉式,这个比喻很形象,可以看出上面的对象其实在类第一次被加载后就被创建了.这样有个好处就是避免了线程安全问题.但是这样另外一个问题,因为对象实在类被第一次加载后就被创建了,可能会造成不必要的消耗,因为有可能这个实力不会被用到.基于这个原因从而引出另一个实现方式: <code>懒汉式</code>,下面我们来看看:</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象被使用时才初始化</span></span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">             lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式就叫做懒汉式。懒汉，顾名思义就是不会提前把实例对象创建出来，而是将创建的动作放在了第一次使用的时候.</p><p>但是,仔细一看就会发现上面的实现方式存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时需要使用此对象,从而存在同时进入if语句中，最后在两个线程执行完方法后创建了两个不同的对象. 针对这个问题, 我们尝试做出如下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 私有构造</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> lazy;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过修改之后,我们发现可以通过加锁的方式来解决了线程同步的问题.</p><p>但是熟悉Java内存模式的同学会发现还是会存在潜在的危险.</p><blockquote><p>在J2SE1.5版本之前使用双重锁检查时会有潜在的危险,有时会正常工作,有时候会因为线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。此问题在J2SE 5.0中被处理了.我们可以通过volatile关键字来处理</p></blockquote><p>我们只需要在我们声明的对象上加上<code>volatile</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy lazy;</span><br></pre></td></tr></table></figure><p>好了,到此关于线程安全的问题我们解决了.</p><p>现在我们再来考虑一个问题, 做过java的同学,想必对反射和序列化不陌生.为什么在这里提这两个呢? 因为这两个可能会破坏我们的单例.(具体什么原因,后面我会有详细的文章介绍).针对这个问题我们可以做出如下修改就可以解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我们只需要在单例类里定义此方法就能解决</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">       return lazy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
