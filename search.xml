<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>（二）Kubernetes简介：核心资源对象&amp;核心组件</title>
      <link href="/kubernetes/k8s2/"/>
      <url>/kubernetes/k8s2/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 使用共享网络将多个物理机或虚拟机汇集到一个集群中，在各服务器之间进行通信，该集群是配置 Kubernetes 的所有组件、功能和工作负载的物理平台。 集群中一台服务器（或高可用部署中的一组服务器）用作 Master ，负责管理整个集群，余下的其他机器用作 Worker Node ，它们是使用本地和外部资源接收和运行工作负载的服务器。</p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>Master 是集群的网关和中枢，负责为用户和客户端暴露 API ，跟踪其他服务器的健 康状态、以最优方式调度工作负载，以及编排其他组件之间的通信等任务，它是用户或客户端与集群之间的核心联络点，并负责 Kubernetes 系统的大多数集中式管控逻辑。 单个 Master 节点即可完成其所有的功能，但出于冗余及负载均衡等目的，生产环境中通常需要协同部署多个此类主机。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是 Kubernetes 集群的工作节点，负责接收来自 Master 的工作指令并根据指令相应地创建或销毁 Pod 对象，以及调整网络规则以合理地路由和转发流量等。 理论上讲，Node 可以是任何形式的计算设备，不过 Master 会统一将其抽象为 Node 对象进行管理。</p><p>Kubernetes 将所有 Node 的资源集结于一处形成一台更加强大的“服务器”，在用户将应用部署于其上时，Master 会使用调度算法将其自动指派至某个特定的 Node 运行。在 Node 加入集群或从集群中移除时 Master 也会按需重新编排影响到的 Pod（容器）。于是，用户无须关心其应用究竟运行于何处。</p><p>从抽象的视角来讲， Kubernetes 还有着众多的组件来支撑其内部的业务逻辑，包括运行应用、应用编排、服务暴露、应用恢复等，它们在 Kubernetes 中被抽象为Pod、Label、Annotation、Ingress、Service、Controller等资源对象。</p><h2 id="资源对象"><a href="#资源对象" class="headerlink" title="资源对象"></a>资源对象</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Kubernetes 并不直接运行容器，而是使用一个抽象的资源对象来封装一个或者多个容器，这个抽象为 Pod ，它也是 Kubernetes 的最小调度单元。同一 Pod 中的容器共享网络名称空间和存储资源，这些容器可经由本地回环接口 lineout 直接通信，但彼此之间又在 Mount、User 及 PID 等名称空间上保持了隔离。尽管 Pod 中可以包含多个容器，但是作为最小调度单元，它应该尽可能地保持“小”，即通常只应该包含一个主容器。</p><h3 id="Label-资源标签"><a href="#Label-资源标签" class="headerlink" title="Label 资源标签"></a>Label 资源标签</h3><p>标签（ Label ）是将资源进行分类的标识符，资源标签其实就是一个键值型（ key/values) 数据。标签旨在指定对象（如 Pod 等）辨识性的属性，这些属性仅对用户存在特定的意义，对 Kubernetes 集群来说并不直接表达核心系统语义。标签可以在对象创建时附加其上，并能够在创建后的任意时间进行添加和修改。一个对象可以拥有多个标签，一个标签也可以附加于多个对象（通常是同一类对象）之上</p><h3 id="标签选择器（-Selector-）"><a href="#标签选择器（-Selector-）" class="headerlink" title="标签选择器（ Selector ）"></a>标签选择器（ Selector ）</h3><p>标签选择器（ Selector ）全称为 “ Label Selector” 它是一种根据 Label 来过滤符合条件的资源对象的机制。 例如，将附有标签“ role:backend ”的所有 Pod 对象挑选出来归为一组就是标签选择器的一种应用，用户通常使用标签对资源对象进行分类，而后使用标签选择器挑选出它们，直接批量给挑选出来的资源对象做相应的操作。</p><h3 id="Pod-控制器"><a href="#Pod-控制器" class="headerlink" title="Pod 控制器"></a>Pod 控制器</h3><p>尽管 Pod 是 Kubernetes 的最小调度单元，但用户通常并不会直接部署及管理 Pod 对象，而是要借助于另一类抽象——控制器（Controller）对其进行管理。 用于工作负载的控制器是一种管理 Pod 生命周期的资源抽象，它们是 Kubernetes 上的一类对象，而非单个资源对象，包 括 ReplicationController、ReplicaSet、 Deployment、StatefulSet、Job 等 。 以 Deployment 控制器为例，它负责确保指定的 Pod 对象的副本数量精确符合定义，否则“多退少补”。使用控制器之后就不再需要手动管理 Pod 对象了，用户只需要声明应用的期望状态，控制器就会自动对其进行进程管理。</p><h3 id="服务资源（-Service"><a href="#服务资源（-Service" class="headerlink" title="服务资源（ Service )"></a>服务资源（ Service )</h3><p>Service 是建立在一组 Pod 对象之上的资源抽象，它通过标签选择器选定一组 Pod 对象， 并为这组 Pod 对象定义一个统一的固定访问入口（通常是一个 IP 地址），若 Kubernetes 集群存在 DNS 附件，它就会在 Service 创建时为其自动配置一个 DNS 名称以便客户端进行服务发现。 到达 Service IP 的请求将被负载均衡至其后的端点——各个 Pod 对象之上，因此 Service 从本质上来讲是一个四层代理服务。 另外， Service 还可以将集群外部流量引入到集群中来 。</p><h3 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h3><p>存储卷（ Volume ）是独立于容器文件系统之外的存储空间，常用于扩展容器的存储空间并为它提供持久存储能力。Kubernetes 集群上的存储卷大体可分为临时卷 、本地卷和网络卷。临时卷和本地卷都位于 Node 本地，一旦 Pod 被调度至其他 Node，此种类型的存储卷将无法访问到，因此临时卷和本地卷通常用于数据缓存，持久化的数据则需要放置于持久卷 (persistent volume ）之上。</p><h3 id="Name-和-Namespace"><a href="#Name-和-Namespace" class="headerlink" title="Name 和 Namespace"></a>Name 和 Namespace</h3><p>名称（ Name ）是 Kubernetes 集群中资源对象的标识符，它们的作用域通常是名称空间( Namespace ）因此名称空间是名称的额外的限定机制。在同一个名称空间中，同一类型资源对象的名称必须具有唯一性。名称空间通常用于实现租户或项目的资源隔离，从而形成逻辑分组。创建资源对象未指定名称空间时 ，它们都属于默认的名称空间“ default ” 。</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>Annotation（注解）是另一种附加在对象之上的键值类型的数据，但它拥有更大的数据容量。Annotation常用于将各种非标识型元数据（ metadata ） 附加到对象上，但它不能用于标识和选择对象，通常也不会被 Kubernetes 直接使用，其主要目的是方便工具或用户的阅读及查找等</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>Kubernetes 将 Pod 对象和外部网络环境进行了隔离，Pod 和 Service 等对象间的通信都使用其内部专用地址进行，如若需要开放某些 Pod 对象提供给外部用户访问，则需要为其请求流量打开一个通往 Kubernetes 集群内部的通道，除了Service之外，Ingress 也是这类通道的实现方式之一。</p><h2 id="Kubernetes集群组件"><a href="#Kubernetes集群组件" class="headerlink" title="Kubernetes集群组件"></a>Kubernetes集群组件</h2><p>一个典型的 Kubernetes 集群由多个工作节点和一个或多个Master节点，以及一个集群状态存储系统（ etcd ）组成。其中 Master 节点负责整个集群的管理工作， 为集群提供管理接口，并监控和编排集群中的各个工作节点。各个工作节点负责以 Pod 的形式运行容器，因此，各节点需要事先配置好容器运行依赖的所有服务和资源，如容器运行时环境（比如Docker）。</p><p>Master 节点主要是由 apiserver、 controller-manager 和 scheduler 三个组件，以及一个用于集群状态存储的 etcd 存储服务组成，而每个 Node 节点则主要包含 kubelet、kube-proxy 及容器引擎（ Docker是最为常用的实现）等组件。此外，完整的集群服务还依赖于一些附加组件，如 KubeDNS、Dashboard、Heapster、Ingress Controller 等。</p><h3 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h3><p>API Server 负责输出 RESTful 风格的 Kubernetes API ，它是发往集群的所有 REST 操作命令的接入点，并负责接收、校验并响应所有的 REST 请求，结果状态被持久存储于 etcd 中。因此，API Server 是整个集群的网关。</p><h3 id="集群状态存储（etcd）"><a href="#集群状态存储（etcd）" class="headerlink" title="集群状态存储（etcd）"></a>集群状态存储（etcd）</h3><p>Kubernetes 集群的所有状态信息都需要持久存储于存储系统 etcd 中，不过， etcd 是由 CoreOS 基于 Raft 协议开发的分布式键值存储，可用于服务发现、共享配置以及一致性保障（如数据库主节点选择、分布式锁等）。因此，etcd 是独立的服务组件，并不隶属于 Kubernetes 集群自身。生产环境中应该以 etcd 集群的方式运行以确保其服务可用性。</p><p>etcd 不仅能够提供键值数据存储， 而且还为其提供了监昕（ watch ）机制，用于监听和推送变更。 Kubernetes 集群系统中，etcd 中的键值发生变化时会通知到 API Server ，并由其通过 watchAPI 向客户端输出。基于 watch 机制， Kubernetes 集群的各组件实现了高效协同 。</p><h3 id="控制器管理器（-Controller-Manager"><a href="#控制器管理器（-Controller-Manager" class="headerlink" title="控制器管理器（ Controller Manager )"></a>控制器管理器（ Controller Manager )</h3><p>Kubernetes 中，集群级别的大多数功能都是由几个被称为控制器的进程执行实现的，这几个进程被集成于 kube-controller-manager 守护进程中。由控制器完成的功能主要包括生命周期功能和 API 业务逻辑，具体如下。</p><ul><li>生命周期功能：包括 Namespace 创建和生命周期、 Event 垃圾回收、 Pod 终止相关的垃圾回收、级联垃圾回收及 Node 垃圾回收等 。</li><li>API业务逻辑：例如，由 ReplicaSet 执行的 Pod 扩展等 。</li></ul><h3 id="调度器（-Scheduler"><a href="#调度器（-Scheduler" class="headerlink" title="调度器（ Scheduler )"></a>调度器（ Scheduler )</h3><p>Kubernetes 是用于部署和管理大规模容器应用的平台，根据集群规模的不同，其托管运行的容器很可能会数以千计甚至更多。 API Server 确认 Pod 对象的创建请求之后， 便需要由 Scheduler 根据集群内各节点的可用资源状态，以及要运行的容器的资源需求做出调度决策。另外，Kubernetes 还支持用户自定义调度器</p><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>kubelet 是运行于工作节点之上的守护进程，它从 API Server 接收关于 Pod 对象的配置信息并确保它们处于期望的状态。 kubelet 会在 API Server 上注册当前工作节点， 定期向 Master 汇报节点资源使用情况，并通过 cAdvisor 监控容器和节点的资源占用状况 。</p><h3 id="容器运行时环境"><a href="#容器运行时环境" class="headerlink" title="容器运行时环境"></a>容器运行时环境</h3><p>每个 Node 都要提供一个容器运行时（ Container Runtime ）环境， 它负责下载镜像并运行容器。 kubelet 并未固定链接至某容器运行时环境，而是以插件的方式载入配置的容器环境。这种方式清晰地定义了各组件的边界。目前，Kubernetes 支持的容器运行环境至少包括Docker、RKT、cri-o 和 Fraki等。</p><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>每个工作节点都需要运行一个 kube-proxy 守护进程，它能够按需为 Service 资源对象生成 iptables 或 ipvs 规则，从而捕获访问当前 Service 的ClusterIP 的流量并将其转发至正确的后端 Pod 对象。</p><h3 id="KubeDNS"><a href="#KubeDNS" class="headerlink" title="KubeDNS"></a>KubeDNS</h3><p>KubeDNS 是在 Kubernetes 集群中调度运行提供 DNS 服务的 Pod，同一集群中的其他 Pod 可使用此 DNS 服务解决主机名。 Kubernetes 自 1.11 版本开始默认使用 CoreDNS 项目为集群提供服务注册和服务发现的动态名称解析服务，之前的版本中用到的是 kube-dns 项目，而 SkyDNS 则是更早一代的项目。</p><h3 id="Kubernetes-Dashboard"><a href="#Kubernetes-Dashboard" class="headerlink" title="Kubernetes Dashboard"></a>Kubernetes Dashboard</h3><p>Kubernetes 集群的全部功能都要基于 Web 的 UI，来管理集群中的应用甚至是集群自身。</p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><p>容器和节点的性能监控与分析系统，它收集并解析多种指标数据，如资源利用率、生命周期事件等。新版本的 Kubernetes 中，其功能会逐渐由 Prometheus 结合其他组件所取代。</p><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>Service 是一种工作于传统层的负载均衡器，而 Ingress 是在应用层实现的 HTTP (s）负载均衡机制。不过，Ingress 资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则需要通过 Ingress 控制器（ Ingress Controller) 发挥作用 。 目前，此类的可用项目有 Nginx、Traefik、Envoy 及 HAProxy 等。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）Kubernetes 之 pod</title>
      <link href="/kubernetes/k8s3/"/>
      <url>/kubernetes/k8s3/</url>
      
        <content type="html"><![CDATA[<p>pod 是一组并置的容器，代表了 Kubernetes 中的基本构建模块。在实际应用中我们并不会单独部署容器，更多的是针对一组 pod 的容器进行部署和操作。然而这并不意味着一个 pod 总是要包含多个容器，实际上只包含一个单独容器的 pod 也是非常常见的。值得注意的是，当一个 pod 包含多个容器时，这些容器总是运行于同一个工作节点上，一个 pod 绝不会跨越多个工作节点。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670631091472.jpg" alt="-w688"></p><p>在包含容器的 pod 下，我们可以同时运行一些密切相关的进程，并为它们提供几乎相同的环境，此时这些进程就好像全部运行于单个容器中一样，同时又保持着一定的隔离。这样一来，我们便能全面地利用容器所提供的特性，同时对这些进程来说它们就像运行在一起一样，实现两全其美 。</p><p>容器之间彼此是完全隔离的，但此时我们期望的是隔离容器组，而不是单个容器，并让每个容器组内的容器共享一些资源，而不是完全隔离。Kubernetes 通过配置 Docker 来让一个 pod 内的所有容器共享相同的 Linux 命名空间，而不是每个容器都有自己的一组命名空间。</p><p>由于一个 pod 中的所有容器都在相同的 network 和 UTS 命名空间下运行，所以它们都共享相同的主机名和网络接口。同样这些容器也都在相同的 IPC 命名空间下运行，因此能够通过 IPC 进行通信。在最新的 Kubernetes 和 Docker 版本中，它们也能够共享相同的 PID 命名空间，但是该特征默认是未激活的。</p><blockquote><p>当同一个 pod 中的容器使用单独的 PID 命名空间时，在容器中执行 ps aux 就只会看到容器自己的进程。</p></blockquote><p>但是当涉及文件系统时，情况就有所不同。由于大多数容器的文件系统来自容器镜像，因此默认情况下，每个容器的文件系统与其他容器完全隔离。但我们可 以使用 Volume 的 Kubernetes 资源来共享文件目录。</p><p>由于一个 pod 中的容器运行于相同的 Network 命名空间中，因此它们共享相同的 IP 地址和端口空间。这意味着在同－ pod 中的容器运行的多个进程需要注意不能绑定到相同的端口号，否则会导致端口冲突，但这只涉及同一 pod 中的容器。 由于每个 pod 都有独立的端口空间，对于不同 pod 中的容器来说永远不会遇到端口冲突。此外，一个 pod 中的所有容器也都具有相同的网络接口，因此容器可以通过 localhost 与同一 pod 中的其他容器进行通信。</p><p>Kubernetes 集群中的所有 pod 都在同一个共享网络地址空间中，这意味着每个 pod 都可以通过其他 pod 的 IP 地址来实现相互访问。它们之间没有 NAT（网络地址转换）网关。当两个 pod 彼此之间发送网络数据包时，它们都会将对方的实际 IP 地址看作数据包中的源 IP。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15670648371662.jpg" alt="-w616"></p><h2 id="在-Kubernetes-中运行一个简单的-pod"><a href="#在-Kubernetes-中运行一个简单的-pod" class="headerlink" title="在 Kubernetes 中运行一个简单的 pod"></a>在 Kubernetes 中运行一个简单的 pod</h2><p>我们可以通过 kubectl run 命令， 该命令可以创建所有资源组件而无需 JSON 或 YAML 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl run yx-nginx --image=nginx  --port=80 --generator=run/v1</span></span><br></pre></td></tr></table></figure><ul><li>–image=nginx 指定运行的镜像</li><li>–port=80 告诉kubernetes应用正在监听80端口</li><li>–generator 一般来说不会使用它，这里使用是为了让kubernetes创建一个 ReplicationController而不是Deployment</li></ul><h3 id="列出-pod"><a href="#列出-pod" class="headerlink" title="列出 pod"></a>列出 pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   0/1     Pending   0          9m28s</span><br></pre></td></tr></table></figure><p>可以看到 pod 处于挂起状态，READY 列显示 0/1 代表 pod 的容器还未就绪。pod 还没有运行的 原因是：该 pod 被分配到的工作节点正在下载容器镜像，完成之后才可以运行。下载完成后，将创建 pod 的容器， 然后 pod 会变为运行状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">yx-nginx-2r4xf   1/1     Running   0          9m28s</span><br></pre></td></tr></table></figure><p>再次列出 pod，可以发现 pod的状态已经发生改变了。</p><h3 id="查看pod详细信息"><a href="#查看pod详细信息" class="headerlink" title="查看pod详细信息"></a>查看pod详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod yx-nginx-2r4xf</span><br></pre></td></tr></table></figure><h2 id="使用描述文件创建-pod"><a href="#使用描述文件创建-pod" class="headerlink" title="使用描述文件创建 pod"></a>使用描述文件创建 pod</h2><p>YAML 格式的 Pod 定义文件的完整内容:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment">## 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">## 元数据 </span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>  <span class="comment">## Pod 名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span> <span class="comment">## Pod 所属的命名空间 默认值为 default</span></span><br><span class="line"><span class="attr">  labels:</span> <span class="comment">## 自定义标签列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  annotations:</span> <span class="comment">## 自定义注解列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">##pod 中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span> <span class="comment">## 容器列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span> <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">string</span> <span class="comment">## 容器镜像名称</span></span><br><span class="line">    <span class="comment">## 镜像拉取策略: </span></span><br><span class="line">    <span class="comment">## Always(默认值): 表示每次都尝试重新拉取镜像。</span></span><br><span class="line">    <span class="comment">## IfNotPresent: 表示 如果本地有该镜像，则使用本地的镜像，本地不存在时拉取镜像。</span></span><br><span class="line">    <span class="comment">## Never: 表示仅使用本地镜像。</span></span><br><span class="line">    <span class="comment">## 下面几种情况系统将默认设置 imagePullPolicy=Always。</span></span><br><span class="line">    <span class="comment">## 1. 不设置 imagePullPolicy，也未指定镜像的 tag</span></span><br><span class="line">    <span class="comment">## 2. 不设置 imagePullPolicy，镜像 tag 为 latest</span></span><br><span class="line">    <span class="comment">## 3. 启用名为 AlwaysPullImages 的准入控制器（Admission Controller）</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never |IfNotPresent]</span></span><br><span class="line"><span class="string">command: [string] ## 容器的启动命令列表，如果不指定，则使用镜像打包时使用的启动命令。</span></span><br><span class="line"><span class="string">args: [string]  ## 容器的启动命令参数列表</span></span><br><span class="line"><span class="string">workingDir: string ## 容器的工作目录</span></span><br><span class="line"><span class="string">volumeMounts: ## 挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="string">- name: string ## 引用 pod 定义的共享存储卷的名称，需使用 volumes[]部分定义的共享存储卷名称</span></span><br><span class="line"><span class="string">  mountPath: string ## 存储卷在容器内 Mount 的绝对路径，应少于 512 个字符</span></span><br><span class="line"><span class="string">  readOnly: boolean ## 是否为只读模式，默认为读写模式</span></span><br><span class="line"><span class="string">ports: ## 容器需要暴露的端口号列表</span></span><br><span class="line"><span class="string">- name: string ## 端口的名称</span></span><br><span class="line"><span class="string">  containerPort: int ## 容器需要监听的端口号</span></span><br><span class="line"><span class="string">  hostPort: int ## 容器所在主机需要监听的端口号，默认与 containerPort 相同。设置 hostPort 时，同一台宿主机将无法启动该容器的第 2 份副本</span></span><br><span class="line"><span class="string">  protocol: string ## 端口协议，支持 TCP 和 UDP, 默认值为 TCP</span></span><br><span class="line"><span class="string">env:  ## 容器运行前需设置的环境变量列表</span></span><br><span class="line"><span class="string">- name: string ## 环境变量的名称</span></span><br><span class="line"><span class="string">  value: string ## 环境变量的值</span></span><br><span class="line"><span class="string">resources: ## 资源限制和资源请求的设置</span></span><br><span class="line"><span class="string">   limits: </span></span><br><span class="line"><span class="string">     cpu: string ## CPU 限制，单位为 core 数，将用于 docker run --cpu-shares 参数</span></span><br><span class="line"><span class="string">memory: string ## 内存限制，单位可以为 MiB、GiB等，将用于 docker run --memory 参数</span></span><br><span class="line"><span class="string">  requests :</span></span><br><span class="line"><span class="string">cpu: string ## CPU 请求，单位为 core 数，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">memory: string ## 内存请求，单位可以为 MiB、GiB等，容器启动的初始可用数量</span></span><br><span class="line"><span class="string">livenessProbe :</span></span><br><span class="line"><span class="string">  exec:</span></span><br><span class="line"><span class="string">command: [string]</span></span><br><span class="line"><span class="string">  httpGet:</span></span><br><span class="line"><span class="string">path: string</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string">host: string</span></span><br><span class="line"><span class="string">scheme: string </span></span><br><span class="line"><span class="string">httpHeaders:</span></span><br><span class="line"><span class="string">- name: string</span></span><br><span class="line"><span class="string">  value: string</span></span><br><span class="line"><span class="string">  tcpSocket:</span></span><br><span class="line"><span class="string">port: number</span></span><br><span class="line"><span class="string"></span><span class="attr">      initialDelaySeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      successThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]</span></span><br><span class="line"><span class="string"></span><span class="attr">  nodeSelector:</span> <span class="string">object</span></span><br><span class="line"><span class="attr">  imagePullSecrets:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  hostNetwork:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  volumes:</span> <span class="comment">## 在该 Pod 上定义的共享存储卷列表</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">emptyDir:</span> <span class="string">&#123;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="attr">hostPath:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">secret:</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">configMap:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure></p><h3 id="pod定义的主要几个部分"><a href="#pod定义的主要几个部分" class="headerlink" title="pod定义的主要几个部分"></a>pod定义的主要几个部分</h3><p>pod定义由这么几个部分组成：首先是YAML中使用的 kubernetes API 版本和 YAML 描述的资源类型，其次就是几乎在所有 kubernetes 资源中都可以找到的三大重要部分：</p><ul><li>metadata：包括名称，命名空间，标签和关于该容器的其他信息。</li><li>spec：包含 pod 内容的实际说明，例如 pod 的容器，卷和其他数据。</li><li>status：包含运行中的 pod 的当前信息，例如 pod 所处的条件，每个容器的描述和状态，以及内部IP和其他基本信息。</li></ul><h3 id="编写一个简单的-YAML-描述文件创建-pod"><a href="#编写一个简单的-YAML-描述文件创建-pod" class="headerlink" title="编写一个简单的 YAML 描述文件创建 pod"></a>编写一个简单的 YAML 描述文件创建 pod</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx</span> <span class="comment">##pod名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span> <span class="comment">## pod里运行那些容器</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span>  <span class="comment">## 镜像名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span>    <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">80</span> <span class="comment">## 容器运行监听的端口</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 kubectl explain 查找资源对象的属性<br>kubectl explain pod<br>kubectl explain pod.spec</p></blockquote><h4 id="使用-kubectl-create-来创建-pod"><a href="#使用-kubectl-create-来创建-pod" class="headerlink" title="使用 kubectl create 来创建 pod"></a>使用 kubectl create 来创建 pod</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f test-nginx.yaml</span><br><span class="line">``` </span><br><span class="line">&gt; kubectl create -f 命令用于从YAML或JOSN文件创建任何资源，不只是pod。</span><br><span class="line"></span><br><span class="line">#### 获取运行中 pod 的完整定义</span><br><span class="line">```shell</span><br><span class="line">kubectl get po test-nginx -o yaml</span><br><span class="line">kubectl get po test-nginx -o json</span><br></pre></td></tr></table></figure><h4 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h4><p>使用 kubectl logs 命令获取 pod 日志<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx</span><br></pre></td></tr></table></figure></p><p>获取多容器 pod 的日志时指定容器名称<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs test-nginx -c test</span><br></pre></td></tr></table></figure></p><blockquote><p>kubectl logs 命令将显示当前容器的日志。 当你想知道为什么前一个容器终止时，你想看到的是前一个容器的日志，而不是当前容器的。可以通过添加 –previous 选项来完成：<br>kubectl logs test-nginx –previous</p></blockquote><h3 id="停止和移除-pod"><a href="#停止和移除-pod" class="headerlink" title="停止和移除 pod"></a>停止和移除 pod</h3><ul><li>按名称删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods test-nginx</span><br></pre></td></tr></table></figure><ul><li>使用标签选择器删除 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods -l env=debug</span><br></pre></td></tr></table></figure><ul><li>删除指定命名空间下的所有 pod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete pods --all -n test-namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）Kubernetes简介：Kubernetes架构</title>
      <link href="/kubernetes/k8s1/"/>
      <url>/kubernetes/k8s1/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的workflows 和更高级的自动化任务。<br>Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。<br>Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p><h2 id="Borg简介"><a href="#Borg简介" class="headerlink" title="Borg简介"></a>Borg简介</h2><p>Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。</p><p>Borg主要由BorgMaster、Borglet、borgcfg和Scheduler组成，如下图所示</p><p>  <img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662939314245.jpg" alt="-w572"><br>  <img src="https://upload-images.jianshu.io/upload_images/1455014-5262ffd168735d45.jpg" alt="-w572"></p><ul><li>BorgMaster 是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中；</li><li>Scheduer 负责任务的调度，根据应用的特点将其调度到具体的机器上去；</li><li>Borglet 负责真正运行任务（在容器中）；</li><li>borgcfg 是 Borg 的命令行工具，用于跟 Borg 系统交互，一般通过一个配置文件来提交任务。</li></ul><h2 id="Kubernetes-特性"><a href="#Kubernetes-特性" class="headerlink" title="Kubernetes 特性"></a>Kubernetes 特性</h2><p>Kubernetes 是一种用于在一组主机上运行和协同容器化应用程序的系统，旨在提供可预测性、可扩展性与高可用性的方法来完全管理容器化应用程序和服务的生命周期的平台。用户可以定义应用程序的运行方式，以及与其他应用程序或外部世界交互的途径，并能实现服务的扩容和缩容，执行平滑滚动更新，以及在不同版本的应用程序之间调度流量以测试功能或回滚有问题的部署。 Kubernetes 提供了接口和可组合的平台原语，使得用户能够以高度的灵活性和可靠性定义及管理应用程序。简单总结起来，它具有以下几个重要特性 。</p><h3 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1. 自动装箱"></a>1. 自动装箱</h3><p>建构于容器之上，基于资源依赖及其他约束自动完成容器部署且不影响其可用性，并 通过调度机制混合关键型应用和非关键型应用的工作负载于同一节点以提升资源利用率。</p><h3 id="2-自我修复（自愈）"><a href="#2-自我修复（自愈）" class="headerlink" title="2. 自我修复（自愈）"></a>2. 自我修复（自愈）</h3><p>支持容器故障后自动重启、节点故障后重新调度容器，以及其他可用节点、健康状态 检查失败后关闭容器并重新创建等自我修复机制。</p><h3 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3. 水平扩展"></a>3. 水平扩展</h3><p>支持通过简单命令或 UI 手动水平扩展，以及基于 CPU 等资源负载率的自动水平扩展机制 。</p><h3 id="4-服务发现和负载均衡"><a href="#4-服务发现和负载均衡" class="headerlink" title="4. 服务发现和负载均衡"></a>4. 服务发现和负载均衡</h3><p>Kubernetes 通过其附加组件之一的 KubeDNS （或 CoreDNS ）为系统内置了服务发现功能，它会为每个 Service 配置 DNS 名称，并允许集群内的客户端直接使用此名称发出访问请求，而 Service 则通过 iptables 或 ipvs 内建了负载均衡机制 。</p><h3 id="5-自动发布和回滚"><a href="#5-自动发布和回滚" class="headerlink" title="5. 自动发布和回滚"></a>5. 自动发布和回滚</h3><p>Kubernetes 支持“灰度”更新应用程序或其配置信息，它会监控更新过程中应用程序的健康状态，以确保它不会在同一时刻杀掉所有实例，而此过程中一旦有故障发生，就会立即自动执行回滚操作 。</p><h3 id="6-密钥和配置管理"><a href="#6-密钥和配置管理" class="headerlink" title="6. 密钥和配置管理"></a>6. 密钥和配置管理</h3><p>Kubernetes 的 ConfigMap 实现了配置数据与 Docker 镜像解稠，需要时，仅对配置做出变更而无须重新构建 Docker 镜像，这为应用开发部署带来了很大的灵活性。此外，对于应用所依赖的一些敏感数据，如用户名和密码、令牌、密钥等信息， Kubernetes 专门提供了 Secret 对象为其解耦，既便利了应用的快速开发和交付，又提供了一定程度上的安全保障。</p><h3 id="7-存储编排"><a href="#7-存储编排" class="headerlink" title="7. 存储编排"></a>7. 存储编排</h3><p>Kubernetes 支持 Pod 对象按需自动挂载不同类型的存储系统 ，这包括节点本地存储、公有云服务商的云存储（如 AWS 和 GCP 等），以及网络存储系统（例如， NFS、iSCSI、GlusterFS、Ceph、Cinder 和 Flocker 等）。</p><h3 id="8-批量处理执行"><a href="#8-批量处理执行" class="headerlink" title="8. 批量处理执行"></a>8. 批量处理执行</h3><p>除了服务型应用，Kubernetes 还支持批处理作业及 CI（持续集成），如果需要， 一样可以实现容器故障后恢复。</p><h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><p>Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Labels 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像，如下图所示</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15662946967695.jpg" alt=""></p><p>Kubernetes 主要由以下几个核心组件组成：</p><ul><li>etcd 保存了整个集群的状态；</li><li>kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li><li>kube-controller-manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>kube-scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li><li>kubelet 负责维持容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），默认的容器运行时为 Docker；</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的 Add-ons：</p><ul><li>CoreDNS 负责为整个集群提供 DNS 服务</li><li>Ingress Controller 为服务提供外网入口</li><li>Heapster 提供资源监控</li><li>Dashboard 提供 GUI</li><li>Federation 提供跨可用区的集群</li><li>Fluentd-elasticsearch 提供集群日志采集、存储与查询</li></ul><h2 id="Kubernetes架构示意图"><a href="#Kubernetes架构示意图" class="headerlink" title="Kubernetes架构示意图"></a>Kubernetes架构示意图</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>下图清晰表明了Kubernetes的架构设计以及组件之间的通信协议。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663927970976.jpg" alt="Kuberentes架构（图片来自于网络）"></p><p>下面是更抽象的一个视图：</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928276452.jpg" alt="kubernetes整体架构示意图"></p><h3 id="Master架构"><a href="#Master架构" class="headerlink" title="Master架构"></a>Master架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928485300.jpg" alt="Kubernetes master架构示意图"></p><h3 id="Node架构"><a href="#Node架构" class="headerlink" title="Node架构"></a>Node架构</h3><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928706968.jpg" alt="kubernetes node架构示意图"></p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示。</p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15663928960235.jpg" alt="Kubernetes分层架构示意图"></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li><li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</li><li>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</li><li>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（四）Kubernetes之标签-注解-命名空间</title>
      <link href="/kubernetes/k8s4/"/>
      <url>/kubernetes/k8s4/</url>
      
        <content type="html"><![CDATA[<h1 id="Label-标签"><a href="#Label-标签" class="headerlink" title="Label 标签"></a>Label 标签</h1><p>标签是一种简单却功能强大的 kubernetes 特性，不仅可以组织 pod，也可以组织所有其他的 kubernetes 资源。详细来讲 ，标签是可以附加到资源的任意键值对，用以选择具有该确切标签的资源（这是通过标签选择器完成的）。只要标签的 key 在资源内是唯一的，一个资源便可以拥有多个标签。通常在我们创建资源时就会将标签附加到资源上，但之后我们也可以再添加其他标签，或者修改现有标签的值，而无须重新创建资源。</p><h2 id="创建-pod-时指定标签"><a href="#创建-pod-时指定标签" class="headerlink" title="创建 pod 时指定标签"></a>创建 pod 时指定标签</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx-label</span></span><br><span class="line">    <span class="comment">## 添加标签</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">        auth:</span> <span class="string">yuxuan</span></span><br><span class="line"><span class="attr">        env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 创建 pod</span><br><span class="line">kubectl create -f test-nginx-labels.ymal</span><br><span class="line">## 列出pod 并列出label</span><br><span class="line">kubectl get pods --show-labels</span><br><span class="line">## 只列出感兴趣的标签 可以使用 -L 指定并显示在单独的列中</span><br><span class="line">kubectl get pods -L auth</span><br></pre></td></tr></table></figure><h2 id="修改现有-pod-的标签"><a href="#修改现有-pod-的标签" class="headerlink" title="修改现有 pod 的标签"></a>修改现有 pod 的标签</h2><p>标签也可以在现有的 pod 上进行添加和修改。现在来给前面创建的 test-nginx pod来添加标签吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 添加标签</span><br><span class="line">kubectl label pods test-nginx env=test</span><br><span class="line">## 修改现有的标签 需要使用--overwrite</span><br><span class="line">kubectl label pods test-nginx env=debug --overwrite</span><br></pre></td></tr></table></figure></p><h2 id="通过标签选择器列出-pod-子集"><a href="#通过标签选择器列出-pod-子集" class="headerlink" title="通过标签选择器列出 pod 子集"></a>通过标签选择器列出 pod 子集</h2><p>标签要与标签选择器结合在一起。标签选择器允许我们选择标记有特定标签的 pod 子集，并对这些 pod 执行操作。可以说标签选择器是一种能够根据是否包含具有特定值的特定标签来过滤资源的准则。标签选择器根据资源的以下条件来选择资源：</p><ul><li>包含（或不包含〉使用特定键的标签 </li><li>包含具有特定键和值的标签 </li><li>包含具有特定键的标签，但其值与我们指定的不同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 列出指定标签的 pod </span><br><span class="line">kubectl get pods --show-labels -l env</span><br><span class="line">## 列出指定标签,指定标签值的 pod </span><br><span class="line">kubectl get pods --show-labels -l env=prod</span><br><span class="line">## 列出没有指定标签的 pod</span><br><span class="line">kubectl get pods --show-labels -l &apos;!env&apos;</span><br><span class="line">## 列出标签值不等于某个值的 pod</span><br><span class="line">get pods --show-labels -l &apos;env!=prod&apos;</span><br><span class="line">## in</span><br><span class="line">get pods --show-labels -l &apos;env in (prod,debug)&apos;</span><br><span class="line">## notin</span><br><span class="line">get pods --show-labels -l &apos;env notin (prod,debug)&apos;</span><br><span class="line">## 多个条件用逗号分隔</span><br><span class="line">get pods --show-labels -l &apos;env in (prod,debug),auth=yuxuan&apos;</span><br></pre></td></tr></table></figure><h2 id="使用标签和选择器来约束-pod-调度"><a href="#使用标签和选择器来约束-pod-调度" class="headerlink" title="使用标签和选择器来约束 pod 调度"></a>使用标签和选择器来约束 pod 调度</h2><p>pod 并不是唯一可以附加标签的 Kubernetes 资源。标签可以附加到任何 Kubernetes 对象上，包括节点。我们可以通过标签来控制 pod 调度到特定的节点。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 列出集群node</span></span></span><br><span class="line">kc get nodes --show-labels</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 给指点节点打上标签</span></span></span><br><span class="line">kc label node 192.168.1.230 env=test</span><br></pre></td></tr></table></figure></p><p>在yaml里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: pod</span><br><span class="line">metadata:</span><br><span class="line">    name: test-nginx-label</span><br><span class="line">    ## 添加标签</span><br><span class="line">    labels:</span><br><span class="line">        auth: yuxuan</span><br><span class="line">        env: prod</span><br><span class="line">spec:</span><br><span class="line">    ## 控制该pod 只调度在标签 env=test的节点上</span><br><span class="line">    nodeSelector:</span><br><span class="line">        env: &quot;test&quot;</span><br><span class="line">    containers:</span><br><span class="line">    - image: nginx</span><br><span class="line">      name: test</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br><span class="line">        protocol: TCP</span><br></pre></td></tr></table></figure></p><h1 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations 注解"></a>Annotations 注解</h1><p>除标签外，pod 和其他对象还可以包含注解。注解也是键值对，所以它们本质上与标签非常相似。但与标签不同，注解并不是为了保存标识信息而存在的，它们不能像标签一样用于对对象进行分组。当我们可以通过标签选择器选择对象时，就不存在注解选择器这样的东西。</p><p>另一方面，注解可以容纳更多的信息，并且主要用于工具使用。Kubernetes 也会将一些注解自动添加到对象，但其他的注解则需要由用户手动添加。</p><p>向 kubernetes 引入新特性时，通常也会使用注解。一般来说，新功能的 alpha 和 beta 版本不会向 API 对象引入任何新字段，因此使用的是注解而不是字段，一旦所需的 API 更改变得清晰并得到所有相关人员的认可，就会引入新的字段并废弃相关注解。</p><h2 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h2><p>和标签一样，注解可以在创建时就添加到 pod 中，也可以在之后再对现有的 pod 进行添加或修改。其中将注解添加到现有对象的最简单的方法是通过 kubectl annotate 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 添加注解</span></span></span><br><span class="line">kc annotate pod test-nginx test.annotations="test"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改注解</span></span></span><br><span class="line">kc annotate pod test-nginx test.annotations="pro" --overwrite</span><br></pre></td></tr></table></figure></p><h1 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a>namespace 命名空间</h1><p>我们已经看到标签是如何将 pod 和其他对象组织成组的。由于每个对象都可以有多个标签，因 此这些对象组可以重叠。另外，当在集群中工作（例如通过 kubectl ）时，如果没有明确指定标签选择器，我们总能看到所有对象 。</p><p>但是，当你想将对象分割成完全独立且不重叠的组时，又该如何呢？可能你每次只想在一个小组内进行操作，因此 kubernetes 也能将对象分组到命名空间中。Kubernetes 命名空间简单地为对象名称提供了一个作用域。此时我们并不会将所有资源都放在同一个命名空间中，而是将它们组织到多个命名空间中，这样可以允许我们多次使用相同的资源名称（跨不同的命名空间〉。</p><h2 id="列出命名空间及其-pod"><a href="#列出命名空间及其-pod" class="headerlink" title="列出命名空间及其 pod"></a>列出命名空间及其 pod</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#列出集群中的所有命名空间</span></span></span><br><span class="line">kc get ns</span><br></pre></td></tr></table></figure><p>当使用 kubectl get 命令列出资源时，我们从未明确指定命名空间，因此 kubectl 总是默认为 default 命名空间，只显示该命名空间下的对象。但从列表中我们可以看到还存在 kube -public 和 kube-system 命名空间。接下来可以使用 kubectl 命令指定命名空间来列出只属于该命名空间的 pod<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc get pods --namespace kube-system</span><br></pre></td></tr></table></figure></p><blockquote><p>可以使用 -n 代替 –namespace</p></blockquote><h2 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h2><ul><li>通过yaml文件创建</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-namespace</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc create -f test-namespace.yaml</span><br></pre></td></tr></table></figure><ul><li>通过命令创建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace test-namespace</span><br></pre></td></tr></table></figure><blockquote><p>尽管大多数对象的名称必须符合 RFC 1035 （域名）中规定的命名规范，这意味着它们可能只包含字母、数字、横杠（－）和点号， 但命名空间不允许包含点号。</p></blockquote><h2 id="删除命名空间"><a href="#删除命名空间" class="headerlink" title="删除命名空间"></a>删除命名空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete ns test-namespace</span><br></pre></td></tr></table></figure><h2 id="删除命名空间中（几乎）所有的资源"><a href="#删除命名空间中（几乎）所有的资源" class="headerlink" title="删除命名空间中（几乎）所有的资源"></a>删除命名空间中（几乎）所有的资源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete all --all -n test-namespace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（六）Kubernetes 之 控制器</title>
      <link href="/kubernetes/k8s6/"/>
      <url>/kubernetes/k8s6/</url>
      
        <content type="html"><![CDATA[<h2 id="ReplicationController-控制器"><a href="#ReplicationController-控制器" class="headerlink" title="ReplicationController 控制器"></a>ReplicationController 控制器</h2><p>ReplicationController 是一种 Kubernetes 资源，可确保它的 pod 始终保持运行状态。如果 pod 因任何原因消失（例如节点从集群中消失或由于该 pod 己从节点中逐出），则 ReplicationController 会注意到缺少了 pod 并创建替代 pod。</p><p>ReplicationController 的工作是确保 pod 的数量始终与其标签选择器匹配。如果不匹配，则 ReplicationController 将根据所需 ， 采取适当的操作来协调 pod 的数量。 </p><p><img src="https://gitee.com/yuxuancode/picgo_image/raw/master/images/15813380153549.jpg" alt="-w713"></p><h3 id="ReplicationController-的组成部分"><a href="#ReplicationController-的组成部分" class="headerlink" title="ReplicationController 的组成部分"></a>ReplicationController 的组成部分</h3><p>一个 ReplicationController 有三个主要部分：</p><ul><li>label selector:标签选择器，用于确定 ReplicationController 作用域中有哪些 pod</li><li>replica count: 副本个数，指定应运行的 pod 数量</li><li>pod template：pod模板，用于创建新的 pod 副本</li></ul><p>ReplicationController 的副本个数、标签选择器，甚至是 pod 模板都可以随时修改，但只有副本数目的变更会影响现有的 pod。</p><p>更改标签选择器和 pod 模板对现有 pod 没有影响。更改标签选择器会使现有的 pod 脱离ReplicationController 的范围，因此控制器会停止关注它们。在创建 pod 后， ReplicationController 也不关心其 pod 的实际“内容”（容器镜像、环境变量及其他）。 因此，该模板仅影响由此 ReplicationController 创建的新 pod。</p><h3 id="使用ReplicationController-的好处"><a href="#使用ReplicationController-的好处" class="headerlink" title="使用ReplicationController 的好处"></a>使用ReplicationController 的好处</h3><p>像 Kubernetes 中的许多事物一样， ReplicationController 尽管是一个令人难以置信的简单概念，却提供或启用了以下强大功能：</p><ul><li>确保一个或多个pod持续运行，方法是在现有 pod 丢失时启动一个新的 pod。</li><li>集群节点发生故障时，它将为故障节点上运行的所有 pod（受ReplicationController 控制的节点上的pod） 创建替代副本。</li><li>它能轻松实现 pod 的水平伸缩。</li></ul><blockquote><p>pod 实例永远不会重新安置到另一个节点。 相反，ReplicationController 会创建一个全新的 pod 实例，它与正在替换的实例无关。</p></blockquote><h3 id="创建一个-ReplactionController"><a href="#创建一个-ReplactionController" class="headerlink" title="创建一个 ReplactionController"></a>创建一个 ReplactionController</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rc-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment">## 标签选择器，决定rc控制器的操作对象</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rc-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc create -f test-nginx-replication-controller.yaml --validate=false</span><br></pre></td></tr></table></figure><p>Kubernetes 会创建一个名为 rc-test 的新 ReplicationController， 它确保符合标签选择器 app=nginx 的 pod 实例始终是三个。 当没有足够的 pod 时，根据提供的 pod 模板创建新的 pod 。</p><p>模板中的 pod 标签显然必须和 ReplicationController 的标签选择器匹配， 否则控制器将无休止地创建新的容器。因为启动新 pod 不会使实际的副本数量接近期望的副本数量。为了防止出现这种情况，API 服务会校验 ReplicationController 的定义，不会接收错误配置。</p><p>不指定选择器也是一种选择。在这种情况下，它会自动根据 pod 模板中的标签自动配置。</p><blockquote><p>定义 ReplicationController 时不要指定 pod 选择器，让 kubernetes 从 pod 模板中提取它。这样 YAML 更简短。</p></blockquote><h3 id="使用-ReplicationController"><a href="#使用-ReplicationController" class="headerlink" title="使用 ReplicationController"></a>使用 ReplicationController</h3><p>由于没有任何 pod 有 app=nginx 标签，ReplicationController 会根据 pod 模板启动三个新的 pod。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># kc get pods --show-labels</span></span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">rc-test-5g8cz      1/1     Running   0          23m   app=nginx</span><br><span class="line">rc-test-dcsdb      1/1     Running   0          23m   app=nginx</span><br><span class="line">rc-test-fmh2q      1/1     Running   0          23m   app=nginx</span><br></pre></td></tr></table></figure></p><p>删除其中一个 pod 看会发生什么<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># kc delete pods rc-test-mzcqc</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># kc get pods --show-labels</span></span></span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE     LABELS</span><br><span class="line">rc-test-6b69p      1/1     Running             0          2m31s   app=nginx</span><br><span class="line">rc-test-89hqk      0/1     ContainerCreating   0          1s      app=nginx</span><br><span class="line">rc-test-mzcqc      0/1     Terminating         0          3m11s   app=nginx</span><br><span class="line">rc-test-sfc8r      1/1     Running             0          2m50s   app=nginx</span><br></pre></td></tr></table></figure></p><p>重新列出pod会显示四个，删除的 pod 在终止中，新创建的 pod 在创建中</p><h3 id="获取有关-ReplicationController-的信息"><a href="#获取有关-ReplicationController-的信息" class="headerlink" title="获取有关 ReplicationController 的信息"></a>获取有关 ReplicationController 的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 列出所有 rc 控制器</span><br><span class="line">kc get rc</span><br><span class="line">## 查看某个 rc 详细信息</span><br><span class="line">kc describe rc rc-test</span><br></pre></td></tr></table></figure><p>控制器通过创建一个新的替代 pod 来响应 pod 的删除操作。从技术上讲，它并没有对删除本身做出反应，而是针对由此产生的状态：pod 数量不足。<br>虽然 ReplicationController 会立即收到删除 pod 的通知 ( API 服务器允许客户端 监听资源和资源列表的更改 ），但这不是它创建替代 pod 的原因。该通知会触发控制器检查实际的 pod 数量并采取适当的措施。</p><h3 id="将-pod-移入或移出-ReplicationController-的作用域"><a href="#将-pod-移入或移出-ReplicationController-的作用域" class="headerlink" title="将 pod 移入或移出 ReplicationController 的作用域"></a>将 pod 移入或移出 ReplicationController 的作用域</h3><p>由 ReplicationController 创建的 pod 并不是绑定到 ReplicationController。在任何时刻，ReplicationController 管理与标签选择器匹配的 pod。通过更改 pod 的标签，可以将它从 ReplicationController 的作用域中添加或删除。它甚至可以从一个ReplicationController移动到另一个。</p><blockquote><p>尽管一个 pod 没有绑定到一个 ReplicationController，但该 pod 在metadata.ownerReferences 字段中引用它，可以轻松使用它来找到一个 pod 属于哪个 ReplicationController</p></blockquote><p>如果你更改了一个 pod 的标签，使它不再与 ReplicationController 的标签选择器相匹配，那么该 pod 就变得和其他手动创建的 pod 一样了。它不再被任何东西管理。如果运行该节点的 pod 异常终止，它显然不会被重新调度。 但请记住，当你更改 pod 的标签时，ReplicationController 发现一个 pod 丢失了，并启动一个新的 pod 替换它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 给其中的一个pod 添加标签</span><br><span class="line">kc label pods rc-test-89hqk auth=yuxuan</span><br><span class="line">kc get pods --show-labels</span><br><span class="line">rc-test-6b69p      1/1     Running   0          29m   app=nginx</span><br><span class="line">rc-test-89hqk      1/1     Running   0          27m   app=nginx,auth=yuxuan</span><br><span class="line">rc-test-sfc8r      1/1     Running   0          29m   app=nginx</span><br></pre></td></tr></table></figure><p>给其中一个 pod 添加了 auth=yuxuan 标签，再次列出所有 pod 会显示和以前一样的三个 pod。因为从 ReplicationController 角度而言，没发生任何更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 修改其中一个pod的 app 标签值</span><br><span class="line">kc label pod rc-test-89hqk app=nginx2 --overwrite</span><br><span class="line">kc get pods --show-labels</span><br><span class="line">NAME               READY   STATUS              RESTARTS   AGE   LABELS</span><br><span class="line">rc-test-6b69p      1/1     Running             0          35m   app=nginx</span><br><span class="line">rc-test-89hqk      1/1     Running             0          33m   app=nginx2,auth=yuxuan</span><br><span class="line">rc-test-mpf76      0/1     ContainerCreating   0          2s    app=nginx</span><br><span class="line">rc-test-sfc8r      1/1     Running             0          36m   app=nginx</span><br></pre></td></tr></table></figure><p>列出 pod，会发现有四个pod，其中一个 app=nginx2 已经不由 ReplicationController管理了，其他三个是。</p><h3 id="更改-ReplicationControlle-的标签选择器"><a href="#更改-ReplicationControlle-的标签选择器" class="headerlink" title="更改 ReplicationControlle 的标签选择器"></a>更改 ReplicationControlle 的标签选择器</h3><p>如果修改了 ReplicationController 的标签选择器，它会让所有的 pod 脱离 ReplicationController 的管理，导致它 创建三个新的 pod。</p><h3 id="修改-ReplicationControlle-的-pod-模板"><a href="#修改-ReplicationControlle-的-pod-模板" class="headerlink" title="修改 ReplicationControlle 的 pod 模板"></a>修改 ReplicationControlle 的 pod 模板</h3><p>ReplicationController 的 pod 模板可以随时修改。更改 pod 模板就像用一个 pod 替换另－个。它只会影响你之后创建的pod，并且不会影响你已经创建的 pod。要修改旧的 pod，你需要删除它们，并让 ReplicationController 根据新模板将其替换为新的 pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将在你的默认文本编辑器中打开 ReplicationController 的 YAML 配置</span></span></span><br><span class="line">kc edit rc rc-test</span><br></pre></td></tr></table></figure><blockquote><p>配置 kubectl edit 使用不同的文本编辑器<br>可以通过设直 KUBE_EDITOR 环境变量来告诉 kubectl 使用你期望的文本编辑器。例如：<br>export KUBE_EDITOR=”/usr/bin/nano”</p></blockquote><h3 id="调整-rc-的-scale-来水平伸缩-pod"><a href="#调整-rc-的-scale-来水平伸缩-pod" class="headerlink" title="调整 rc 的 scale 来水平伸缩 pod"></a>调整 rc 的 scale 来水平伸缩 pod</h3><p>伸缩 pod 的数量规模就和在ReplicationController 资源中更改 Replicas 宇段的值一样简单。更改之后， ReplicationController 将会看到存在太多 的 pod 并删除其中的一部分（缩容时），或者看到它们数目太少并创建 pod（扩容时）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 使用 kubectl scale 命令</span><br><span class="line">kc scale rc rc-test --replicas=8</span><br><span class="line">## 也可以使用 kc edit 来修改</span><br><span class="line">kc edit rc rc-test</span><br></pre></td></tr></table></figure><h3 id="删除一个-ReplicationController"><a href="#删除一个-ReplicationController" class="headerlink" title="删除一个 ReplicationController"></a>删除一个 ReplicationController</h3><p>当你通过 kubectl delete 删除ReplicationController 时，pod 也会被删除。但是由于由 ReplicationController 创建的 pod 不是 ReplicationController 的组成部分，只是由其进行管理，因此可以只删除 ReplicationController 并保持 pod 运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kc delete rc rc-test --cascade=false</span><br></pre></td></tr></table></figure></p><h2 id="ReplicaSet-控制器"><a href="#ReplicaSet-控制器" class="headerlink" title="ReplicaSet 控制器"></a>ReplicaSet 控制器</h2><p>最初，ReplicationController 是用于复制和在异常时重新调度节点的唯一 Kubernetes 组件，后来又引入了一个名为 ReplicaSet 的类似资源。它是新一代的 ReplicationController，并且将其完全替换掉， ReplicationController 最终将被弃用。</p><h3 id="ReplicaSet-和-ReplicationController-区别"><a href="#ReplicaSet-和-ReplicationController-区别" class="headerlink" title="ReplicaSet 和 ReplicationController 区别"></a>ReplicaSet 和 ReplicationController 区别</h3><p>ReplicaSet 的行为与 ReplicationController 完全相同，但 pod 选择器的表达能力更强。虽然 ReplicationController 的标签选择器只允许包含某个标签的匹配 pod，但 ReplicaSet的选择器还允许匹配缺少某个标签的 pod ，或包含特定标签名的 pod，不管其值如何。</p><p>同样，无论 ReplicationController 的值如何，ReplicationController 都无法仅基于标签名的存在来匹配 pod，而 ReplicaSet 则可以。例如，ReplicaSet 可匹配所有包含 名为 env 的标签的 pod，无论 ReplicaSet 的实际值是什么（可以理解为 env＝* ）。</p><h2 id="定义-ReplicaSet"><a href="#定义-ReplicaSet" class="headerlink" title="定义 ReplicaSet"></a>定义 ReplicaSet</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rs-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 使用简单的matchLabels选择器</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rs-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>首先要注意的是 ReplicaSet 不是 v1 API 的一部分，因此你需要确保在创建资源时指定正确的 apiVersion。你正在创建一个类型为ReplicaSet 的资源，它的内容与之前创建的 ReplicationController 的内容大致相同。</p><p>唯一的区别在选择器中。不必在 selector 属性中直接列出 pod 需要的标签，而是在 selector.matchLabels 下指定它们。这是在 ReplicaSet 中定义标签选择器的更简单的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 列出所有rs</span><br><span class="line">kc get rs</span><br><span class="line">## 查看指定rs的详情</span><br><span class="line">kc describe rs rs-test</span><br></pre></td></tr></table></figure><h3 id="使用-ReplicaSet-的更富表达力的标签选择器"><a href="#使用-ReplicaSet-的更富表达力的标签选择器" class="headerlink" title="使用 ReplicaSet 的更富表达力的标签选择器"></a>使用 ReplicaSet 的更富表达力的标签选择器</h3><p>ReplicaSet 相对于 ReplicationController 的主要改进是它更具表达力的标签选择器。上面用了较简单的 matchLabels 选择器。现在，将用更强大的matchExpressions 属性来重写选择器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">rs-test-matchexpressions</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">        matchExpressions:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">app</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">            values:</span></span><br><span class="line"><span class="bullet">              -</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rs-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>可以给选择器添加额外的表达式。如上面所写， 每个表达式都必须包含一个 key、一个 operator（运算符〉，并且可能还有一个 values 的列表（取决于运算符）。你会看到四个有效的运算符：</p><ul><li>In：Label 的值必须与其中一个指定的 values 匹配。</li><li>NotIn：Label 的值与任何指定的 values 不匹配。</li><li>Exists：pod 必须包含一个指定名称的标签,值不重要。使用此运算符时，不应指定 values 字段。</li><li>DoesNotExist：pod 不得包含有指定名称的标签。values 属性不得指定。</li></ul><p>如果指定了多个表达式，则所有这些表达式都必须为 true 才能使选择器与 pod 匹配。如果同时指定 matchLabels 和 matchExpressions，则所有标签都必须匹配， 并且所有表达式必须计算为 true 以使该 pod 与选择器匹配。</p><h2 id="DaemonSet-在每个节点上运行一个pod"><a href="#DaemonSet-在每个节点上运行一个pod" class="headerlink" title="DaemonSet 在每个节点上运行一个pod"></a>DaemonSet 在每个节点上运行一个pod</h2><p>Replicationcontroller 和 ReplicaSet 都用于在 Kubernetes 集群上运行部署特定数量的 pod。但是，当你希望 pod 在集群中的每个节点上运行时，例如，希望在每个节点上运行日志收集器和资源监控器。</p><p>要在所有集群节点上运行一个 pod，需要创建一个 DaemonSet 对象。DaemonSet 确保创建足够的 pod，并在自己的节点上部署每个 pod。</p><p>尽管 ReplicaSet 或 ReplicationController 确保集群中存在期望数量的 pod 副本，但 DaemonSet 并没有期望的副本数的概念。它不需要，因为它的工作是确保一个 pod 匹配它的选择器并在每个节点上运行。</p><p>如果节点下线，DaemonSet 不会在其他地方重新创建 pod。但是，当将一个新节点添加到集群中时，DaemonSet 会立刻部署一个新的 pod 实例。如果删除了一个 pod，那么它也会重新 创建一个新的 pod。与 ReplicaSet 一样， DaemonSet 从配置的 pod 模板创建 pod。</p><p>默认情况下 DaemonSet 是将 pod 部署到集群中的所有节点上，如果想要指定 pod 只在部分节点上运行。可以通过 pod 模板中的 nodeSelector 属性指定。</p><blockquote><p>节点可以被设置为不可调度的，防止 pod 被部署到节点上。 DaemonSet 甚至会将 pod 部署到这些节点上，因为无法调度的属性只会被调度器使用，而 DaemonSet 管理 的 pod 则 完全绕过调度器。这是预期的，因为 DaemonSet 的目的是运行系统服务，即使是在不可调度的节点上，系统服务通常也需要运行。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ds-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="comment">## pod实例的目标数量</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 使用简单的matchLabels选择器</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment">## 创建新 pod 所用的pod模板</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">            labels:</span></span><br><span class="line"><span class="attr">                app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line">            <span class="comment">## 节点选择器，只会在满足条件的 node 上部署 pod</span></span><br><span class="line"><span class="attr">            nodeSelector:</span></span><br><span class="line"><span class="attr">                cpu:</span> <span class="string">gpu</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-ds-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">              ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建 ds</span></span></span><br><span class="line">kc create -f test-nginx-daemon-set-controller.yaml --validate=false</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 列出 ds</span></span></span><br><span class="line">kc get ds</span><br><span class="line">NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">ds-test   1         1         1       1            1           cpu=gpu         2m50s</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果把节点上的标签修改了 pod 会立即停止</span></span></span><br><span class="line">kc label node 192.168.1.230 cpu=no --overwrite</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 再次列出 ds</span></span></span><br><span class="line">kc get ds</span><br><span class="line">NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">ds-test   0         0         0       0            0           cpu=gpu         5m34s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（八）Kubernetes 之 就绪探针</title>
      <link href="/kubernetes/k8s8/"/>
      <url>/kubernetes/k8s8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>现在我们知道了，服务（service）可以通过服务的 pod 选择器来匹配具有相应标签的 pod。匹配成功后， pod 将作为服务的后端，它将成为服务的一部分，并且请求开始被重定向到 pod。但是，如果 pod 没有完全启动好，比如改 pod 可能需要时间来加载配置或数据，或者可能需要执行预热过程以防止第一个用户请求时间太长影响了用户体验。 在这种情况下，不希望该 pod 立即开始接 收请求，尤其是在有其他运行的 pod 可以正确快速地处理请求的情况下。 不要将请求转发到正在启动的 pod 中，直到完全准备就绪。</p><h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><p>前面我们了解了存活探针，以及它们如何通过确保异常容器自动重启来保持应用程序的正常运行。与存活探针类似，Kubernetes 还允许为容器定义准备就绪探针 。</p><p>就绪探测器会定期调用，并确定特定的 pod 是否接收客户端请求。当容器的准备就绪探测返回成功时，表示容器己准备好接收请求。</p><p>这个准备就绪的概念显然是每个容器特有的东西。 Kubernetes 只能检查在容器中运行的应用程序是否响应一个简单的 GET 请求，或者它可以响应特定的 URL 路径（该 URL 导致应用程序执行一系列检查以确定它是否准备就绪）。考虑到应用程序的具体情况，这种确切的准备就绪的判定是应用程序开发人员的 责任。</p><p>像存活探针一样，就绪探针有三种类型：</p><ul><li>HTTP GET 探针对容器的 IP 地址（指定的端口和路径）执行 HTTP GET 请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果 HTTP 响应状态码是 2xx 或 3xx ），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的。</li><li>TCP 套接字探针尝试与容器指定端口建立 TCP 连接。如果连接成功建立，则探测成功。反之失败。</li><li>Exec 探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 0，则探测成功。所有其他状态码都被认为失败。</li></ul><h2 id="了解就绪探针的流程"><a href="#了解就绪探针的流程" class="headerlink" title="了解就绪探针的流程"></a>了解就绪探针的流程</h2><p>启动容器时，可以为 Kubernetes 配置一个等待时间，经过等待时间后才可以执行第 一次准备就绪检查。之后，它会周期性地调用探针，并根据就绪探针的结果采取行动。如果某个 pod 报告它尚未准备就绪，则会从该服务(Service)中删除该 pod。如果 pod 再次准备就绪，则重新添加 pod。</p><p>与存活探针不同，如果容器未通过准备检查，则不会被终止或重新启动。这是存活探针与就绪探针之间的重要区别。存活探针通过杀死异常的容器并用新的正常容器替代它们来保持 pod 正常工作，而就绪探针确保只有准备好处理请求的 pod 才可以接收请求。这在容器启动时最为必要，当然在容器运行一段时间后也是有用的。</p><p>如下图所示，如果一个容器的就绪探测失败， 则将该容器从端点对象中移除。连接到该服务的客户端不会被重定向到 pod。这和 pod 与服务的标签选择器完全不匹配的效果相同。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-0a4e696f494b4a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="就绪失败的 pod 将从服务的 endpoint 中移除"></p><h2 id="pod-添加就绪探针"><a href="#pod-添加就绪探针" class="headerlink" title="pod 添加就绪探针"></a>pod 添加就绪探针</h2><p>我们可以在定义 pod 模板的时候添加好探针，也可以通过 kubectl edit 命令来修改已存在的 pod 模板。下面我们就来修改之前创建的 ReplicationController中的 pod 模板。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc rc-test</span><br></pre></td></tr></table></figure></p><p>当在文本编辑器中打开 ReplicationController 的 YAML 时，就将以下就绪探针定义添加到 spec.template.spec.containers 下的容器模板中。修改后的 YAML 大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="string">.....</span> <span class="comment">##省略其它</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="string">.....</span> <span class="comment">##省略其它</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">            containers:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">test-rc-nginx</span></span><br><span class="line"><span class="attr">              image:</span> <span class="string">nginx</span></span><br><span class="line">              <span class="comment">## 添加就绪探针</span></span><br><span class="line"><span class="attr">              readinessProbe:</span></span><br><span class="line"><span class="attr">                exec:</span></span><br><span class="line"><span class="attr">                    command:</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">ls</span></span><br><span class="line"><span class="bullet">                    -</span> <span class="string">/var/test</span> </span><br><span class="line">    <span class="string">.....</span> <span class="comment">##省略其它</span></span><br></pre></td></tr></table></figure><p>就绪探针将定期在容器内执行 ls /var/test 命令。 如果文件存在，则 ls 命令返回退出码 0，否则返回非零的退出码。如果文件存在，则就绪探针为成功，反之失败。</p><p>修改 rc 之后，现有的所有 pod 仍没有定义准备就绪探针。我们需要删除现有 pod 并让它们通过修改之后的 ReplicationController 重新创建。新的 pod 将进行就绪检查会一直失败，并且不会将其作为服务的端点，直到在每个 pod 中创建 /var/test 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 列出 pod  会发现所有的 pod 都处于 NO READY 状态</span></span></span><br><span class="line">[root@h249 test]# kc get pods</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">rc-test-nxg74   0/1     Running   0          9m55s</span><br><span class="line">rc-test-pztvx   0/1     Running   0          6m58s</span><br><span class="line">rc-test-svkzp   0/1     Running   0          6m58s</span><br></pre></td></tr></table></figure><p>使用 kubecl exec 命令为 pod 创建 /var/test 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@h249 home]# kc exec rc-test-nxg74 -- touch /var/test</span><br></pre></td></tr></table></figure><p>准备就绪探针会定期检查，默认情况下每 10 秒检查一次。可能不是马上就会调用就绪探针，因此容器可能还是未准备好。但是最晚 10 秒钟内，该 pod 就会准备就绪。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（五）Kubernetes 之 存活探针</title>
      <link href="/kubernetes/k8s5/"/>
      <url>/kubernetes/k8s5/</url>
      
        <content type="html"><![CDATA[<h2 id="保持pod健康"><a href="#保持pod健康" class="headerlink" title="保持pod健康"></a>保持pod健康</h2><p>使用 Kubernetes 的一个主要好处是，可以给 Kubernetes －个容器列表来由其保持容器在集群中的运行。可以通过让 Kubernetes 创建 pod 资源，为其选择一个工作节点并在该节点上运行该 pod 的容器来完成此操作。但是，如果其中一个容器终止，或一个 pod 的所有容器都终止，怎么办？</p><p>只要将 pod 调度到某个节点，该节点上的 Kubelet 就会运行 pod 的容器， 从此只要该 pod 存在，就会保持运行。如果容器的主进程崩溃，Kubelet 将重启容器。如果应用程序中有一个导致它每隔一段时间就会崩溃的 bug, Kubernetes 会自动重启应用程序，所以即使应用程序本身没有做任何特殊的事，在Kubernetes 中运行也能自动获得自我修复的能力。</p><p>即使进程没有崩溃，有时应用程序也会停止正常工作。例如，具有内存泄漏的 Java 应用程序将开始抛出 OutOfMemoryErrors，但 JVM 进程会一直运行。如果有一种方法，能让应用程序向 Kubernetes 发出信号，告诉 Kubernetes 它运行异常并让 Kubernetes 重新启动，那就很棒了。</p><p>我们已经说过，一个崩溃的容器会自动重启，所以也许你会想到，可以在应用中捕获这类错误， 并在错误发生时退出该进程。当然可以这样做，但这仍然不能解决所有的问题。</p><p>例如，你的应用因为无限循环或死锁而停止响应。为确保应用程序在这种情况下可以重新启动，必须从外部检查应用程序的运行状况，而不是依赖于应用的内部检测。</p><h3 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h3><p>Kubernetes 可以通过存活探针（liveness probe）检查容器是否还在运行。可以为 pod 中的每个容器单独指定存活探针。如果探测失败，Kubernetes 将定期执行探针并重新启动容器。</p><p>Kubernetes 有以下三种探测容器的机制：</p><ul><li>HTTP GET 探针对容器的 IP 地址（指定的端口和路径）执行 HTTP GET 请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果 HTTP 响应状态码是 2xx 或 3xx ），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。</li><li>TCP 套接字探针尝试与容器指定端口建立 TCP 连接。如果连接成功建立，则探测成功。 否则，容器重新启动。</li><li>Exec 探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 0，则探测成功。所有其他状态码都被认为失败。</li></ul><h4 id="创建-HTTP-的存活探针"><a href="#创建-HTTP-的存活探针" class="headerlink" title="创建 HTTP 的存活探针"></a>创建 HTTP 的存活探针</h4><p>创建一个包含 HTTP GET 存活探针的新 pod</p><pre><code>apiVersion: v1kind: Podmetadata:    name: test-nginx-liveness-probespec:    containers:    - image: nginx      name: test      ## 存活探针      livenessProbe:        ## 初始延迟        initiaDelaySeconds: 20        ## HTTP GET 存活探针        httpGet:            ## HTTP 请求路径            path: /            ## 端口            port: 8080      ports:      - containerPort: 80        protocol: TCP</code></pre><p>该 pod 的描述文件定义了一个 HTTP Get 存活探针，该探针告诉 Kubernetes 定期在端口 8080 路径上执行 HTTP GET 请求，已确定该容器是否健康，请求在容器运行后立即开始。</p><p>上面指定8080，但其实容器没有在8080端口上运行http程序，所以会一直请求失败，Kubernete 会认为探测失败并重启容器。</p><blockquote><p>当容器被强行终止时会创建一个全新的容器，而不是重启原来的容器 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（七）Kubernetes 之 服务 Service</title>
      <link href="/kubernetes/k8s7/"/>
      <url>/kubernetes/k8s7/</url>
      
        <content type="html"><![CDATA[<p>kubernetes 服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源。当服务存在时，它的 IP 地址和端口不会改变。客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上。通过这种方式，客户端不需要知道每个单独的提供服务的 pod 的地址，这样这些 pod 就可以在集群中随时被创建或移除。</p><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><h3 id="通过-kubectl-expose-快速创建"><a href="#通过-kubectl-expose-快速创建" class="headerlink" title="通过 kubectl expose 快速创建"></a>通过 kubectl expose 快速创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose rc yx-nginx</span><br></pre></td></tr></table></figure><p>执行此命令，就是会根据 rc 控制器 yx-nginx 创建一个同名的 service。</p><h3 id="通过-yaml-配置文件创建"><a href="#通过-yaml-配置文件创建" class="headerlink" title="通过 yaml 配置文件创建"></a>通过 yaml 配置文件创建</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>创建了一个名叫 yx-nginx 的服务，它将在端口 8000 接受请求并将连接路由到具有 app=nginx 标签的 pod 的 80 端口上。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f test-nginx-service.yaml</span><br></pre></td></tr></table></figure></p><h2 id="列出命名空间下所有服务资源"><a href="#列出命名空间下所有服务资源" class="headerlink" title="列出命名空间下所有服务资源"></a>列出命名空间下所有服务资源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc</span><br><span class="line"></span><br><span class="line">NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes              ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          3d20h</span><br><span class="line">yx-nginx                ClusterIP      10.109.90.148   &lt;none&gt;        8000/TCP         18h</span><br></pre></td></tr></table></figure><p>列表显示分配给服务的 IP 地址是 10.109.90.148。因为只是集群的 iP 地址，只能在集群内部可以被访问。</p><h2 id="配置服务上的会话亲和性"><a href="#配置服务上的会话亲和性" class="headerlink" title="配置服务上的会话亲和性"></a>配置服务上的会话亲和性</h2><p>如果多次请求同一个服务，每次调用执行应该在不同的 pod 上。因为在默认情况下， Kubernetes 采用 RoundRobin 模式对客户端请求进行负载分发。</p><p>如果希望特定客户端产生的所有请求每次都指向同一个 pod，可以设置服务的sessionAffinity 属性为ClientIP，默认值为 None。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">    ## 服务名称</span><br><span class="line">    name: yx-nginx</span><br><span class="line">spec:</span><br><span class="line">    sessionAffinity: ClientIP</span><br><span class="line">    ports:</span><br><span class="line">    ## 服务访问端口</span><br><span class="line">    - port: 8000</span><br><span class="line">    ## 目标 pod 访问端口</span><br><span class="line">      targetPort: 80</span><br><span class="line">    selector:</span><br><span class="line">        ## 具有 app=nginx 标签的 pod 都属于该服务</span><br><span class="line">        app: nginx</span><br></pre></td></tr></table></figure></p><h2 id="同一个服务暴露多个端口"><a href="#同一个服务暴露多个端口" class="headerlink" title="同一个服务暴露多个端口"></a>同一个服务暴露多个端口</h2><p>创建的服务可以暴露一个端口，也可以暴露多个端口。比如，你的 pod 监昕两个端口，比如 HTTP 监听 80 端口、 HTTPS 监听 443 端口，可以使用一个服务从端口 80 和 443 转发至 pod 端口 80 和 443。在这种情况下，无须创建两个不同的服务。通过一个集群 IP，使用一个服务就可以将多个端口全部暴露出来。</p><blockquote><p>在创建一个有多个端口的服务的时候，必须给每个端口指定名字。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>标签选择器应用于整个服务，不能对每个端口做单独的配置。如果不同的 pod 有不同的端口映射关系，需要创建两个服务。</p></blockquote><h2 id="使用命名的端口"><a href="#使用命名的端口" class="headerlink" title="使用命名的端口"></a>使用命名的端口</h2><p>我们可以在定义 pod 端口的时候给端口命名，然后在服务 spec 中按名称引入端口。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-nginx</span> <span class="comment">##pod名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    containers:</span> <span class="comment">## pod里运行那些容器</span></span><br><span class="line"><span class="attr">    - image:</span> <span class="string">nginx</span>  <span class="comment">## 镜像名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test</span>    <span class="comment">## 容器名称</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>为什么要采用命名端口的方式？最大的好处就是即使更换端口号也无须更改服务 spec。你的 pod 现在对 http 服务用的是 80，但是假设过段时间你决定将端口更换为 8080 呢？<br>如果你采用了命名的端口，仅仅需要做的就是改变 spec pod 中的端口号（当然你的端口号的名称没有改变）。在你的 pod 向新端口更新时，根据 pod 收到的连接 (80 端口在旧的 pod 上、 8080 端口在新的 pod 上 ），用户连接将会转发到对应的端口。</p><h2 id="连接集群外部的服务"><a href="#连接集群外部的服务" class="headerlink" title="连接集群外部的服务"></a>连接集群外部的服务</h2><p>通过 Kubernetes 服务特性暴露外部服务的情况。不要让服务将连接重定向到集群中的 pod，而是让它重定向到外部 IP 和端口。<br>这样做可以让你充分利用服务负载平衡和服务发现。在集群中运行的客户端 pod 可以像连接到内部服务一样连接到外部服务 。</p><h3 id="介绍服务-endpoint"><a href="#介绍服务-endpoint" class="headerlink" title="介绍服务 endpoint"></a>介绍服务 endpoint</h3><p>服务并不是和 pod 直接相连的。相反，有一种资源介于两者之间，它就是 Endpoint 资源。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe svc yx-nginx</span></span><br><span class="line">Name:              yx-nginx</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.108.146.21</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         100.108.201.68:80,100.73.43.204:80,100.98.112.72:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>Endpoint 资源就是暴露一个服务的 IP 地址和端口的列表，Endpoint 资源和其他 Kubernetes 资源一样，所以可以使用 kubectl info 来获取它的基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get endpoints yx-nginx</span></span><br><span class="line">NAME       ENDPOINTS                                            AGE</span><br><span class="line">yx-nginx   100.73.43.204:80,100.73.43.205:80,100.73.43.206:80   23h</span><br></pre></td></tr></table></figure><p>尽管在 spec 服务中定义了 pod 选择器，但在重定向传入连接时不会直接使用它。相反，选择器用于构建 IP 和端口列表，然后存储在 Endpoint 资源中。 当客户端连接到服务时，服务代理选择这些 IP 和端口对中的一个，并将传入连接重定向到在该 位置监昕的服务器。</p><h3 id="手动配置服务的-endpoint"><a href="#手动配置服务的-endpoint" class="headerlink" title="手动配置服务的 endpoint"></a>手动配置服务的 endpoint</h3><p>服务的 endpoint 与服务解稍后，可以分别手动配置和更新它们。</p><p>如果创建了不包含 pod 选择器的服务，Kubernetes 将不会创建 Endpoint 资源（毕竟，缺少选择器，将不会知道服务中包含哪些 pod ）。这样就需要创建 Endpoint 资源来指定该服务的 endpoint 列表。</p><h4 id="创建没有选择器的服务"><a href="#创建没有选择器的服务" class="headerlink" title="创建没有选择器的服务"></a>创建没有选择器的服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">manual-endponit-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>定义一个名为 manual-endponit-service 的服务， 它将接收端口 80 上的传入连接。并没有为服务定义一个 pod 选择器 。</p><h4 id="为没有选择器的服务创建-Endpoint-资源"><a href="#为没有选择器的服务创建-Endpoint-资源" class="headerlink" title="为没有选择器的服务创建 Endpoint 资源"></a>为没有选择器的服务创建 Endpoint 资源</h4><p>Endpoint 是一个单独的资源并不是服务的一个属性。由于创建的服务中并不包 含选择器，相关的 Endpoints 资源并没有自动创建，所以必须手动创建。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## endpoint 的名称必须和服务名称一致</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">manual-endponit-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.239</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8090</span></span><br></pre></td></tr></table></figure></p><p>Endpoint 对象需要与服务具有相同的名称，并包含该服务的目标 IP 地址和端口列表。服务和 Endpoint 资源都发布到服务器后，这样服务就可以像具有 pod 选择器那样的服务正常使用。在服务创建后创建的容器将包含服务的环境变量，并且与其 ip : port 对的所有连接都将在服务端点之间进行负载均衡。</p><h2 id="将服务暴露给外部访问"><a href="#将服务暴露给外部访问" class="headerlink" title="将服务暴露给外部访问"></a>将服务暴露给外部访问</h2><p>上面只讨论了集群内服务如何被 pod 使用；但是，还需要向外部公开某些服务。例如前端 web 服务器，以便外部客户端可以访问它们。<br>有几种方式可以在外部访问服务 ：</p><ul><li>将服务的类型设置成 NodePort：每个集群节点都会在节点上打开一个端口，对于 NodePort 服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。该服务仅在内部集群 IP 和端口上才可访问，但也可通过所有节点上的专用端口访问。</li><li>将服务的类型设置成 LoadBalance：NodePort 类型的一种扩展，这使得 服务可以通过一个专用的负载均衡器来访问，这是由 Kubernetes 中正在运行的云基础设施提供的。负载均衡器将流量重定向到跨所有节点的节点端口。 客户端通过负载均衡器的 IP 连接到服务。</li><li>创建一个 Ingress 资源，这是一个完全不同的机制，通过一个 IP 地址公开多个服务，它运行在 HTTP 层（ 网络协议第 7 层）上，因此可以提供比工作在第 4 层的服务更多的功能。</li></ul><h3 id="创建-NodePort-类型的服务"><a href="#创建-NodePort-类型的服务" class="headerlink" title="创建 NodePort 类型的服务"></a>创建 NodePort 类型的服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="comment">## 集群节点端口，通过该端口访问服务，如果不设置，kubernetes 会随机一个端口</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30123</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>将类型设置为 NodePort 并指定该服务应该绑定到的所有集群节点的节点端口。指定端口不是强制性的。如果忽略它，Kubernetes 将选择一个随机端口。</p><h3 id="创建-LoadBalance-负载均衡器服务"><a href="#创建-LoadBalance-负载均衡器服务" class="headerlink" title="创建 LoadBalance 负载均衡器服务"></a>创建 LoadBalance 负载均衡器服务</h3><p>kubernetes 集群通常支持从云基础架构自动提供负载平衡器。所有需要做的就是设置服务的类型为 LoadBadancer 而不是 NodePort。负载均衡器拥有自己独一无二的可公开访问的 IP 地址， 可以通过负载均衡器的 IP 地址访问服务。</p><p>如果 kubernetes 在不支持 LoadBadancer 服务的环境中运行，则不会调 配负载平衡器，但该服务仍将表现得像一个 NodePort 服务。这是因为 LoadBadancer 服务是 Node Port 服务的扩展<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="comment">## 服务名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">yx-nginx-loadbalancer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment">## 服务访问端口</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="comment">## 目标 pod 访问端口</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30124</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line">        <span class="comment">## 具有 app=nginx 标签的 pod 都属于该服务</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure></p><h2 id="了解外部连接的特性"><a href="#了解外部连接的特性" class="headerlink" title="了解外部连接的特性"></a>了解外部连接的特性</h2><h3 id="防止不必要的网络跳数"><a href="#防止不必要的网络跳数" class="headerlink" title="防止不必要的网络跳数"></a>防止不必要的网络跳数</h3><p>当外部客户端通过节点端口连接到服务时，随机选择的 pod 并不一定在接收连接的同一节点上运行。可能需要额外的网络跳转才能到达 pod，但这种行为并不符合期望。</p><p>可以通过将服务配置为仅将外部通信重定向到接收连接的节点上运行的 pod 来阻止此额外跳数。这是通过在服务的 spec 部分中设置 externalTrafficPolicy 字段来完成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">    externalTrafficPolicy:</span> <span class="string">Local</span></span><br></pre></td></tr></table></figure><p>如果服务定义包含此设置，并且通过服务的节点端口打开外部连接，则服务代理将选择本地运行的 pod。如果没有本地 pod 存在，则连接将挂起。因此，需要确保负载平衡器将连接转发给至少具有一个 pod 的节点。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（四）Docker 容器</title>
      <link href="/docker/docker4/"/>
      <url>/docker/docker4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>容器是 Docker 的另一个核心概念。简单来说，容器是镜像的一个运行实例。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态。</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><h3 id="新建容器-docker-create"><a href="#新建容器-docker-create" class="headerlink" title="新建容器 docker create"></a>新建容器 docker create</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker create -it ubuntu:latest</span><br><span class="line">5d05ba725c395dbc351da29253c077bf82b4f711ea332687b09d03e3c1aa046b</span><br><span class="line">[root@h244 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">5d05ba725c39        ubuntu:latest          "bash"                   5 seconds ago       Created                                         nifty_chandrasekhar</span><br></pre></td></tr></table></figure><p>使用 docker create 命令新建的容器处于停止状态，可以使用 docker start 命令来启动。</p><p>容器是整个 Docker 技术的核心，创建容器的选项十分复杂，主要包裹几个大类：</p><ul><li>与容器运行模式相关</li><li>与容器环境配置相关</li><li>与容器资源限制</li><li>与安全保护相关</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1455014-2022faefe8e8ad28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行模式相关"></p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-536f47f3240e35d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环境配置相关"></p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-6d1e7d993dc84138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-382a34351de517a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="启动容器-docker-start"><a href="#启动容器-docker-start" class="headerlink" title="启动容器 docker start"></a>启动容器 docker start</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker start 5d05ba725c39</span><br><span class="line">5d05ba725c39</span><br><span class="line">[root@h244 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED              STATUS              PORTS               NAMES</span><br><span class="line">5d05ba725c39        ubuntu:latest          "bash"                   About a minute ago   Up 1 second                             nifty_chandrasekhar</span><br></pre></td></tr></table></figure><p>此时，通过 ps 命令查看就会发现容器是运行状态了。</p><h3 id="新建并启动容器-docker-run"><a href="#新建并启动容器-docker-run" class="headerlink" title="新建并启动容器 docker run"></a>新建并启动容器 docker run</h3><p>docker run，其等价于先执行 docker create，在执行 docker start 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker run ubuntu:latest /bin/echo 'hello world'</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>执行上面命令其实和本地执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。<br>当执行 docker run 来创建并启动容器时，docker 在后台操作如下：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载。</li><li>利用镜像创建一个容器，并启动该容器。</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层。</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li><li>从网桥的地址池配置一个 IP 地址给容器。</li><li>执行用户指定的应用程序。</li><li>执行完毕后容器被自动退出运行。</li></ul><p>下面我们在 run 一个容器，运行 bash 终端进行交互<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker run -it  ubuntu:latest /bin/bash</span><br><span class="line">root@e99229bb9570:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@e99229bb9570:/# ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 bash</span><br><span class="line">     9 pts/0    00:00:00 ps</span><br><span class="line">root@e99229bb9570:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure></p><p>－t 选项让 Docker 分配一个伪终端并绑定到容器的标准输入上，－i 则让容器的标准输入保持打开。</p><p>在容器内用 ps 命令查看进程，可以看到，只运行了 bash 应用，并没有运行其他无关的进程。当我们 exit 退出 bash 进程之后，容器也会自动退出。</p><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>很多时候，需要让 docker 容器在后台以守护态形式运行。我们可以通过添加 -d 参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker run -d  ubuntu:latest /bin/sh -c "while true; do echo hello world; sleep 1; done"</span><br><span class="line">8538511dbb52c78b7b7b4b1cfa38f981ef484713ad0595fda2647724e12acf90</span><br></pre></td></tr></table></figure><p>容器启动后会返回一个唯一的 id, 可以通过 docker ps 来查看容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8538511dbb52        ubuntu:latest          "/bin/sh -c 'while t…"   2 seconds ago       Up 1 second                             wizardly_hugle</span><br></pre></td></tr></table></figure><h2 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker logs -f 8538511dbb52</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>通过 docker logs 可以查看容器的输出。</p><blockquote><p>－details 打印详细信息<br>-f,-follow 持续保持输出<br>-since string 输出从某个时间开始得日志<br>-tail string 输出最近的若干日志<br>-t,-timestamps 显示时间戳信息<br>-until string 输出某个时间之前的日志</p></blockquote><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><h3 id="暂停容器"><a href="#暂停容器" class="headerlink" title="暂停容器"></a>暂停容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker pause 8538511dbb52</span><br><span class="line">8538511dbb52</span><br><span class="line">[root@h244 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">8538511dbb52        ubuntu:latest          "/bin/sh -c 'while t…"   7 minutes ago       Up 7 minutes (Paused)                       wizardly_hugle</span><br><span class="line"></span><br><span class="line">[root@h244 ~]# docker unpause 8538511dbb52</span><br><span class="line">8538511dbb52</span><br><span class="line">[root@h244 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8538511dbb52        ubuntu:latest          "/bin/sh -c 'while t…"   8 minutes ago       Up 8 minutes                            wizardly_hugle</span><br></pre></td></tr></table></figure><p>当执行 pause 之后容器状态就会变成 Paused，然后可以通过 unpause来恢复到运行状态</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker stop 8538511dbb52</span><br><span class="line">8538511dbb52</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure><p>使用 docker stop 来终止一个运行中的容器，该命令会首先向容器发送 SIGTERM 信号，等待一段超时时间后（默认为 10 秒），再发送 SIGKILL 信号来终止容器。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 －d 参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行 操作。这个时候如果需要进入容器进行操作，我们可以使用 exec 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker exec -it dc138363f794 /bin/bash</span><br><span class="line">root@dc138363f794:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@dc138363f794:/# cd /home/</span><br><span class="line">root@dc138363f794:/home# ls</span><br><span class="line">root@dc138363f794:/home# pwd</span><br><span class="line">/home</span><br><span class="line">root@dc138363f794:/home#</span><br></pre></td></tr></table></figure></p><p>可以看到会打开一个新的 bash 终端，在不影响容器内其他应用的前提下，用户可以与 容器进行交互。</p><p>exec 比较重要的参数如下：</p><blockquote><p>-d, –detach  在容器中后台执行命令<br>–detach-keys=”” 指定将容器切回后台的按键<br>-e, –env=[]  指定环境变量列表<br>-i,–interactive=true|false 打开标准输入接受用户输入命令，默认值为 false<br>– privileged=true|false 是否给执行命令以最高权限，默认值为 false<br>-t, -tty=true|false 分配伪终端， 默认值为 false<br>-u, –user=”” 执行命令的用户名或 ID</p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>我们可以通过 docker rm 命令来删除处于终止或退出状态的容器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker rm -f dc138363f794</span><br><span class="line">dc138363f794</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure></p><blockquote><p>－f, –force=false 是否强行终止并删除一个运行中的容器<br>-l, –link=false  删除容器的连接，但保留容器<br>-v, –volumes=false 删除容器挂载的数据卷</p></blockquote><blockquote><p>执行 docker container prune 命令清除掉所有处于停止状态的容器</p></blockquote><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><p>有时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用 Docker 的导入和导出功能，这也是 Docker 自身提供的一个重要特性。</p><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 home]# docker export -o run_ubuntu_export.tar 8538511dbb52</span><br><span class="line">[root@h244 home]# ls</span><br><span class="line">run_ubuntu_export.tar</span><br><span class="line">[root@h244 home]# docker export 8538511dbb52 &gt; stop_ubuntu_export.tar</span><br><span class="line">[root@h244 home]# ls</span><br><span class="line">run_ubuntu_export.tar  stop_ubuntu_export.tar</span><br></pre></td></tr></table></figure><p>上面两个命令都可以将容器导出</p><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>执行下面命令就可以将导出的 tar 文件导入系统中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 home]# docker import run_ubuntu_export.tar  test/ubuntu:v1</span><br><span class="line">sha256:6dda819276c34cd2a8c6cc7a2f79caa188e5e5d1e432ecad9e8fffa738149d2d</span><br><span class="line">[root@h244 home]# docker images</span><br><span class="line">REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">test/ubuntu                          v1                  6dda819276c3        2 seconds ago       72.8MB</span><br></pre></td></tr></table></figure><p>实际上，既可以使用 docker load 命令来导入镜像存储文件到本地镜像库，也可以使 用 docker [container] import 命令来导入一个容器快照到本地镜像库。这两者的区别在于：容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积更大。此外，从容器快照文件导人时可以重新指定标签等元数据信息。</p><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><h3 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker container inspect 8538511dbb52</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "8538511dbb52c78b7b7b4b1cfa38f981ef484713ad0595fda2647724e12acf90",</span><br><span class="line">        "Created": "2021-08-25T06:30:59.638701387Z",</span><br><span class="line">        "Path": "/bin/sh",</span><br><span class="line">        "Args": [</span><br><span class="line">            "-c",</span><br><span class="line">            "while true; do echo hello world; sleep 1; done"</span><br><span class="line">        ],</span><br><span class="line">        "State": &#123;</span><br><span class="line">            "Status": "running",</span><br><span class="line">            "Running": true,</span><br><span class="line">            "Paused": false,</span><br><span class="line">            "Restarting": false,</span><br><span class="line">            "OOMKilled": false,</span><br><span class="line">            "Dead": false,</span><br><span class="line">            "Pid": 104436,</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Error": "",</span><br><span class="line">            "StartedAt": "2021-08-25T07:57:45.41899904Z",</span><br><span class="line">            "FinishedAt": "2021-08-25T06:40:51.275889779Z"</span><br><span class="line">        &#125;,</span><br><span class="line">        "Image": "sha256:1318b700e415001198d1bf66d260b07f67ca8a552b61b0da02b3832c778f221b"</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>执行 inspect 命令会以 json 格式返回容器 Id、创建时间、路径、状态、镜像、配置等在内的各项信息。</p><h3 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker container top 8538511dbb52</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                97740               104436              0                   09:49               ?                   00:00:00            sleep 1</span><br><span class="line">root                104436              104419              0                   8月25                ?                   00:00:28            /bin/sh -c while true; do echo hello world; sleep 1; done</span><br></pre></td></tr></table></figure><p>docker top 类似于 linux 系统中的 top 命令，会打印出容器内的进程信息，包括 PID、用户、时间、命令等。</p><h3 id="查看统计信息"><a href="#查看统计信息" class="headerlink" title="查看统计信息"></a>查看统计信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker stats --no-stream  8538511dbb52</span><br><span class="line">CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">8538511dbb52        wizardly_hugle      0.18%               304KiB / 7.62GiB    0.00%               656B / 0B           0B / 0B             2</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure><p>docker container stats 命令会显示 CPU、内存、存储、网络等使用情况的统计信息。</p><blockquote><p>-a,-all 输出所有容器统计信息，默认仅在运行中的容器<br>－-format string 格式化输出信息<br>－-no-stream 不持续输出，默认会自动实时刷新数据<br>－-no-trunc 不截断输出信息</p></blockquote><h2 id="主机与容器之间文件复制"><a href="#主机与容器之间文件复制" class="headerlink" title="主机与容器之间文件复制"></a>主机与容器之间文件复制</h2><p>复制文件到容器里<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./text.txt 8538511dbb52:/tmp/</span><br></pre></td></tr></table></figure></p><p>上面这个命令把 text.txt 文件复制到容器里的 tmp 目录下</p><p>从容器里面复制文件到主机上<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 8538511dbb52:/tmp/text.txt ./</span><br></pre></td></tr></table></figure></p><p>上面那个命令把容器里的 text.txt 文件复制到主机的当前目录下。</p><blockquote><p>-a, -archive 打包模式，复制文件会带有原始的 uid/gid 信息<br>-L, -follow-link 跟随软连接。当原路径为软连接时，默认只复制链接信息，使用该选项会复制链接的目标内容。</p></blockquote><h2 id="查看容器文件系统变更"><a href="#查看容器文件系统变更" class="headerlink" title="查看容器文件系统变更"></a>查看容器文件系统变更</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker container diff 8538511dbb52</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/text.txt</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure><p>使用 diff 命令可以查看容器内文件系统的变更。</p><h2 id="查看容器端口映射"><a href="#查看容器端口映射" class="headerlink" title="查看容器端口映射"></a>查看容器端口映射</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@POLY-SERVER:~# docker container port af38a226694e</span><br><span class="line">9555/tcp -&gt; 0.0.0.0:9555</span><br><span class="line">8848/tcp -&gt; 0.0.0.0:8848</span><br></pre></td></tr></table></figure><p>port 命令可以查看容器的端口映射情况</p><h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><p>docker update 命令可以更新容器的一些运行时配置主要是一些资源限制份额。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@h244 ~]# docker update --restart always 8538511dbb52</span><br><span class="line">8538511dbb52</span><br><span class="line">[root@h244 ~]#</span><br></pre></td></tr></table></figure><p>执行上面命令就可以调整容器退出后的重启策略为 always。</p><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1455014-b6b547fe85a2558e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持修改的配置"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）Docker 镜像</title>
      <link href="/docker/docker3/"/>
      <url>/docker/docker3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>镜像是 Docker 三大核心概念中最重要的，Docker 运行容器前需要本地存在对应的镜像， 如果镜像不存在， Docker 会尝试先从默 认镜像仓库下载（默认使用 Docker Hub 公共注册服务器中的仓库）， 用户也可以通过配置，使用自定义的镜像仓库。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像 [imge] 代表可以省略</span></span><br><span class="line">docker [image] pull IMAGE_NAME:TAG</span><br></pre></td></tr></table></figure><p>通过上面的命令就可以从Docker镜像源拉取镜像了，其中IMAGE_NAME是镜像名称，TAG是镜像的标签。如果不指定TAG的话，默认是latest</p><blockquote><p>docker pull IMAGE_NAME:TAG 其实相当于 docker pull registry.hub.docker.com/IMAGE_NAME:TAG命令，即从官方的镜像仓库拉取镜像。如果想从非官方仓库拉取镜像的话，此时应该改为<br>非官方仓库地址_URL/IMAGE_NAME:TAG</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pull子命令支持的选项主要包括:</span></span><br><span class="line">-a, --all-tags=true|false 是否获取仓库中所有镜像，默认为否</span><br><span class="line">--disable-content-trust 取消镜像的内容校验，默认为真</span><br><span class="line">--registry-mirror=proxy_URL 可以指定镜像代理服务器地址来加速Docker镜像拉取过程</span><br></pre></td></tr></table></figure><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><p>docker images或docker image ls命令可以列出本地已有镜像基本信息</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-a1a040911eddb80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## images 子命令主要支持如下选项</span><br><span class="line"> -a, --all=true|false 列出所有(包括临时文件)镜像文件，默认为否</span><br><span class="line"> --digests=true|false 列出镜像的数字摘要值，默认为否</span><br><span class="line"> -f，--filter=[] 过滤列出的镜像，如dangling=true只显示悬虚镜像</span><br><span class="line">--format=&quot;&#123;&#123;.ID&#125;&#125;  &#123;&#123;.Repository&#125;&#125; &#123;&#123;.CreatedSince&#125;&#125;  &#123;&#123;.CreatedAt&#125;&#125;&quot; 控制输出格式</span><br><span class="line">--no-trunc=true|false 对输出结果太长的部分是否进行截断，默认为真</span><br><span class="line">-q, --quiet=ture|false 仅输出ID信息，默认为否</span><br></pre></td></tr></table></figure><h3 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h3><p>为了方便区分镜像，可以使用tag命令来为本地镜像任意的添加新的标签。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag mysql:latest yuxuan:1.0</span><br></pre></td></tr></table></figure></p><h3 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h3><p>使用inspect命令可以获取该镜像的详细信息，包括制作者，适应架构，各层的数字摘要等<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect mysql:latest</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 返回的信息比较多，可以通过-f来过滤</span></span></span><br><span class="line">docker inspect -f "&#123;&#123;.Architecture&#125;&#125; &#123;&#123;.Size&#125;&#125; &#123;&#123;.Metadata&#125;&#125;"  mysql:latest</span><br></pre></td></tr></table></figure></p><h3 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h3><p>使用history命令可以列出镜像各层的创建信息。<br><img src="https://upload-images.jianshu.io/upload_images/1455014-672920db0a5b74f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>使用 docker search 命令可以搜索 Docker Hub 官方仓库中的镜像。 语法为 docker search [option] keyword。支持的命令选项主要包括：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f,--filter 过滤输出内容；</span><br><span class="line">--format 格式化输出内容</span><br><span class="line">--limit：限制输出结果个数， 默认为 25</span><br><span class="line">--no-trunc: 不截断输出结果</span><br></pre></td></tr></table></figure></p><h3 id="删除和清理镜像"><a href="#删除和清理镜像" class="headerlink" title="删除和清理镜像"></a>删除和清理镜像</h3><p>使用 docker rmi 或 docker image rm 命令可以删除镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi mysql:lastest</span><br><span class="line">支持选项有：</span><br><span class="line">-f, -force 强制删除镜像，及时有容器依赖它</span><br><span class="line">-no-prune 不要清理未带标签的父镜像</span><br></pre></td></tr></table></figure></p><p>使用Docker一段时间，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过docker image prune命令来进行清理。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：基于已有镜像的容器创建、 基于本地模板导入、 基于Dockerfile创建。</p><h3 id="基于已有容器创建"><a href="#基于已有容器创建" class="headerlink" title="基于已有容器创建"></a>基于已有容器创建</h3><p>该方法主要是使用 docker [container] commit 命令。<br>命令格式为 docker [container] commit [OPTIONS] CONTAINER IMAGE_NAME:TAG<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要选项包括：</span><br><span class="line">-a, --author="" 作者信息</span><br><span class="line">-c, --change=[] 提交的时候执行 Dockerfile 指令,包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等</span><br><span class="line">-m,--message="" 提交消息</span><br><span class="line">-p, --pause=true 提交时暂停容器运行</span><br></pre></td></tr></table></figure></p><h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>用户也可以直接从一个操作系统模板文件导入一个镜像， 主要使用 docker [container] import命令。格式为 docker [image] import [OPTIONS] file|URL|  IMAGE_NAME:TAG</p><h3 id="基于Dockerfile创建"><a href="#基于Dockerfile创建" class="headerlink" title="基于Dockerfile创建"></a>基于Dockerfile创建</h3><p>基于 Dockerfile 创建是最常见的方式。 Dockerfile 是一个文本文件， 利用给定的指令描述基于某个父镜像创建新镜像的过程。具体命令docker build</p><h2 id="存入和载入镜像"><a href="#存入和载入镜像" class="headerlink" title="存入和载入镜像"></a>存入和载入镜像</h2><h3 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h3><p>如果要导出镜像到本地文件，可以使用docker save命令。该命令支持-o,-output string参数，导出镜像到指定文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ./yuxuan.tar hub.c.163.com/library/redis:3.2</span><br></pre></td></tr></table></figure></p><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用 docker [image] load 将导出的 tar 文件再导人到本地镜像库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i ***.tar</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）Centos 安装 Docker</title>
      <link href="/docker/docker2/"/>
      <url>/docker/docker2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Centos安装过程"><a href="#Centos安装过程" class="headerlink" title="Centos安装过程"></a>Centos安装过程</h1><blockquote><p>Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。<br>社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。<br>社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。</p></blockquote><h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><blockquote><p>由于国内网络问题，我们可以设置阿里云yum源来加快速度<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">## 2. 可以查看所有仓库中所有docker版本，并选择特定版本安装</span><br><span class="line">```shell</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 直接安装默认版本</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span> 安装指定版本</span><br><span class="line">sudo yum install docker-ce-version号 docker-ce-cli-version号 containerd.io</span><br></pre></td></tr></table></figure><h2 id="4-设置Docker开机自启并启动"><a href="#4-设置Docker开机自启并启动" class="headerlink" title="4. 设置Docker开机自启并启动"></a>4. 设置Docker开机自启并启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; sudo systemctl start docker</span><br></pre></td></tr></table></figure><blockquote><p>docker安装时默认创建了docker用户组，将普通用户加入docker用户组就可以不使用sudo来操作docker<br>sudo usermod -aG docker 用户名 //注:添加用户组之后要退出重新登录才会生效</p></blockquote><p>#镜像加速<br>只要是外国的东西在国内基本都很难有好的速度，所有就有了加速器的概念，目前国内常用的如下：</p><ul><li>阿里云：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li><li>USTC：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></li><li>daocloud：<a href="http://get.daocloud.io/" target="_blank" rel="noopener">http://get.daocloud.io/</a></li><li>网易：<a href="https://c.163.com" target="_blank" rel="noopener">https://c.163.com</a></li><li>时速云：<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">https://hub.tenxcloud.com/</a></li><li>灵雀云：<a href="https://hub.alauda.cn/" target="_blank" rel="noopener">https://hub.alauda.cn/</a></li><li>推荐优先阿里云，然后是 USTC</li><li>我下面的讲解也是基于阿里云加速</li><li>阿里云的服务需要注册账号，<strong>首次使用需要设置 docker 登录密码（阿里云叫做：</strong>修改Registry登录密码<strong>），这个以后用私人仓库会用到。</strong></li><li>如果忘记了，后面可以在这里修改：<a href="https://cr.console.aliyun.com/#/imageList" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/imageList</a></li><li>注册后请访问：<a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a>，你会看到专属的加速地址，比如我是：<code>https://a4jvbfkt.mirror.aliyuncs.com</code>，所以下面文章你看到该地址都表示是这个专属地址，请记得自己更换自己的。</li><li>以及教你如何使用 Docker 加速器。如果你已经安装了最新版的 Docker 你就不需要用它的脚本进行安装了。</li><li>最新版本的 Docker 是新增配置文件：<code>vim /etc/docker/daemon.json</code>，增加如下内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [<span class="string">"https://a4jvbfkt.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">```<span class="comment"># Centos安装过程</span></span><br><span class="line">&gt;Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。</span><br><span class="line">社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。</span><br><span class="line">社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 安装依赖</span></span><br><span class="line">```shell</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><blockquote><p>由于国内网络问题，我们可以设置阿里云yum源来加快速度<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">## 2. 可以查看所有仓库中所有docker版本，并选择特定版本安装</span><br><span class="line">```shell</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-安装Docker-1"><a href="#3-安装Docker-1" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接安装默认版本</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本</span></span><br><span class="line">sudo yum install docker-ce-version号 docker-ce-cli-version号 containerd.io</span><br></pre></td></tr></table></figure><h2 id="4-设置Docker开机自启并启动-1"><a href="#4-设置Docker开机自启并启动-1" class="headerlink" title="4. 设置Docker开机自启并启动"></a>4. 设置Docker开机自启并启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; sudo systemctl start docker</span><br></pre></td></tr></table></figure><blockquote><p>docker安装时默认创建了docker用户组，将普通用户加入docker用户组就可以不使用sudo来操作docker<br>sudo usermod -aG docker 用户名 //注:添加用户组之后要退出重新登录才会生效</p></blockquote><p>#镜像加速<br>只要是外国的东西在国内基本都很难有好的速度，所有就有了加速器的概念，目前国内常用的如下：</p><ul><li>阿里云：<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a></li><li>USTC：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></li><li>daocloud：<a href="http://get.daocloud.io/" target="_blank" rel="noopener">http://get.daocloud.io/</a></li><li>网易：<a href="https://c.163.com" target="_blank" rel="noopener">https://c.163.com</a></li><li>时速云：<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">https://hub.tenxcloud.com/</a></li><li>灵雀云：<a href="https://hub.alauda.cn/" target="_blank" rel="noopener">https://hub.alauda.cn/</a></li><li>推荐优先阿里云，然后是 USTC</li><li>我下面的讲解也是基于阿里云加速</li><li>阿里云的服务需要注册账号，<strong>首次使用需要设置 docker 登录密码（阿里云叫做：</strong>修改Registry登录密码<strong>），这个以后用私人仓库会用到。</strong></li><li>如果忘记了，后面可以在这里修改：<a href="https://cr.console.aliyun.com/#/imageList" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/imageList</a></li><li>注册后请访问：<a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">https://cr.console.aliyun.com/#/accelerator</a>，你会看到专属的加速地址，比如我是：<code>https://a4jvbfkt.mirror.aliyuncs.com</code>，所以下面文章你看到该地址都表示是这个专属地址，请记得自己更换自己的。</li><li>以及教你如何使用 Docker 加速器。如果你已经安装了最新版的 Docker 你就不需要用它的脚本进行安装了。</li><li>最新版本的 Docker 是新增配置文件：<code>vim /etc/docker/daemon.json</code>，增加如下内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [<span class="string">"https://a4jvbfkt.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）初识 Docker 与容器</title>
      <link href="/docker/docker1/"/>
      <url>/docker/docker1/</url>
      
        <content type="html"><![CDATA[<p>Docker 是基于 Go 语言实现的开源容器项目，主要用于创建、管理和编排容器。 它诞生于 2013 年年初，最初是由一家名为 dotCloud 的公司利用 Linux 容器技术开发的一套内部工具。自开源后受到业界广泛的关注与参与，dotCloud 公司也随之快速发展壮大， 在 2013 年年底直接改名为 Docker Inc，并专注于 Docker 相关技术和产品的开发，目前已经成为全球最大的 Docker 容器服务提供商。</p><p>Docker 的构想是要实现“ Build, Ship and Run Any App, Anywhere ”，即通过对应用的封装（Packaging）、分发（ Distribution ）、部署（ Deployment）、运行（ Runtime ）生命周期进行管 理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件， 既可以是一个 Web 应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。基于 Linux 平台上的多项开源技术，Docker 提供了高效、敏捷和轻量级的容器方案， 并支持部署到本地环境和多种主流云平台。可以说，Docker 首次为应用的开发、运行和部署提供了“一站式”的实用解决方案。</p><p>在 LXC 的基础上， Docker 进一步优化了容器的使用体验，让它进入寻常百姓家。首先，Docker 提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器；其次，Docker 通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大地改善了用户体验。用户操作 Docker 容器就像操作应用自身一样简单。</p><p>早期的 Docker 代码实现是直接基于 LXC 的。自 0.9 版本开始，Docker 开发了 libcontainer 项目作为更广泛的容器驱动实现，从而替换掉了 LXC 的实现。目前，Docker 还积极推动成立了 rune 标准项目，井贡献给开放容器联盟，试图让容器的支持不再局限于 Linux 操作系统，而是更安全、更开放、更具扩展性。</p><h2 id="Docker-运行时与编排引擎"><a href="#Docker-运行时与编排引擎" class="headerlink" title="Docker 运行时与编排引擎"></a>Docker 运行时与编排引擎</h2><p>多数技术人员在谈到 Docker 时，主要是指 Docker 引擎。Docker 引擎是用于运行和编排容器的基础设施工具。有 VMware 管理经验的读者可以将其类比为 ESXi。ESXi 是运行虚拟机的核心管理程序，而 Docker 引擎是运行容器的核心容器运行时。</p><p>Docker 引擎主要有两个版本:企业版 (EE) 和社区版 (CE)。<br>每个季度，企业版和社区版都会发布一一个稳定版本。社区版本会提供 4 个月的支持，而企业版本会提供 12 个月的支持。<br>社区版还会通过 Edge 方式发布月度版。</p><h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><p>对开发和运维（ DevOps ）人员来说，最梦寐以求的效果可能就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行，而 Docker 恰恰是可以实现这一终极目标的“瑞士军刀”。具体说来，在开发和运维过程中，Docker 具有如下几个方面的优势：</p><ul><li>更快速的交付和部署：使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。</li><li>更高效的资源利用：运行 Docker 容器不需要额外的虚拟化管理程序的支持，Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</li><li>更轻松的迁移和扩展：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。</li><li>更简单的更新管理：使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</li></ul><p>Docker 容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得“很薄的”容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。当然，在隔离性方面，传统的虚拟机方式提供的是相对封闭的隔离。但这并不意味着 Docker 不安全。 Docker利用 Linux 系统上的多种防护技术实现了严格的隔离可靠性， 并且可以整合众多安全工具。从 1.3.0 版本开始，Docker重点改善了容器的安全控制和镜像的安全机制，极大地提高了使用 Docker 的安全性。Docker 在运行应用上跟传统的虚拟机方式相比具有如下：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动速度</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">较弱</td></tr><tr><td style="text-align:center">内存代价</td><td style="text-align:center">很小</td><td style="text-align:center">较多</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为MB</td><td style="text-align:center">一般为GB</td></tr><tr><td style="text-align:center">运行密度</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr><tr><td style="text-align:center">隔离性</td><td style="text-align:center">安全隔离</td><td style="text-align:center">完全隔离</td></tr><tr><td style="text-align:center">迁移性</td><td style="text-align:center">优秀</td><td style="text-align:center">一般</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（四）Spring Cloud Feign 服务远程调用</title>
      <link href="/springcloud/springcloud4/"/>
      <url>/springcloud/springcloud4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="OpenFeign-简介"><a href="#OpenFeign-简介" class="headerlink" title="OpenFeign 简介"></a>OpenFeign 简介</h2><p>微服务提倡将一个原本独立的系统分成众多小型服务系统，这些小型服务系统都在独立的进程中运行，通过各个小型服务系统之间的协作来实现原本独立系统的所有业务功能。拆分后的微服务系统使用多种跨进程的方式进行通信协作，在使用 Spring Cloud 开发微服务应用时，各个服务提供者都是以 HTTP 接口的形式对外提供服务，因此在服务消费者调用服务提供者时，底层通过 HTTP Client 的方式访问。当然我们可以使用 JDK 原生的 URLConnection 、 Apache 的 HTTP Client 、 Netty 的异步 HTTP Client , Spring 的 RestTemplate 去实现服务间的调用。 但是最方便、最优雅的方式是通过 Spring Cloud Open Feign 进行服务间的调用。Spring Cloud 对Feign 进行了增强，使 Feign 支持 Spring MVC 的注解，并整合了 Ribbon 等，从而让 Feign 的使用更加方便。</p><h2 id="什么是-OpenFeign"><a href="#什么是-OpenFeign" class="headerlink" title="什么是 OpenFeign"></a>什么是 OpenFeign</h2><p>OpenFeign 是一个声明式 HTTP 网络请求客户端。 OpenFeign 提供了HTTP 请求的模板，通过编写简单的接口和插入注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。Feign 会完全代理 HTTP 请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。Spring Cloud 对 Feign 进行了封装，使其支持 SpringMVC 标准注解和 HttpMessageConverters。OpenFeign 主要特性如下：</p><ul><li>可插拔的注解支持， 包括 Feign 注解和 JAX-RS 注解。</li><li>支持可插拔的 HTTP 编码器和解码器。</li><li>支持 Hystrix 和它的 Fallback。</li><li>支持 Ribbon 的负载均衡。</li><li>支持 HTTP 请求和响应的压缩 。</li></ul><h2 id="使用-OpenFeign"><a href="#使用-OpenFeign" class="headerlink" title="使用 OpenFeign"></a>使用 OpenFeign</h2><p>在 Spring Cloud 中集成 OpenFeign 的步骤很简单，首先还是先引入依赖，代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在启动类上添加 @EnableFeignClients 注解，如果 Feign 接口定义和启动类不在同一个路径下，还需要通过 basePackages 来指定扫描的包名。@EnableFeignClients 就像是一个开关，只有使用了该注解，OpenFeign 相关组件和配置机制才会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = <span class="string">"com.yuxuan"</span>)</span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Feign-调用接口"><a href="#使用-Feign-调用接口" class="headerlink" title="使用 Feign 调用接口"></a>使用 Feign 调用接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单服务远程调用客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"order-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/add"</span>)</span><br><span class="line">    <span class="function">String <span class="title">addOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@FeignClient 注解就是用来标记该接口是一个 Feign 远程调用客户端，value 属性对应的是服务名称，代表需要调用那个服务中的接口<br>FeignClient 注解的常用属性如下：</p><ul><li>name：指定 FeignClient 的名称，如果项目使用了 Ribbon, name 属性会作为微服务的名称，用于服务发现。</li><li>url：url 一般用于调试，可以于动指定＠FeignClient 调用的地址。</li><li>decode404： 当发生 404 错误时，如果该字段为 true，会调用 decoder 进行解码，否则抛出 FeignException。</li><li>configuration：Feign 配置类，可以自定义 Feign 的 Encoder、 Decoder、 LogLevel 、 Contract。</li><li>fallback：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback 指定的类必须实现 ＠FeignClient 标记的接口。</li><li>fallbackFactory：工厂类，用于生成 fallback 类实例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。</li><li>path：定义当前 FeignClient 的统一前缀。</li></ul><h3 id="自定义-Feign-的配置"><a href="#自定义-Feign-的配置" class="headerlink" title="自定义 Feign 的配置"></a>自定义 Feign 的配置</h3><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>有时候遇到接口调用失败，参数没收到等问题，或者想看看调用性能。这个时候就需要配置 Feign 的日志级别，让 Feign 把请求信息输出到日志中。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志级别</span></span><br><span class="line"><span class="comment">     * NONE: 不输出日志</span></span><br><span class="line"><span class="comment">     * BASIC: 只输出请求方法的 URL 和响应的状态码以及接口执行的时间</span></span><br><span class="line"><span class="comment">     * HEADERS：将 BASIC 信息和请求头信息输出</span></span><br><span class="line"><span class="comment">     * FULL：输出完整的请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在 @FeignClient 注解中指定使用的配置类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"order-service"</span>,configuration = FeignConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/add"</span>)</span><br><span class="line">    <span class="function">String <span class="title">addOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在配置文件中指定 Client 类的日志级别,格式为”logging.level.client类路径”<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      yuxuan:</span></span><br><span class="line"><span class="attr">        feign:</span></span><br><span class="line"><span class="attr">          OrderClient:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></p><blockquote><p>FeignConfig 类上如果添加 @Configuration 注解，则不需要在 Client 上再次指定配置类，默认会作用到所有的 FeignClien 上</p></blockquote><h4 id="契约配置"><a href="#契约配置" class="headerlink" title="契约配置"></a>契约配置</h4><p>Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。如果想在 Spring Cloud 中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Basic-认证配置"><a href="#Basic-认证配置" class="headerlink" title="Basic 认证配置"></a>Basic 认证配置</h4><p>通常调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，比如 Basic 认证方式。在 Feign 中我们可以直接配置 Basic 认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>,<span class="string">"password"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以自定义请求拦截器，通过实现 RequestInterceptor 接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * feign 请求拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yuxuan</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerFeignInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时时间配置"><a href="#超时时间配置" class="headerlink" title="超时时间配置"></a>超时时间配置</h4><p>Feign 的调用分两层，Ribbon 调用和 Hystrix 的调用，高版本的 Hystrix 默认是关闭的。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-ea33af5cfac56fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果出现上面报错信息，代表 Ribbon 处理超时，添加 Ribbon 配置即可：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">2000</span>  <span class="comment">#请求连接的超时时间</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">5000</span>  <span class="comment">#请求处理的超时时间</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-4015876b63ff599b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果出现上面报错信息，则代表 Hystrix 超时报错，设置 Hystrix 配置即可：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">feign</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  shareSecurityContext:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      circuitBreaker:</span></span><br><span class="line"><span class="attr">        sleepWindowInMilliseconds:</span> <span class="number">100000</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure></p><p>通过 Options 可以配置连接超时时间和读取超时时间，Options 的第一个参数是连接超时时间(ms)，默认值是 10 × 1000 ； 第二个是取超时时间(ms)，默认 60 × 1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Request.Options options()&#123;</span><br><span class="line">    return new Request.Options(5000,10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端组件配置"><a href="#客户端组件配置" class="headerlink" title="客户端组件配置"></a>客户端组件配置</h4><p>Feign 中默认使用 JDK 原生的 URLConnection 发送 HTTP 请求，我们可以集成别的组件来替换掉 URLConnection，比如 Apache HttpClient, OkHttp。</p><p>配置 OkHttp 只需要加入 OkHttp 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置，将 Feign 的 HttpClient 禁用，启用 OkHttp</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  httpclient:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  okhttp:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>关于配置可参考源码 org.springframework.cloud.openfeign .FeignAutoConfiguration</p></blockquote><p>添加配置之后就会创建默认的 OkHttpClient 对象，当然也可以构建自定义的 OkHttpClient，代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(Feign.class)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(FeignAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignOkHttpConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> okhttp3.<span class="function">OkHttpClient <span class="title">okHttpClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> okhttp3.OkHttpClient.Builder()</span><br><span class="line">                <span class="comment">//连接超时时间</span></span><br><span class="line">                .connectTimeout(<span class="number">60</span>,TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//读超时时间</span></span><br><span class="line">                .readTimeout(<span class="number">60</span>,TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//写超时时间</span></span><br><span class="line">                .writeTimeout(<span class="number">60</span>,TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//是否自动重连</span></span><br><span class="line">                .retryOnConnectionFailure(<span class="keyword">true</span>)</span><br><span class="line">                .connectionPool(<span class="keyword">new</span> ConnectionPool())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="GZIP-压缩配置"><a href="#GZIP-压缩配置" class="headerlink" title="GZIP 压缩配置"></a>GZIP 压缩配置</h4><p>开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP 来压缩数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line">      <span class="comment">##开启请求数据压缩</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">## 指定压缩类型</span></span><br><span class="line"><span class="attr">      mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">      <span class="comment">## 最小压缩值</span></span><br><span class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line">     <span class="comment">##开启响应数据压缩</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>只有当 Feign 的 HttpClient 不是 okhttp3 的时候，压缩才会生效，配置源码在 org.springframework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration<br>核心代码就是 @ConditionalOnMissingBean(type = “okhttp3.OkHttpClient”) 表示 Spring BeanFactory 中不包含指定的 bean 时条件匹配， 也就是没有启用 okhttp3 时才会进行压缩配置。</p></blockquote><h4 id="配置文件自定义-Feign-的配置"><a href="#配置文件自定义-Feign-的配置" class="headerlink" title="配置文件自定义 Feign 的配置"></a>配置文件自定义 Feign 的配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 链接超时时间</span><br><span class="line">feign.client.config.feignName.connectTimeout=5000</span><br><span class="line"># 读取超时时间</span><br><span class="line">feign.client.config.feignName.readTimeout=5000</span><br><span class="line"># 日志等级</span><br><span class="line">feign.client.config.feignName.loggerLevel=full</span><br><span class="line"># 重试</span><br><span class="line">feign.client.config.feignName.retryer=com.example.SimpleRetryer</span><br><span class="line"># 拦截器</span><br><span class="line">feign.client.config.feignName.requestInterceptors[0]=com.example.FooRequestInterceptor</span><br><span class="line">feign.client.config.feignName.requestInterceptors[1]=com.example.BarRequestInterceptor</span><br><span class="line"># 编码器</span><br><span class="line">feign.client.config.feignName.encoder=com.example.SimpleEncoder</span><br><span class="line"># 解码器</span><br><span class="line">feign.client.config.feignName.decoder=com.example.SimpleDecoder</span><br><span class="line"># 契约</span><br><span class="line">feign.client.config.feignName.contract=com.example.SimpleContract</span><br></pre></td></tr></table></figure><blockquote><p>feignName 需要替换成指定的 feignclient 名称</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（五）Spring Cloud Hystrix 服务熔断</title>
      <link href="/springcloud/springcloud5/"/>
      <url>/springcloud/springcloud5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在分布式系统下，微服务之间不可避免地会发生相互调用，但是没有一个系统能够保证自身运行的绝对正确。微服务在调用过程中，很可能会面临依赖服务失效的问题，这些问题的发生有很多原因，有可能是因为微服务之间的网络通信出现较大的延迟，或者是被调用的微服务发生了调用异常，还有可能是因为依赖的微服务负载过大无法及时响应请求等 。总而言之服务若在调用时出现故障会导致连 锁效应，也就是可能会让整个系统变得不可用，这种情况我们称之为服务雪崩效应。</p><p>Hystrix 是 Netflix 针对微服务分布式系统采用的熔断保护中间件，相当于电路中的保险丝。它能够在依赖服务失效的情况下，通过隔离系统依赖服务的方式，防止服务级联失败；同时 Hystrix 提供失败回滚机制，使系统能够更快地从异常中恢复。这样可以阻止故障的连锁效应，能够让接口调用快速失败并迅速恢复正常，或者回退并优雅降级。</p><p>spring-cloud-netflix-hystrix 对 Hystrix 进行封装和适配，使 Hystrix 能够更好地运行于 Spring Cloud 环境中，为微服务间的调用提供强有力的容错机制。</p><h2 id="Spring-Cloud-Hystrix-简单使用"><a href="#Spring-Cloud-Hystrix-简单使用" class="headerlink" title="Spring Cloud Hystrix 简单使用"></a>Spring Cloud Hystrix 简单使用</h2><p>添加 Hystrix 依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在启动类上添加 @EnableHystrix 或者 @EnableCircuitBreaker 注解</p><blockquote><p>@EnableHystrix 中包含了 @EnableCircuitBreaker</p></blockquote><p>编写一个接口，在上面增加一个 @HystrixCommand 注解，用于指定调用延迟或失败时调用的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"defalutHello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">defalutHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fail hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用失败触发熔断是就是调用 defalutHello 方法来回退具体的内容。</p><h3 id="Feign-整合-Hystrix"><a href="#Feign-整合-Hystrix" class="headerlink" title="Feign 整合 Hystrix"></a>Feign 整合 Hystrix</h3><p>OpenFeign 中自带 Hystrix，但是默认没有打开，需要添加如下配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">    hystrix:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="fallback-方式"><a href="#fallback-方式" class="headerlink" title="fallback 方式"></a>fallback 方式</h4><p>在 Feign 的客户端类上的＠FeignClient 注解中指定 fallback 进行回退。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"order-service"</span>, fallback = OrderClientFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/add"</span>)</span><br><span class="line">    <span class="function">String <span class="title">addOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientFallback</span> <span class="keyword">implements</span> <span class="title">OrderClient</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FallbackFactory-方式"><a href="#FallbackFactory-方式" class="headerlink" title="FallbackFactory 方式"></a>FallbackFactory 方式</h3><p>通过 fallback 可以实现服务不可用时回退的功能，但如果想知道触发回退的原因，可以使用 FallbackFactory 来实现回退功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"order-service"</span>, fallbackFactory = OrderClientFallbackFactory.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/add"</span>)</span><br><span class="line">    <span class="function">String <span class="title">addOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">OrderClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderClient <span class="title">create</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">addOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hystrix-监控"><a href="#Hystrix-监控" class="headerlink" title="Hystrix 监控"></a>Hystrix 监控</h2><p>在微服务架构中，Hystrix 除了实现容错外，还提供了实时监控功能。在服务调用时 Hystrix 会实时累积关于 HystrixCommand 的执行信息，比如每秒的请求数、成功数等。 </p><blockquote><p>更多的指标信息请查看官方文档：<a href="https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring</a></p></blockquote><p>Hystrix 监控需要两个必备条件:</p><ul><li>必须有 Actuator 的依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>必须有 Hystrix 的依赖,切必须添加 ＠EnableHystrix 开启 Hystrix</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放开 hystrix 监控数据访问端点:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">hystrix.stream</span></span><br></pre></td></tr></table></figure></p><p>访问端点地址：<a href="http://localhost:9010/actuator/hystrix.stream" target="_blank" rel="noopener">http://localhost:9010/actuator/hystrix.stream</a><br>可以看到一直在输出“ ping ： ”，出现这种情况是因为还没有数据，等 HystrixCommand 执行了之后就可以看到具体数据了。</p><h3 id="整合-Dashboard-查看监控数据"><a href="#整合-Dashboard-查看监控数据" class="headerlink" title="整合 Dashboard 查看监控数据"></a>整合 Dashboard 查看监控数据</h3><p>Hystrix 提供了监控的功能，可以通过 hystrix.stream 端点来获取监控 数据 ，但是这些数据是以字符串的形式展现的，实际使用中不方便查看。我们可以借助 hystrix-dashboard 对监控进行图形化展示。</p><p>新建一个项目，然后添加以下依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在启动类中添加如下注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure></p><p>在属性配置文件中只需要配置服务名称和服务端口：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">hystrix-monitor-demo</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure></p><p>然后启动服务，访问 <a href="http://localhost:8081/hystrix，就可以看到" target="_blank" rel="noopener">http://localhost:8081/hystrix，就可以看到</a> dashboard 页面，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-1b96207cf1ee0676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在页面上有三个地方可以填写：</p><ul><li>第一行是监控的 stream 地址<ul><li>默认集群监控，通过 <a href="http://turbine-hostname:port/turbine.stream" target="_blank" rel="noopener">http://turbine-hostname:port/turbine.stream</a> 访问。</li><li>指定集群监控: <a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]" target="_blank" rel="noopener">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</a></li><li>单个应用监控：<a href="http://hystrix-app:port/hystrix.stream" target="_blank" rel="noopener">http://hystrix-app:port/hystrix.stream</a></li></ul></li><li>delay 时间，表示用多少毫秒同步一次监控信息</li><li>title 标题，随便填写</li></ul><p>我们把前面创建的 hystrix 应用的监控地址填入，然后点击监控</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-ef76cbc90ed5102a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>圆圈： 代表流量的大小和流量的健康，有绿色，黄色，橙色，红色，通过这些颜色的标识，可以快速发现故障，具体的实例，请求压力等。</li><li>曲线：代表 2 分钟内流量的变化，可以根据它发现请求的浮动趋势。</li><li>左边的7个数字：<ul><li>绿色：请求成功数</li><li>黄色：超时的请求数</li><li>深蓝色：熔断数</li><li>紫色：线程池拒绝数</li><li>天蓝色：错误的请求数</li><li>红色：失败的请求数</li><li>灰色：最近 10 秒内错误的比率</li></ul></li><li>Host&amp;Cluster：代表机器和集群的请求频率</li><li>Circuit：断路器状态，open/closed</li><li>Hosts&amp;Median&amp;Mean： 集群下的报告，百分位延迟数。</li><li>Thread Pools: 线程池的指标，核心线程池指标，队列大小等。</li></ul><h2 id="Turbine-聚合-Hystrix"><a href="#Turbine-聚合-Hystrix" class="headerlink" title="Turbine 聚合 Hystrix"></a>Turbine 聚合 Hystrix</h2><p>上面尝试了单个实例的 Hystrix Dashboard，但在整个系统和集群的情况下不是特别有用，所以需要一种方式来聚合整个集群下的监控状况，Turbine 就是来聚合所有相关的 hystrix.stream 流的方案， 然后在 Hystrix Dashboard 中显示。</p><p>继续在上面 hystrix-dashboard 工程上改造。首先添加 Turbine 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line">    <span class="comment">## 需要聚合的服务名称，多个逗号隔开</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">feign-demo</span></span><br><span class="line">  <span class="comment">## 需要聚合的集群名称 </span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">"'default'"</span></span><br></pre></td></tr></table></figure><blockquote><p>clusterNameExpression 默认表达式appName，此时：turbine.aggregator.clusterConfig 需要配置想要监控的应用名称(必须大写)<br> 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default<br> 当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</p></blockquote><p>修改启动类添加 ＠EnableTurbine 和 ＠EnableDiscoveryClient 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样咱们就可以使用 <a href="http://localhost:8081/turbine.stream" target="_blank" rel="noopener">http://localhost:8081/turbine.stream</a> 来访问集群的监控数据了。 Turbine 会通过 Eureka 中查找的服务 homePageUrl 加上 hystrix.stream 来获取服务的监控数据。</p><h3 id="context-path-导致监控失败"><a href="#context-path-导致监控失败" class="headerlink" title="context-path 导致监控失败"></a>context-path 导致监控失败</h3><p>如果被监控的服务中设置了 context-path ，则会导致 Turbine 无法获取监控数据。<br>这个时候需要在 Turbine 中指定 turbine.instanceUrlSuffix 来解决这个问题：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">    instanceUrlSuffix:</span> <span class="string">/api/actuator/hystrix.stream</span></span><br></pre></td></tr></table></figure></p><p>上面这种方式是全局配置，会有一个问题，就是一般我们在使用中会用一个集群去监控多个服务，如果每个服务的 context-path 都不一样，这个时候有一些就会出问题，那么就需要对每个服务做一个集群，然后配置集群对应的。</p><p>修改需要监控的服务设置集群名称：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    metadata-map:</span></span><br><span class="line"><span class="attr">      cluster:</span> <span class="string">feign-demo</span></span><br></pre></td></tr></table></figure><p>修改 turbine 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="comment">## 需要聚合的服务名称，多个逗号隔开</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">feign-demo</span></span><br><span class="line">  <span class="comment">## 用于指定集群名称，当服务数量非常多的时候，可以启动多个</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">metadata['cluster']</span></span><br><span class="line"><span class="attr">  aggregator:</span></span><br><span class="line">    <span class="comment">## 多个逗号隔开</span></span><br><span class="line"><span class="attr">    cluster-config:</span> <span class="string">feign-demo</span></span><br><span class="line"><span class="attr">  instanceUrlSuffix:</span></span><br><span class="line"><span class="attr">    feign-demo:</span> <span class="string">/api/actuator/hystrix.stream</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix-异常机制和处理"><a href="#Hystrix-异常机制和处理" class="headerlink" title="Hystrix 异常机制和处理"></a>Hystrix 异常机制和处理</h3><p>Hystrix 的异常处理中，有 5 种出错的情况下会被 fallback 所截获，从而触发 fallback。</p><ul><li>FAILURE：执行失败，抛出异常</li><li>TIMEOUT：执行超时</li><li>SHORT CIRCUITED：断路器打开</li><li>THREAD POOL REJECTED：线程池拒绝</li><li>SEMAPHORE REJECTED：信号量拒绝 。</li></ul><p>有一种类型的异常是不会触发 fallback 且不会被计数进入熔断的，它是 BAD_REQUEST, 会抛出 HystrixBadRequestException，这种异常一般对应的是由非法参数或者一些非系统异常引起的，对于这类异常可以根据响应创建对应的异常进行异常封装或者直接处理</p><h3 id="Hystrix-配置说明"><a href="#Hystrix-配置说明" class="headerlink" title="Hystrix 配置说明"></a>Hystrix 配置说明</h3><h4 id="properties-配置"><a href="#properties-配置" class="headerlink" title="properties 配置"></a>properties 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># hystrix.command.default和hystrix.threadpool.default中的default为默认CommandKey，CommandKey默认值为服务方法名。</span><br><span class="line"># 在properties配置中配置格式混乱，如果需要为每个方法设置不同的容错规则，建议使用yml文件配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Execution相关的属性的配置：</span><br><span class="line"># 隔离策略，默认是Thread, 可选Thread｜Semaphore</span><br><span class="line">hystrix.command.default.execution.isolation.strategy=THREAD</span><br><span class="line">#命令执行超时时间，默认1000ms，只在线程池隔离中有效。</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=1000</span><br><span class="line"># 执行是否启用超时，默认启用true，只在线程池隔离中有效。</span><br><span class="line">hystrix.command.default.execution.timeout.enabled=true</span><br><span class="line"># 发生超时是是否中断，默认true，只在线程池隔离中有效。</span><br><span class="line">hystrix.command.default.execution.isolation.thread.interruptOnTimeout=true</span><br><span class="line"># 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。# 理论上选择semaphore的原则和选择thread一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。# semaphore应该占整个容器（tomcat）的线程池的一小部分。</span><br><span class="line">hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests=10</span><br><span class="line"># 如果并发数达到该设置值，请求会被拒绝和抛出异常并且fallback不会被调用。默认10。# 只在信号量隔离策略中有效，建议设置大一些，这样并发数达到execution最大请求数时，会直接调用fallback，而并发数达到fallback最大请求数时会被拒绝和抛出异常。</span><br><span class="line">hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests=10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ThreadPool 相关参数</span><br><span class="line"># 并发执行的最大线程数，默认10</span><br><span class="line">hystrix.threadpool.default.coreSize=10</span><br><span class="line"># BlockingQueue的最大队列数，当设为-1，会使用SynchronousQueue，值为正时使用LinkedBlcokingQueue。# 该设置只会在初始化时有效，之后不能修改threadpool的queue size，除非reinitialising thread executor。默认-1。</span><br><span class="line">hystrix.threadpool.default.maxQueueSize=-1</span><br><span class="line"># 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝。</span><br><span class="line">hystrix.threadpool.default.queueSizeRejectionThreshold=20</span><br><span class="line"># 线程存活时间，单位是分钟。默认值为1。</span><br><span class="line">hystrix.threadpool.default.keepAliveTimeMinutes=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Fallback相关的属性 </span><br><span class="line"># 当执行失败或者请求被拒绝，是否会尝试调用fallback方法 。默认true hystrix.command.default.fallback.enabled=true # Circuit Breaker相关的属性 # 是否开启熔断器。默认true hystrix.command.default.circuitBreaker.enabled=true # 一个rolling window内最小的请求数。如果设为20，那么当一个rolling window的时间内（比如说1个rolling window是10毫秒）收到19个请求# 即使19个请求都失败，也不会触发circuit break。默认20</span><br><span class="line">hystrix.command.default.circuitBreaker.requestVolumeThreshold=20</span><br><span class="line"># 触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝远程服务调用，也就是5000毫秒后才会重试远程服务调用。默认5000</span><br><span class="line">hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds=5000</span><br><span class="line"># 错误比率阀值，如果错误率&gt;=该值，circuit会被打开，并短路所有请求触发fallback。默认50</span><br><span class="line">hystrix.command.default.circuitBreaker.errorThresholdPercentage=50</span><br><span class="line"># 强制打开熔断器</span><br><span class="line">hystrix.command.default.circuitBreaker.forceOpen=false</span><br><span class="line"># 强制关闭熔断器</span><br><span class="line">hystrix.command.default.circuitBreaker.forceClosed=false</span><br></pre></td></tr></table></figure><h4 id="yaml-配置"><a href="#yaml-配置" class="headerlink" title="yaml 配置"></a>yaml 配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line">    <span class="comment"># default代表全部服务配置，如果为某个具体服务定制配置，使用：'服务接口名#方法名(参数类型列表)'的方式来定义。</span></span><br><span class="line">    <span class="comment"># 如：'FirstClientFeignService#test(int)'。如果接口名称在应用中唯一，可以只写simpleName。</span></span><br><span class="line">    <span class="comment"># 如果接口名称在应用中不唯一，需要写fullName（包名.类名）</span></span><br><span class="line">    <span class="string">"FirstClientFeignService#testFeign()"</span><span class="string">:</span></span><br><span class="line"><span class="attr">      fallback:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> hystrix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）Spring Cloud Eureka 常用配置</title>
      <link href="/springcloud/eureka/springcloud3/"/>
      <url>/springcloud/eureka/springcloud3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="关闭自我保护"><a href="#关闭自我保护" class="headerlink" title="关闭自我保护"></a>关闭自我保护</h2><p>保护模式主要在一组客户端和 Eureka Server 之间存在网络分区场景时使用。一旦进入保护模式，Eureka Server 将会尝试保护其服务的注册表中的信息，不再删除服务注册表中的数据。当网络故障恢复后，该 Eureka Server 节点会自动退出保护模式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">        enable-self-preservation:</span> <span class="literal">false</span> <span class="string">//关闭自我保护</span></span><br></pre></td></tr></table></figure><h2 id="自定义-Eureka-的-InstanceID"><a href="#自定义-Eureka-的-InstanceID" class="headerlink" title="自定义 Eureka 的 InstanceID"></a>自定义 Eureka 的 InstanceID</h2><p>客户端在注册时，服务的 Instance ID 的默认值的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;spring.cloud.client.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application. instance id:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure><p>其实就是“主机名：服务名称：服务端口”</p><p>如果想把主机名替换成 IP</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    instance:</span></span><br><span class="line"><span class="attr">        instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipaddress&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用-IP-进行注册"><a href="#使用-IP-进行注册" class="headerlink" title="使用 IP 进行注册"></a>使用 IP 进行注册</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    instance:</span></span><br><span class="line"><span class="attr">        preferipAddress:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="自定义实例调整链接"><a href="#自定义实例调整链接" class="headerlink" title="自定义实例调整链接"></a>自定义实例调整链接</h2><p>通过配置实现了用 IP 进行注册，当点击 Instance ID 进行跳转的时候， 就可以用 IP 跳转了，跳转的地址默认是 IP+Port/info 。我们可以自定义这个跳转的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        status-page-url: http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/swagger-ui.html</span><br></pre></td></tr></table></figure><h2 id="快速移除已经失效的服务信息"><a href="#快速移除已经失效的服务信息" class="headerlink" title="快速移除已经失效的服务信息"></a>快速移除已经失效的服务信息</h2><p>在实际开发过程中，我们可能会不停地重启服务，由于 Eureka 有自己的保护机制，故节点下线后，服务信息还会一直存在于 Eureka 中。我们可以通过增加一些配置让移除的速度更快一点，当然只在开发环境下使用，生产环境下不推荐使用。<br>首先在 eureka-server 中增加两个配置，分别是关闭自我保护和清理间隔：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">        enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">        eviction-interval-timer-in-ms:</span> <span class="number">5000</span> <span class="comment">## 默认 60000 毫秒</span></span><br></pre></td></tr></table></figure></p><p>然后在客户端服务配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        healthcheck:</span><br><span class="line">            enabled: true ## 开启健康检查</span><br><span class="line">    instance:</span><br><span class="line">        lease-renewal-interval-in-seconds: 5 ##默认 30 秒</span><br><span class="line">        lease-expiration-duration-in-seconds: 5 ##默认 30 秒</span><br></pre></td></tr></table></figure><p>开启健康检查，需要在 pom.xml 中引入 actuator的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>lease-renewal-interval-in-seconds: 表示 Eureka Client 发送心跳给 server 端的频率。</li><li>lease-expiration-duration-in-seconds: 表示 Eureka Server 至上一次收到 client 的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则移除该 Instance</li></ul><blockquote><p>更多的 Instance 配置信息可参考源码中的配置类：org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean<br>更多的 Server 配置信息可参考源码中的配置类：org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean</p></blockquote><h2 id="元数据使用"><a href="#元数据使用" class="headerlink" title="元数据使用"></a>元数据使用</h2><p>Eureka 的元数据有两种类型，分别是框架定好了的标准元数据和用户自定义元数据。标准元数据指的是主机名、IP 地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。自定义元数据可以使用 eureka.instance.metadataMap 进行配置。</p><p>自定义元数据说得通俗点就是自定义配置，我们可以为每个 Eureka Client 定义一些属于自己的配置，这个配置不会影响 Eureka 的功能。自定义元数据可以用来做一些扩展信息，比如灰度发布之类的功能，可以用元数据来存储灰度发布的状态数据，Ribbon 转发的时候就可以根据服务的元数据来做一些处理。当不需要灰度发布的时候可以调用 Eureka 提供的 REST API 将元数据清除掉。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    instance:</span></span><br><span class="line"><span class="attr">        metadataMap:</span></span><br><span class="line"><span class="attr">            version:</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure></p><h3 id="EuekaClient-使用"><a href="#EuekaClient-使用" class="headerlink" title="EuekaClient 使用"></a>EuekaClient 使用</h3><p>当我们的项目中集成了 Eureka 之后，可以通过 EurekaClient 来获取一些我们想要的数据，比如上面提的元数据。我们就可以直接通过 EurekaClient 来获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br></pre></td></tr></table></figure></p><p>除了使用 EurekaClient，还可以使用 DiscoveryClient, 不是Eureka 自带的, 是 Spring Cloud 重新封装的，类的路径为 org.springframework.cloud.client.discovery.DiscoveryClient</p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>默认情况下，Eureka 客户端是使用心跳和服务端通信来判断客户端是否存活，在某些场景下，比如服务对应的数据库出现了异常，但应用进程还是存在的，这意味着服务可以继续上报心跳，但其实此时的服务已经不能够正常提供服务了。</p><p>Spring Boot Actuator 提供了／actuator/health 端点，该端点可展示应用程序的健康信息， 当应用服务异常时，通过扩展健康检查的端点调整健康检查逻辑</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="attr">        healthcheck:</span></span><br><span class="line"><span class="attr">            enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>开启健康检查，在 pom.xml 中引入 actuator的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthindicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">(Builder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务上下线监控"><a href="#服务上下线监控" class="headerlink" title="服务上下线监控"></a>服务上下线监控</h2><p>在某些特定的需求下，我们需要对服务的上下线进行监控，上线或下线都进行邮件通知，Eureka 中提供了事件监昕的方式来扩展 。</p><ul><li>EurekaInstanceCanceledEvent 服务下线事件 。</li><li>EurekaInstanceRegisteredEvent 服务注册事件。 </li><li>EurekaInstanceRenewedEvent 服务续约事件。 </li><li>EurekaRegistryAvailableEvent Eureka 注册中心启动事件。</li><li>EurekaServerStartedEvent Eureka Server 启动事件。</li></ul><p>基于 Eureka 提供的事件机制，可以监控服务的上下线过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaStateChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceCanceledEvent event)</span></span>&#123;</span><br><span class="line">        <span class="comment">//服务下线监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceRegisteredEvent event)</span></span>&#123;</span><br><span class="line">        <span class="comment">//服务注册事件监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceRenewedEvent event)</span></span>&#123;</span><br><span class="line">        <span class="comment">//服务续约事件监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaRegistryAvailableEvent event)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注册中心启动监听</span></span><br><span class="line">        <span class="comment">// 通过查看 EurekaServerInitializerConfiguration 源码 EurekaRegistryAvailableEvent 在 EurekaServerStartedEvent 之前发送</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaServerStartedEvent event)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Eureka Server 启动事件监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）服务注册与发现之 Spring Cloud Eureka</title>
      <link href="/springcloud/eureka/springcloud2/"/>
      <url>/springcloud/eureka/springcloud2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在传统的单体应用中，组件之间的调用通过有规范约束的接口进行，从而实现不同模块间良好协作。在微服务架构中，原本的“巨石”应用按照业务被分割成相对独立的、提供特定功能的微服务，每一个微服务都可以通过集群或者其他方式进行动态扩展，每一个微服务实例的网络地址都可能动态变化，这使得原本通过硬编码地址的调用方式失去了作用。微服务架构中，服务地址的动态变化和数量变动，迫切需要系统建立一个中心化的组件对各个微服务实例信息进行登记和管理，同时让各个微服务实例之间能够互相发现，从而达到互相调用的结果。</p><p>通常来说服务注册与发现包括两部分一个是服务器端，另一个是客户端。Server 是一个公共服务，为 Client 提供服务注册和发现的功能，维护注册到自身的 Client 的相关信息，同时提供接口给 Client 获取注册表中其他服务的信息，使得动态变化的 Client 能够进行服务间的相互调用。Client 将自己的服务信息通过一定的方式登记到 Server 上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过 Server 获取到自己依赖的其他服务信息，完成服务调用。</p><p>Eureka Server 端采用的是 P2P 的复制模式，但是它不保证复制操作一定能成功，因此它提供的是一个最终一致性的服务实例视图。Client 端在 Server 端的注册信息有一个带期限的租约，一旦 Server 端在指定期间没有收到 Client 端发送的心跳，则 Server 端会认为 Client 端注册的服务是不健康的，定时任务会将其从注册表中删除。</p><p>Spring Cloud Netflix Eureka 是 Spring Cloud 提供用于服务发现和注册的基础组件，是搭建 Spring Cloud 微服务架构的前提之一。Eureka 作为一个开箱即用的基础组件，屏蔽了底层 Server 和 Client 交互的细节，使得开发者能够将精力更多地放在业务逻辑上，加快微服务架构的实施和项目的开发。</p><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>搭建一个 Eureka Server 非常简单，创建一个maven项目，添加一个 spring-cloud-starter-netflix-eureka-server 依赖。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>    <span class="comment"># eureka server 没必要自己把自己注册上去，所以可以设置成 false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否从Eureka Server上获取注册信息，默认为true，此处建议修改成 false</span></span><br></pre></td></tr></table></figure><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，访问 <a href="http://localhost:8761" target="_blank" rel="noopener">http://localhost:8761</a> 就会看到如下界面，至此一个简单的 Eureka Server 就搭建好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-bdab176bd8d6e083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>Eureka Server 注册中心已经创建好了，下面我们来创建一个 Eureka Client 注册到 Eureka Server 中。 </p><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">   application:</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动程序-1"><a href="#启动程序-1" class="headerlink" title="启动程序"></a>启动程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动主程序之后，刷新 Eureka Server 界面，会发现服务已经注册上来了，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-c24668ad0aeaa041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Eureka-Server-的-REST-API"><a href="#Eureka-Server-的-REST-API" class="headerlink" title="Eureka Server 的 REST API"></a>Eureka Server 的 REST API</h2><p>Eureka 使用的是 JAVA 语言开发的，但是 Eureka Server 提供 REST API，可以让非 JAVA 语言的其它语言开发的应用服务通过 HTTP REST 的方式注册到 Eureka Server 中。</p><h3 id="REST-API-列表"><a href="#REST-API-列表" class="headerlink" title="REST API 列表"></a>REST API 列表</h3><table><thead><tr><th>功能</th><th>API</th></tr></thead><tbody><tr><td>注册新的应用实例</td><td>POST /eureka/apps/{appId}</td></tr><tr><td>注销应用实例</td><td>DELETE /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>应用实例发送心跳</td><td>PUT /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>查询所有实例</td><td>GET /eureka/apps</td></tr><tr><td>查询指定appId的实例</td><td>GET /eureka/apps/{appId}</td></tr><tr><td>根据指定appId和instanceId查询</td><td>GET /eureka/apps/{appId}/{instanceId}</td></tr><tr><td>根据指定instanceId查询</td><td>GET /eureka/instances/{instanceId}</td></tr><tr><td>暂停应用实例</td><td>PUT /eureka/apps/ {appId}/ {instanceId}/status?value=OUT_OF_SERVICE</td></tr><tr><td>恢复应用实例</td><td>DELETE /eureka/apps/{appId}/{instanceld}/status?value=UP (value参数可不传)</td></tr><tr><td>更新元数据</td><td>PUT /eureka/apps/{appId}/{instanceId}/metadata?key=value</td></tr><tr><td>根据vip地址查询</td><td>GET /eureka/vips/{vipAddress}</td></tr><tr><td>根据svip地址查询</td><td>GET /eureka/svips/{svipAddress}</td></tr></tbody></table><h2 id="Spring-Cloud-Eureka-的核心类"><a href="#Spring-Cloud-Eureka-的核心类" class="headerlink" title="Spring Cloud Eureka 的核心类"></a>Spring Cloud Eureka 的核心类</h2><h3 id="InstanceInfo"><a href="#InstanceInfo" class="headerlink" title="InstanceInfo"></a>InstanceInfo</h3><p>Instancelnfo 类代表注册的服务实例，主要有如下字段：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>instanceId</td><td>实例id</td></tr><tr><td>app</td><td>应用名</td></tr><tr><td>appGroupName</td><td>应用所属群组</td></tr><tr><td>ipAddr</td><td>ip 地址</td></tr><tr><td>port</td><td>端口号</td></tr><tr><td>securePort</td><td>https 的端口号</td></tr><tr><td>homePageUrl</td><td>应用实例的首页 url</td></tr><tr><td>statusPageUrl</td><td>应用实例的状态页 url</td></tr><tr><td>healthCheckUrl</td><td>应用实例健康检查的 url</td></tr><tr><td>secureHealthCheckUrl</td><td>应用实例健康检查的 https 的 url</td></tr><tr><td>vipAddress</td><td>虚拟 ip 地址</td></tr><tr><td>secureVipAddress</td><td>https 的虚拟 ip 地址</td></tr><tr><td>hostName</td><td>主机名称</td></tr><tr><td>status</td><td>实例状态，如 UP、DOWN、STARTING、OUT_OF_SERVICE、UNKNOWN</td></tr><tr><td>overriddenstatus</td><td>外界需要强制覆盖的状态值，默认为 UNKNOWN</td></tr><tr><td>leaselnfo</td><td>租约信息</td></tr><tr><td>metadata</td><td>应用实例的元数据信息</td></tr><tr><td>lastUpdatedTimestamp</td><td>状态信息最后更新时间</td></tr><tr><td>lastDirtyTimestamp</td><td>实例信息最新的过期时间，在 Client 端用于标识该实例信息是否与 Eureka Server 一致，在 Server 端则用于多个 Eureka Server 之间的信息同步处理</td></tr><tr><td>actionType</td><td>标识 Eureka Server 对该实例执行的操作 ，包括 ADDED 、 MODIFIED 、 DELETED 这三类</td></tr><tr><td>asgName</td><td>在 AWS 的 autoscaling group 的名称</td></tr></tbody></table><h3 id="Leaselnfo"><a href="#Leaselnfo" class="headerlink" title="Leaselnfo"></a>Leaselnfo</h3><p>Leaselnfo 类标识应用实例的租约信息，用于标识应用实例的心跳情况，比如约定的心跳周期，租约有效期，最近一次续约的时间，主要有一下字段：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>renewalintervalinSecs</td><td>Client 端续约的间隔周期</td></tr><tr><td>durationlnSecs</td><td>Client 端需要设定的租约的有效时长</td></tr><tr><td>registrationTimestamp</td><td>Server 端设置的该租约的第一次注册时间</td></tr><tr><td>lastRenewalTimestamp</td><td>Server 端设置的该租约的最后一次续约时间</td></tr><tr><td>evictionTimestamp</td><td>Server 端设置的该租约被剔除的时间</td></tr><tr><td>serviceUpTimestamp</td><td>Server 端设置的该服务实例标记为 UP 的时间</td></tr></tbody></table><h3 id="ServiceInstance"><a href="#ServiceInstance" class="headerlink" title="ServiceInstance"></a>ServiceInstance</h3><p>ServiceInstance 是 Spring Cloud 对服务发现的实例信息的抽象接口，因为 Spring Cloud Discovery 适配了 Zookeeper，Consul，Netfix Eureka 等注册中心，所以 ServiceInstance 定义更为抽象和通用。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>getServiceId()</td><td>服务ID</td></tr><tr><td>getHost()</td><td>实例的host</td></tr><tr><td>getPort()</td><td>实例的端口</td></tr><tr><td>isSecure()</td><td>实例是否开启https</td></tr><tr><td>getUri()</td><td>实例的 uri 地址</td></tr><tr><td>getMetadata()</td><td>实例的元数据信息</td></tr><tr><td>getScheme()</td><td>实例的 scheme</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）微服务架构与 Spring Cloud 简介</title>
      <link href="/springcloud/springcloud1/"/>
      <url>/springcloud/springcloud1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>从单体应用架构发展到SOA架构，再到微服务架构，应用架构经历了多年的不断演进。微服务架构不是凭空产生的，而是技术发展的必然结果，分布式云平台的应用环境使得微服务代替单体应用成为互联网大型系统的架构选择。目前，虽然微服务架构还没有公 认的技术标准和规范草案，但业界已经有了一些很有影响力的开源微服务架构解决方案，在进行微服务化开发或改造时可以进行相应的参考。</p><p>目前软件架构有三种架构类型，分别是业务架构、应用架构、技术架构。它们之间的关系是业务架构决定应用架构，技术架构支撑应用架构。架构的发展历程是从单体架构、分布式架构、SOA架构再到微服务架构，如下图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-3a3ff2c6224b631b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h2><p>传统的单体架构在Java领域可以理解为一个Web应用，大部分Web工程都是将所有的功能打包在一起部署和运行。按照程序调用顺序，从上到下为表示层、业务层、数据访问层、DB层。如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/1455014-2fa28cd5b928fbb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为所有的功能模块都是在一个工程编写的，所以从开发和测试的角度来看，开发人员可以在短时间内就开发出单体应用，并且由于没有过多的依赖项，测试也可以节约很多时间。</p><p>但是，随着应用不断的发展，开发团队不断的扩张之后，单体应用的不足和弊端就会很明显的暴露出来，主要有以下不足点：</p><ul><li>灵活度不够：如果程序有任何修改，那么修改的不止一个点，可能需要从上到下地去修改，并且测试的时候必须等到整个程序部署完才能看出效果，并且由于整个开发工作都是在一个工程下进行的，可能需要等待其他开发人员开发完成才能完成部署，大大的降低了团队的灵活性。</li><li>可靠性：一旦出现了bug，影响的将是整个应用。因为所有的模块功能都是运行在一个进程中的。</li><li>复杂性高：单体应用的代码量可能会让团队新来的成员望而生畏，应用难以理解和迭代，从而到时开发速度大大降低。</li><li>系统扩展性差：添加新东西的时候不能针对某个点增加，要全局性增加。</li><li>系统启动慢：一个应用包含了所有功能模块，导致系统的启动时间较长。</li></ul><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>SOA的核心主体是服务，其目标是通过服务的流程化来实现业务的灵活性。服务就像一堆“元器件”，这些元器件通过封装形成标准服务，它们有相同的接口和语义表达规则。但服务要组装成一个流程和应用，还需要有效的“管理”，包括如何注册服务、如何发现服 务、如何包装服务的安全性和可靠性，这些就是SOA治理。SOA治理是将 SOA 的一堆元器件进行有效组装。这是形成一个“产品”的关键，否则那些永远是一堆元器件，而无法形成一个有机整体。<br>完整的SOA架构由五大部分组成：基础设施服务、企业服务总线、关键服务组件、开发工具、管理工具等。</p><ul><li>基础设施：为整个SOA组件和框架提供一个可靠的运行环境，以及服务组件容器，它的核心组件是应用服务器等基础软件支撑设施，提供运行期完整、可靠的软件支撑 。</li><li>企业服务总线：提供可靠消息传输、服务接入、协议转换、数据格式转换、 基于内容的路由等功能，屏蔽了服务的物理位置、协议和数据格式 。</li><li>关键服务组件：SOA在各种业务服务组件的分类。</li><li>开发工具和管理工具：提供完善的、可视化的服务开发和流程编排工具，包括服务的设计、开发、 配置、部署、监控、重构等完整的SOA项目开发生命周期 。</li></ul><p>SOA 架构中有两个主要角色：服务提供者（Provider）和服务消费者（Consumer）。<br>SOA架构的优点：</p><ul><li>把模块拆分， 使用接口通信， 降低模块之间的耦合度。</li><li>把项目拆分成若干个子项目，不同的团队负责不同的子项目。</li><li>增加功能时只需要增加一个子项目，调用其他系统的接口即可。</li><li>可以灵活地进行分布式部署。 </li></ul><p>SOA 架构的缺点：系统之间的交互需要使用远程通信， 接口开发增加工作量 。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务的概率最早是由 Martin Fowler 与 James Lewis 于 2014 年共同提出，需要了解细节的读者可以阅览 <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices</a>。根据其描述，总体来说，微服务是一种架构风格， 对于一个大型复杂的业务系统，它的业务功能可以拆分为多个相互独立的微服务，各个微服务之间是松搞合的，通过各种远程协议进行同步／异步通信，各微服务均可以被独立部署、 扩／缩容以及升／降级。这些服务是基于业务逻辑和范围，通过自动 化部署的机制来独立部署的，并且服务的集中管理应该是最低限度的，即每个服务可以采用不同的编程语言编写，使用不同的数据存储技术 。<br>如今，微服务架构已经不是一个新概念了，很多业界前沿互联网公司的实践表明，微服务是一种渐进式的演进架构，是企业应对业务复杂性，支持大规模持续创新行之有效的架构手段。</p><h3 id="微服务组成"><a href="#微服务组成" class="headerlink" title="微服务组成"></a>微服务组成</h3><p>微服务架构是一种比较复杂、内涵丰富的架构模式，它包含很多支撑“微”服务的具体组件和概念，其中一些常用的组件及其概念如下：</p><ul><li>服务注册与发现：服务提供方将己方调用地址注册到服务注册中心，让服务调用方能够方便地找到自己；服务调用方从服务注册中心找到自己需要调用的服务的地址。</li><li>负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，服务节点选择的过程对服务调用方来说是透明的。</li><li>服务网关：服务网关是服务调用的唯一入口，可以在这个组件中实现用户鉴权、动态路由、灰度发布、 A/B测试、负载限流等功能。</li><li>配置中心：将本地化的配置信息（ Properties 、 XML 、 YAML 等形式）注册到配置中心，实现程序包在开发、测试、生产环境中的无差别性，方便程序包的迁移。</li><li>集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形 式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够 在统一的界面中使用系统。</li><li>调用链监控：记录完成一次请求的先后衔接和调用关系，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。</li><li>支撑平台：系统微服务化后，各个业务模块经过拆分变得更加细化，系统的部署、运维、监控等都比单体应用架构更加复杂，这就需要将大部分的工作自动化。 现在，Jenkins、Docker、Kubernetes等工具可以给微服务架构的部署带来较多的便利，例如持续集成、蓝绿 发布、健康检查、性能健康等等。如果没有合适的支撑平台或工具，微服务架构就无法发挥它最大的功效 。</li></ul><p>微服务架构模式有很多优势可以有效解决单体应用扩大之后出现的大部分问题。首先，通过将巨大单体式应用分解为多个服务的方法解决了复杂性问题。在功能不变的情况下，应用分解为多个可管理的模块或服务。每个服务都有一个用RPC或者消息驱动API定义清楚的边界。微服务架构模式为采用单体式编码方式，由此，单个服务变得很容易开发、理解和维护。<br>其次，微服务架构模式使得团队并行开发得以推进，每个服务都可以由专门开发团队来开发。不同团队的开发者可以自由选择开发技术，提供API服务。这种自由意味着开发者不需要被迫使用之前采用的过时技术，他们可以选择最新的技术。甚至于，因为服务都是相对简单的，即使用新技术重写以前的代码也不是很困难的事情。</p><p>微服务的一些想法是好的，但在实践中也会呈现出其复杂性，具体如下：</p><ul><li>运维要求较高：更多的服务意味着需要更多的运维投入。在单体架构中只需要保证一个应用的正常运行即可；而在微服务中，需要保证几十甚至几百个服务的正常运行与协作，这带来了巨大的挑战。 </li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统来说，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。</li><li>接口调整成本高：微服务之间通过接口进行通信。 如果修改某个微服务的API，可能所有使用了该接口 的微服务都需要做调整。</li><li>重复劳动：很多服务可能都会使用到相同的功能， 而这个功能并没有达到分解为一个微服务的程度， 这个时候，可能各个服务都会开发这一功能，导致代码重复。</li><li>可测试性的挑战：在动态环境下，服务间的交互会产生非常微妙的行为，难以进行可视化及全面测试。</li></ul><h2 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h2><p>Spring Cloud是一系列框架的有序集合。目前由 Spring 官方开发维护，基于 Spring Boot 开发，提供一套完整的微服务解决方案。包括服务注册与发现、配置中心、全链路监控、 API 网关、熔断器等开源组件，可以随需扩展和替换组装。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>Spring Cloud 不同于其他独立项目，它是拥有众多子项目的项目集合。因为 Spring Cloud 的子项目居多，每个子项目有自己的版本号，为了对 Spring Cloud 整体进行版本编号，确定一个可用于生产上的版本标识。这些版本采用伦敦地铁站的名字，按名称首字母排序，比如 Dalston 版、Edgware 版、Finchley 版、Greenwich 版。</p><h2 id="Spring-Cloud-组成"><a href="#Spring-Cloud-组成" class="headerlink" title="Spring Cloud 组成"></a>Spring Cloud 组成</h2><p>Spring Cloud 包含的组件众多，各个组件都有各自不同的特性和优点，为使用者提供丰富的选择 ：</p><ul><li><p>服务注册与发现组件：Eureka、Zookeeper 和 Consul 等。</p></li><li><p>服务调用组件：Hystrix、Ribbon 和 OpenFeign。其中 Hystrix 能够使系统在出现依赖服务访问不可达的情况下，通过隔离系统依赖服务的方式，防止服务雪崩，同时提供失败回滚机制，使系统能够更快地从异常中恢复。Ribbon 用于提供客户端的软件负载均衡算法，还提供了一系列完善的配置项如连接超时、重试等。OpenFeign 是一个声明式 RESTful 网络请求客户端，它使编写 Web 服务客户端变得更加方便和快捷。</p></li><li><p>路由和过滤组件：包括 Zuul 和 Spring Cloud Gateway。Spring Cloud Gateway 提供了一个构建在 Spring 生态 之上的 API 网关，其旨在提供一种简单而有效的途径来发送API，并为他们提供横切关注点。如：安全性、监控指标和弹性。</p></li><li><p>消息组件：Spring Cloud Stream 和 Spring Cloud Bus。Spring Cloud Stream 对于分布式消息的各种需求进行了抽象，包括发布订阅、分组消费和消息分区等功能，实现了微服务之间的异步通信。Spring Cloud Bus 主要提供了服务间的事件通信（比如：刷新配置 ）。</p></li><li><p>安全控制组件：Spring Cloud Security 基于 OAuth2.0 开放网络的安全标准，提供了微服务环境下的单点登录、资源授权和令牌管理等功能。</p></li><li><p>链路监控组件：Spring Cloud Sleuth 提供了全自动、可配置的数据埋点，以 收集微服务调用链路上的性能数据，并可以结合 Zipkin 进行数据存储、统计和展示。</p></li></ul><p>除了上述组件之外，Spring Cloud 还提供了命令行工具 Spring Cloud Cli 和集群工具 Spring Cloud Cluster。 Spring Cloud Cli 提供了以命令行和脚本的方式来管理微服务及 Spring Cloud 组件的方式，Spring Cloud Cluster 提供了集群选主、分布式锁和一次性令牌等分布式集群需要的技术组件。</p><table><thead><tr><th style="text-align:center">组件名称</th><th style="text-align:center">所属项目</th><th style="text-align:center">组件分类</th></tr></thead><tbody><tr><td style="text-align:center">Eureka</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Consul</td><td style="text-align:center">spring-cloud-consul</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zookeeper</td><td style="text-align:center">spring-cloud-zookeeper</td><td style="text-align:center">注册中心</td></tr><tr><td style="text-align:center">Zuul</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">第一代网关</td></tr><tr><td style="text-align:center">Ribbon</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">负载均衡</td></tr><tr><td style="text-align:center">Hystrix</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">熔断器</td></tr><tr><td style="text-align:center">Turbine</td><td style="text-align:center">spring-cloud-netfix</td><td style="text-align:center">集群监控</td></tr><tr><td style="text-align:center">Feign</td><td style="text-align:center">spring-cloud-openfeign</td><td style="text-align:center">远程调用</td></tr><tr><td style="text-align:center">Gateway</td><td style="text-align:center">spring-cloud-gateway</td><td style="text-align:center">第二代网关</td></tr><tr><td style="text-align:center">Sleuth</td><td style="text-align:center">spring-cloud-seluth</td><td style="text-align:center">链路追踪</td></tr><tr><td style="text-align:center">Bus</td><td style="text-align:center">spring-cloud-bus</td><td style="text-align:center">总线</td></tr><tr><td style="text-align:center">config</td><td style="text-align:center">spring-cloud-config</td><td style="text-align:center">配置中心</td></tr><tr><td style="text-align:center">Pipeline</td><td style="text-align:center">spring-cloud-pipeline</td><td style="text-align:center">部署管道</td></tr><tr><td style="text-align:center">Dataflow</td><td style="text-align:center">spring-cloud-dataflow</td><td style="text-align:center">数据处理</td></tr><tr><td style="text-align:center">Security</td><td style="text-align:center">spring-cloud-Security</td><td style="text-align:center">安全控制</td></tr></tbody></table><p>Spring Cloud 并不能与微服务或者微服务架构划上等号，不能误认为使用了 Spring Cloud 的应用服务就是微服务。微服务架构是一种架构的理念，重点是微服务的设计原则，从理论上为具体的技术落地提供了指导思想。Spring Cloud 是一个基于 Spring Boot 实现的服务治理工具包，关注全局的服务治理框架。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十、【Java 并发】抽象同步队列 AQS</title>
      <link href="/javaThread/thread10/"/>
      <url>/javaThread/thread10/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="AbstractQueuedSynchronizer-抽象队列同步器"><a href="#AbstractQueuedSynchronizer-抽象队列同步器" class="headerlink" title="AbstractQueuedSynchronizer 抽象队列同步器"></a>AbstractQueuedSynchronizer 抽象队列同步器</h2><p>抽象队列同步器 AbstractQueuedSynchronizer，简称 AQS，是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。它是实现同步组件的基础， 并发包中锁的底层就是使用 AQS 实现的。</p><p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用 AQS 提供的3个方法 gestate、setstate(int new State)和 compareAndSetState(int expect， int update)<br>来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，AQS 自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，AQS 既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件( Reentrantlock、ReentrantReadWriteLock 和 CountDownLatch 等)。</p><p>AQS 是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用 AQS 实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节; AQS 面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和 AQS 很好地隔离了使用者和实现者所需关注的领域。大多数开发者可能永远不会直接使用AQS，但是知道其原理对于架构设计还是很有帮助的。</p><h2 id="AQS-原理-amp-架构"><a href="#AQS-原理-amp-架构" class="headerlink" title="AQS 原理 &amp; 架构"></a>AQS 原理 &amp; 架构</h2><p>AQS 的设计是基于模板方法模式，使用者需要继承 AQS 并重写指定的方法，将 AQS 组合在自定义同步组件的实现中，并调用 AQS 提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p><h3 id="AQS-模板方法"><a href="#AQS-模板方法" class="headerlink" title="AQS 模板方法"></a>AQS 模板方法</h3><h4 id="AQS-可重写的模板方法"><a href="#AQS-可重写的模板方法" class="headerlink" title="AQS 可重写的模板方法"></a>AQS 可重写的模板方法</h4><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">protected boolean tryAcquire(int arg)</td><td style="text-align:center">独占式获取同步状态，实现该方法需要查询当前状态， 并判断同步状态是否符合预期，然后再进行 CAS 设置同步状态</td></tr><tr><td style="text-align:center">protected boolean tryRelease(int arg)</td><td style="text-align:center">独占式释放同步状态，等待获取同步状态的线程将有机会获取到同步状态</td></tr><tr><td style="text-align:center">protected int tryAcquireShared(int arg)</td><td style="text-align:center">共享式获取同步状态，返回大于等于0的值，表示获取成功，反之获取失败</td></tr><tr><td style="text-align:center">protected boolean tryReleaseShared(int arg)</td><td style="text-align:center">共享式释放同步状态</td></tr><tr><td style="text-align:center">protected boolean isHeldExclusively()</td><td style="text-align:center">当前同步器是否在独占模式下被线程占用，一般该方法表示 是否被当前线程所独占</td></tr></tbody></table><h4 id="AQS-提供的模板方法"><a href="#AQS-提供的模板方法" class="headerlink" title="AQS 提供的模板方法"></a>AQS 提供的模板方法</h4><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">void acquire(int arg）</td><td style="text-align:center">独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回， 否则将会进入同步队列等待，该方法将会调用重写的 tryAcquire(int arg)方法</td></tr><tr><td style="text-align:center">void acquireInterruptibly(int arg)</td><td style="text-align:center">与 acquire(int arg)相同，但是该方法响应中断，当前线程未获取到 同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出 InterruptedException 并返回</td></tr><tr><td style="text-align:center">boolean tryAcquireNanos(int arg)</td><td style="text-align:center">在 acquireInterruptibly(int arg)基础上增加了超时限制， 如果当前线程在超时时间内没有获取到同步状态， 那么将会返回 false， 如果获取到了返回true</td></tr><tr><td style="text-align:center">void acquireShared(int arg)</td><td style="text-align:center">共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列 等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td style="text-align:center">void acquireSharedInterruptibly(int arg)</td><td style="text-align:center">与 acquireShared(int arg)相同，该方法响应中断</td></tr><tr><td style="text-align:center">boolean tryAcquireSharedNanos(int arg， long nanos)</td><td style="text-align:center">在 acquireSharedInterruptibly (int arg)基础上增加了超时限制</td></tr><tr><td style="text-align:center">boolean release(int arg)</td><td style="text-align:center">独占式的释放同步状态，该方法会在释放同步状态之后， 将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td style="text-align:center">boolean releaseShared(int arg)</td><td style="text-align:center">共享式的释放同步状态</td></tr><tr><td style="text-align:center">Collection<thread> getQueuedThreads()</thread></td><td style="text-align:center">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>AQS 提供的模板方法可以分为下面几类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>自定义同步组件使用同步器提供的模板方法来实现自己的同步语义。只有掌握了同步器的工作原理才能更加深人地理解并发包中其他的并发组件，所以下面<br>通过 AQS 源码中提供的一个独占锁的示例来深入了解一下同步器的工作原理。</p><p>顾名思义，独占锁就是在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>， <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类 自定义同步器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否处于占用状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当状态为 0 的时候获取锁</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>， <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 释放锁，将状态设置为 0</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个 Condition，每个 condition 都包含了一个 condition 队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException， ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// 重置为解锁状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将操作通过 Sync 上即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout， TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>， unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Mutex 是一个自定义独占锁同步组件，它在同一时刻只允许一个线程占有锁。Mutex 中定义了一个静态内部类，该内部类继承了 AQS 并实现了独占式获取和释放同步状态。在 tryAcquire(int releases) 方法中，如果经过 CAS 设置成功，也就是同步状态值设置为 1，则代表获取了同步状态，而在 tryRelease(int releases) 方法中只是将同步状态值重置为 0。</p><p>使用 Mutex 时并不会直接和内部 AQS 的实现打交道，而是调用 Mutex 提供的方法，在 Mutex 的实现中，以获取锁的 lock() 方法为例，只需要在方法实现中调用同步器的模板方法 acquire(int args) 即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待，这样就大大降低了实现一个可靠自定义同步组件的门槛。</p><h3 id="AQS-同步队列"><a href="#AQS-同步队列" class="headerlink" title="AQS 同步队列"></a>AQS 同步队列</h3><p>AQS 依赖内部的一个 FIFO 双向同步队列来完成同步状态的管理，当前线程获<br>取同步状态失败时，AQS 会将当前线程以及等待状态等信息构造成为一个 Node 并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p><p>同步队列中的节点( Node)用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述。源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 一种标识，表示被标识的结点是共享式 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** 一种标识，表示被标识的结点是独占式 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态，初始值为 0 ， 状态值如下:</span></span><br><span class="line"><span class="comment">         * CANCELLED: 被中断或者获取同步状态超时会被置为该状态，且在该状态下的线程不再被阻塞，从同步队列中取消等待，节点进入该状态将不再改变</span></span><br><span class="line"><span class="comment">         * SIGNAL: 线程如果释放了或者取消了同步状态，则会将对应的结点置为该状态，用于通知下一个节点，准备获取同步状态</span></span><br><span class="line"><span class="comment">         * CONDITION: 当前节点在 Condition 等待队列中，当其他线程对 Condition 调用了signal 方法后，</span></span><br><span class="line"><span class="comment">         *            该节点将会从等待队列中转移到 AQS 同步队列中，等待获取同步锁</span></span><br><span class="line"><span class="comment">         * PROPAGATE: 与共享式获取同步状态有关，处于该状态的节点中的线程处于可运行的状态， </span></span><br><span class="line"><span class="comment">         *            表示下一次共享式同步状态获取将会无条件地被传播下去，</span></span><br><span class="line"><span class="comment">         *            释放共享资源时需要通知其他节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前驱节点， 当节点加入同步队列时被设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取同步状态的线程.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点在Condition中等待队列上的下一个节点（给Condition等待队列使用）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前节点是否是在共享模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread， Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread， <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Node 是构成同步队列的基础，AQS 拥有首节点 head 和尾结点 tail，没有成功获取同步状态的线程将会成为节点加入该队列的尾部</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-3418f5669abc3792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>AQS 包含了两个节点类型的引用，一个指向头节点，而另-一个指向尾节<br>点。当一个线程成功地获取了同步状态(或者锁)，其他线程将无法获取到同步状态，转而被构造成为节点并加人到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect， Node update)，它需要传递当前线程认为的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-d6e47f67f8d6fb12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-2c7d78da21befded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如上图，设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。</p><h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><h5 id="acquire-方法"><a href="#acquire-方法" class="headerlink" title="acquire 方法"></a>acquire 方法</h5><p>通过调用 AQS 的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出，方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占式获取同步状态,</span></span><br><span class="line"><span class="comment"> * 如果当前线程获取同步状态成功，则由该方法返回，</span></span><br><span class="line"><span class="comment"> * 否则将会进入同步队列等待,该方法将会调用重写的 tryAcquire(int arg)方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面方法主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点(独占式 Node.EXCLUSIVE, 同一时刻只能有一个线程成功获取同步状态)并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueuedQNode node, int arg)方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><p>下面来详细分析一下整个流程。首先是节点的构造以及加入同步队列，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前线程以给定模式创建节点并加入同步队列中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode 指定的节点模式  Node.EXCLUSIVE 独占式, Node.SHARED 共享式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回创建好的节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前线程封装成 Node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试在尾部添加</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//成功加入直接返回</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用此方法继续尝试加入同步队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过自旋方式保证入队列成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 入队列节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 入队成功返回前置节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//如果队尾为空说明队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化队列,将头结点设置为空节点,头结点即表示当前正在运行的节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">//再将尾节点值设置成头结点,继续下次循环尾结点就不会为空了</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将当前队列的尾节点设置成当前节点的前置节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//CAS 操作当前节点加入队尾,如果失败的话,继续循环,直到成功返回</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//设置成功将当前节点设置成前尾节点的后继节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点加入同步队列之后，就会进入一个自旋的过程，每个节点中的线程都在自省地观察，当条件满足，获取到了同步状态，就可以从自旋中退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过自旋不断的调用 tryAcquire 尝试获取同步状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标示是否成功获取同步状态</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//标示线程中断状态</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//只有当前置节点为首节点才会尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//获取同步状态成功后,设置当前节点为首节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取同步状态失败,判断当前线程是否需要阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果自旋结束,failed 标示还为 true 则代表获取同步状态失败,那么就将该节点从同步队列中移除,同时唤醒下一节点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 acquireQueued(final Node node, int arg) 方法中，当前线程在自旋中尝试获取同步状态，只有前置结点是头节点才能够舱室获取同步状态，这样设计原因有如下两个：</p><ul><li>头结点是成功获取到同步状态的节点，而头结点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前置节点是否是头结点</li><li>维护同步队列的 FIFO 原则。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点从同步队列中移除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点不存在了直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//设置该节点线程为空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到状态不为 CANCELLED 的前置节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前置节点的下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前中断的节点状态为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前中断的节点是尾节点,则将尾节点重新指向</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">//尾结点的下个节点设置为 null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前置节点的状态为 SINGAL 或者即将 SINGAL,那么将当前中断节点移除</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将节点移除,并唤醒下一个节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点移除,同时唤醒下一个节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置该节点为初始化状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中断节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 判断后继节点的状态,如果为 Node.CANCELED 状态, 回溯获取最近的 waitStatus &lt;= 0 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果该节点不为 null,则通过 LockSupport 唤醒该节点中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire(int arg)方法调用流程，也就是独占式同步状态获取流程，整个流程可以参考下图：</p><p>[图片上传失败…(image-980765-1630650770495)]</p><p>当线程获取同步状态成功并执行了相应逻辑之后，就需要释放同步状态，使得其后续节点能够继续获取同步状态。通过调用同步器的 release(int arg) 方法可以释放同步状态，该方法在释放同步状态之后，会唤醒其后继节点，进而使后继节点重新尝试获取同步状态，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占式的释放同步状态,该方法会在释放同步状态之后, 将同步队列中第一个节点包含的线程唤醒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>release 方法执行时，会唤醒头结点的后继节点，unparkSuccessor(Node node)方法使用 LockSupport 来唤醒处于等待状态的线程。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在获取同步状态时，AQS 维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋。移出队列(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 tryRelease(int arg) 方法释放同步状态，然后唤醒头节点的后继节点。</p><h4 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h4><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p><p>通过调用 AQS 的 acquireShared(int arg)方法可以共享式地获取同步状态，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享式的获取同步状态,如果当前线程未获取到同步状态,将会进入同步队列等待</span></span><br><span class="line"><span class="comment"> * 与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态， tryAcquireShared(int arg) 方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg) 方法返回值大于等于 0。可以看到，在 doAcquireShared(int arg) 方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于 0 ,表示该次获取同步状态成功并从自旋过程中退出。与独占式一样，共享式获取也需要释放同步状态，通过调用 releaseShared(int arg) 方法释放同步状态，该方法代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享式的释放同步状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件(比如Semaphore)，它和独占式主要区别在于 tryReleaseShared(int arg) 方法必须确保同步状态(或者资源数)线程安全释放，一般是通过循环和 CAS 来保证的,因为释放同步状态的操作会同时来自多个线程。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>九、【Java 并发】锁的概述</title>
      <link href="/javaThread/thread9/"/>
      <url>/javaThread/thread9/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h2><p>乐观锁和悲观锁是在数据库中引入的名词，但是在 Java 并发包锁里面也引入了类似的思想。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><strong>悲观锁</strong> 指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。</p><p><strong>悲观锁</strong> 的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">long</span> id)</span> l</span></span><br><span class="line"><span class="function">    <span class="comment">// 使用悲观锁获取指定记录</span></span></span><br><span class="line"><span class="function">    EntryObject entry </span>= query(<span class="string">"select * from table1 where id=#&#123;id&#125; for update"</span>, id) ;</span><br><span class="line">    <span class="comment">// 修改名称</span></span><br><span class="line">    entry.setName (“<span class="keyword">new</span> name”) ;</span><br><span class="line">    <span class="comment">// 执行更新操作</span></span><br><span class="line">    <span class="keyword">int</span> count = update(<span class="string">"update table1 set name=#&#123;name&#125;, age=#&#123;age&#125; where id=#&#123;id&#125;"</span>,entry) ;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">当多个线程同时调用 updateEntry 方法,并且传递的是同一个id时,只有一个线程执行代码 query 方法会成功，其他线程则会被阻塞,这是因为在同一时间只有一个线程可以获取对应记录的锁，在获取锁的线程释放锁前 ( update Entry执行完毕,提交事务之前 )，其他线程必须等待,也就是在同一时间只有一个线程可以对该记录进行修改。</span><br><span class="line"></span><br><span class="line">### 乐观锁</span><br><span class="line"></span><br><span class="line">**乐观锁** 是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。具体来说，根据update返回的行数让用户决定如何去做。将上面的例子改为使用乐观锁的代码如下。</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)使用乐观锁获取指定记录</span></span><br><span class="line">    EntryObject entry = query(<span class="string">"select * from table1 where id = #&#123;id&#125;"</span>,id) ;</span><br><span class="line">    <span class="comment">//(2)修改记录内容，version 字段不能被修改</span></span><br><span class="line">    entry.setName(“name”);</span><br><span class="line">    <span class="comment">// (3) update操作</span></span><br><span class="line">    <span class="keyword">int</span> count = update(<span class="string">"update table1 set name=#&#123;name&#125; , age=#&#123;age&#125;, version=$&#123;version&#125;+1 where id =#&#123;id&#125; and version=#&#123;version&#125;"</span>,entry);</span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观锁并不会使用数据库提供的锁机制，一般在表中添加version字段或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。</p><h2 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h2><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程请求锁的时间先后来决定的，也就是最先请求锁的线程将最先获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。</p><p>例如，假设线程A已经持有了锁，这时候线程B请求该锁其将会被挂起。当线程A释放锁后，假如当前有线程C也需要获取该锁，如果采用非公平锁方式，则根据线程调度策略，线程B和线程C两者之一可能获取锁，这时候不需要任何其他干涉，而如果使用公平锁则需要把C挂起，让B获取当前锁。</p><p><strong>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销</strong></p><h2 id="独占锁-amp-共享锁"><a href="#独占锁-amp-共享锁" class="headerlink" title="独占锁 &amp; 共享锁"></a>独占锁 &amp; 共享锁</h2><p>根据锁只能被单个线程持有还是能被多个线程共同持有,锁可以分为独占锁和共享锁。</p><p>独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock 就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。</p><p>独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</p><p>共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢?如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数(严格来说是有限次数)地进入被该锁锁住的代码。</p><p>synchronized 内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程<br>标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为 0，说明该锁没有被任何线程占用。当一个线程获取了该锁时,计数器的值会变成1,这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p><p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1，当释放锁后计数器值-1。当计数器值为0时，锁里面的线程标示被重置为null，这时候被阻塞的线程会被唤醒来竞争获取该锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>由于Java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁(比如独占锁)失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取(默认次数是10，可以使用 -XX:PreBlockSpinsh 参数设置该值)，很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。</p><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h2><p>在 Lock 接口出现之前，Java 程序是靠 synchronized 关键字实现锁功能的，而 Java Se5 之后，并发包中新增了 Lock 接口(以及相关实现类)用来实现锁功能，它提供了与 synchronized 关键字类似的同步功能,只是在使用时需要显式地获取和释放锁。虽然它缺少了(通过 synchronized 块或者方法所提供的)隐式获取释放锁的便捷性,但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步<br>特性。</p><p>使用 synchronized 关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然,这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。Lock 的使用其实也很简单，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 finally 块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p><h3 id="Lock-接口方法"><a href="#Lock-接口方法" class="headerlink" title="Lock 接口方法"></a>Lock 接口方法</h3><ul><li><p>void lock()；<br>获取锁,调用该方法当前线程将会获取锁,当锁获得后,从该方法返回  </p></li><li><p>void lockInterruptibly() throws InterruptedException；<br>可中断地获取锁，和 lock 方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</p></li><li><p>boolean tryLock()<br>尝试非阻塞的获取锁,调用该方法后立刻返回，如果能够获取则返回 true，否则返回 false</p></li><li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException；<br>超时的获取锁,当前线程在以下3种情况下会返回:</p><ul><li>当前线程在超时时间内获得了锁</li><li>当前线程在超时间内被中断</li><li>超时时间结束,返回 false</li></ul></li><li><p>void unlock<br>  释放锁</p></li><li><p>Condition newCondition()；<br>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait 方法，而调用后，当前线程将释放锁</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八、【Java 并发】伪共享</title>
      <link href="/javaThread/thread8/"/>
      <url>/javaThread/thread8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h2><p>为了解决计算机系统中主内存与 CPU 之间运行速度差问题，会在 CPU 与主内存之间添加一级或者多级高速缓冲存储器（ Cache ）。这个 Cache 一般是被集成到 CPU 内部的， 所以也叫 CPU Cache ，如下图所示是两级 Cache 结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-795db8f09d33a5ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在 Cache 内部是按行存储的，其中每一行称为一个 Cache 行。Cache 行是 Cache 与主内存进行数据交换的单位，Cache 行的大小一般为 2 的幂次数字节。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-c1ea87f536e18149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当 CPU 访问某个变量时，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否则就去主内存里面获取该变量，然后把该变量所在内存区域的一个 Cache 行大小的内存复制到 Cache 中。由于存放到 Cache 行的是内存块而不是单个变量，所以可能会把多个变量存放到 一个 Cache 行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-db0cbd9a2e6f7ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在上图中，变量 x 和 y 同时被放到了 CPU 的一级和二级缓存，当线程 1 使用 CPU1 对变量 x 进行更新时，首先会修改 CPU1 的一级缓存变量 x 所在的缓存行，这时候在缓存一致性协议下，CPU2 中变量 x 对应的缓存行失效。那么线程 2 在写入变量 x 时就只能去二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的 CPU 中相同缓存行里面的变量。更坏的情况是，如果 CPU 只有一级缓存，则会导致频繁地访问主内存。</p><h2 id="为何会出现伪共享"><a href="#为何会出现伪共享" class="headerlink" title="为何会出现伪共享"></a>为何会出现伪共享</h2><p>伪共享的产生是因为多个变量被放入了一个缓存行中，并且多个线程同时去写入缓存行中不同的变量。那么为何多个变量会被放入一个缓存行呢？其实是因为缓存与内存交换数据的单位就是缓存行，当 CPU 要访问的变量没有在缓存中找到时，根据程序运行的局部性原理，会把该变量所在内存中大小为缓存行的内存放入缓存行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure></p><p>如上代码声明了四个 long 变量，假设缓存行的大小为 32 字节，那么当 CPU 访问变量 a 时，发现该变量没有在缓存中，就会去主内存把变量 a 以及内存地址附近的 b、c、d 放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中。当创建数组时，数组里面的多个元素就会被放入同一个缓存行。那么在单线程下多个变量被放入同一个缓存行对性能有影响吗？其实在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><h2 id="如何避免伪共享"><a href="#如何避免伪共享" class="headerlink" title="如何避免伪共享"></a>如何避免伪共享</h2><p>在 JDK 8 之前一般都是通过字节填充的方式来避免该问题，也就是创建一个变量时使用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同 一个缓存行中，例如如下代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = OL;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> pl,p2,p3,p4,p5,p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如缓存行为 64 字节，那么我们在 FilledLong 类里面填充了 6 个 long 类型的变量，每个 long 类型变量占用 8 字节，加 上 value 变量的 8 字节总共 56 字节。另外，这里 FilledLong 是一个类对象，而类对象的字节码的对象头占用 8 字节，所以一个 FilledLong 对象实际会占用 64 字节的内存，这正好可以放入一个缓存行。</p><p>JDK 8 提供了 一个 sun.misc.Contended 注解，用来解决伪共享问题。将上面代码修改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = OL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次注解除了可以修饰类，也可以修饰变量，比如在 Thread 类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line">    <span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line">    <span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line">    <span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure></p><p>Thread 类里面这三个变量默认被初始化为 0 ，这三个变量会在ThreadLocalRandom 类中使用。</p><p>需要注意的是，在默认情况下，＠Contended 注解只用于 Java 核心类，比如此包下的类。如果用户类路径下的类需要使用这个注解，则需要添加 JVM 参数：－XX:-RestrictContended。填充的宽度默认为 128 ，要自定义宽度则可以设置 －XX:ContendedPaddingWidth 参数。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>七、【Java 并发】原子性之CAS操作，Unsafe 类</title>
      <link href="/javaThread/thread7/"/>
      <url>/javaThread/thread7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Java-中的-CAS-操作"><a href="#Java-中的-CAS-操作" class="headerlink" title="Java 中的 CAS 操作"></a>Java 中的 CAS 操作</h2><p>CAS ( Compare and Swap ) 是对一种处理器指令(例如 x86 处理器中的 cmpxchg 指令)的称呼。不少多线程相关的 Java 标准库类的实现最终都会借助 CAS。虽然在实际工作中多数情况下我们并不需要直接使用 CAS，但是理解CAS 有助于我们更好地理解相关标准库类，以便恰当地使用它们。</p><p>在 Java 中，锁在并发编程中占据了一席之地，但是使用锁后，势必会产生由于使用锁而导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的 volatile 关键字来解决共享变量的可见性问题，这在一定程度。上弥补了锁带来的开销问题，但是 volatile 只能保证共享变量的可见性，不能解决读改写等的原子性问题。CAS 即 Compare and Swap，其是 JDK 提供的非阻塞原子性操作，它通过硬件保证了更新操作的原子性。JDK 里面的 Unsafe 类提供了一系列的compareAndSwap* 方法，比如下面的compareAndSwapLong 方法。</p><ul><li>boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update);</li></ul><p>其中 compareAndSwap 的意思是比较并交换。CAS有四个操作数，分别为:</p><ul><li>对象内存位置</li><li>对象中的变量的偏移量</li><li>变量预期值</li><li>和新的值</li></ul><p>其操作含义是，如果对象 obj 中内存偏移量为 valueOffset 的变量值为 expect，则使用新的值 update 替换旧的值 expect。这是处理器提供的一个原子性指令。</p><blockquote><p>关于 CAS 操作有个经典的 ABA 问题，具体如下:</p><p>假如线程 I 使用 CAS 修改初始值，为 A 的变量 X，那么线程 I 会首先去获取当前变量 X 的值(为A)，然后使用 CAS 操作尝试修改 X 的值为 B,如果使用CAS操作成功了,那么程序运行一-定是正确的吗?</p><p>其实未必，这是因为有可能在线程 I 获取变量 X 的值 A 后，在执行 CAS 前，线程 II 使用 CAS 修改了变量 X 的值为 B，然后又使用CAS修改了变量 X 的值为 A。所以虽然线程 I 执行 CAS时 X 的值是 A，但是这个A已经不是线程 I 获取时的 A 了。这就是 ABA 问题。</p><p>ABA 问题的产生是因为变量的状态值产生了环形转换，就是变量的值可以从 A 到 B，然后再从 B 到 A。如果变量的值只能朝着一个方向转换，比如 A 到 B，B 到 C，不构成环形，就不会存在问题。JDK 中的AtomicStampedReference 类给每个变量的状态值都配备了一个时间戳，从而避免了ABA问题的产生。</p></blockquote><h2 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h2><p>JDK 的 rt，jar 包中的 Unsafe 类提供了硬件级别的原子性操作，Unsafe 类中的方法都是 native 方法，它们使用 JNI 的方式访问本地 C++ 实现库。</p><h3 id="Unsafe-类重要方法"><a href="#Unsafe-类重要方法" class="headerlink" title="Unsafe 类重要方法"></a>Unsafe 类重要方法</h3><ul><li><p>long objectFieldOffset(Field field);<br>返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该 Unsafe 函数中访问指定字段时使用。</p></li><li><p>int arrayBaseOffset(Class arrayClass);<br>获取数组中第一个元素的地址。</p></li><li><p>int arrayIndexScale(Class arrayClass);<br>获取数组中一个元素占用的字节。</p></li><li><p>boolean compareAndSwapLong(Object obj, long offset, long expect, long update);<br>比较对象 obj 中偏移量为 offset 的变量的值是否与 expect 相等，相等则使用 update 值更新，然后返回 true，否则返回 false。</p></li><li><p>public native long getLongvolatile(Object obj, long offset);<br>获取对象obj中偏移量为 offset 的变量对应 volatile 语义的值。</p></li><li><p>void putLongvolatile(Object obj, long offset, long value);<br>设置 obj 对象中 offset 偏移的类型为 long 的 field 的值为 value，支持 volatile 语义。</p></li><li><p>void putOrderedLong(Object obj, long offset, long value);<br>设置 obj 对象中 offset 偏移地址对应的 long 型 field 的值为 value。这是一个有延迟的 putLongvolatile 方法,并且不保证值修改对其他线程立刻可见。只有在变量使用 volatile 修饰并且预计会被意外修改时才使用该方法。</p></li><li><p>void park(boolean isAbsolute, long time);<br>阻塞当前线程，其中参数 isAbsolute 等于 false 且 time 等于 0 表示一直阻塞。time 大于 0 表示等待指定的 time 后阻塞线程会被唤醒，这个time 是个相对值，是个增量值，也就是相对当前时间累加 time 后当前线程就会被唤醒。如果 isAbsolute 等于 true，并且 time 大于0，则表示阻塞<br>的线程到指定的时间点后会被唤醒，这里 time 是个绝对时间，是将某个时间点换算为 ms 后的值。另外，当其他线程调用了当前阻塞线程的 interrupt 方法而中断了当前线程时，当前线程也会返回，而当其他线程调用了 unPark 方法并且把当前线程作为参数时当前线程也会返回。</p></li><li><p>void unpark(Object thread);<br>唤醒调用 park 后阻塞的线程。</p></li><li><p>long getAndSetLong(Object obj, long offset, long update);<br>获取对象 obj中 偏移量为 offset 的变量 volatile 语义的当前值，并设置变量 volatile 语义的值为 update。</p></li><li><p>long getAndAddLong(Object obj, long offset, long addValue);<br>获取对象 obj 中偏移量为 offset 的变量 volatile 语义的当前值，并设置变量值为原始值+addValue。</p></li></ul><h2 id="简单实用-Unsafe-类"><a href="#简单实用-Unsafe-类" class="headerlink" title="简单实用 Unsafe 类"></a>简单实用 Unsafe 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取 Unsafe 实例</span></span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于记录 state 属性的内存偏移量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取 state 属性的内存偏移量</span></span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(UnsafeTest.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        UnsafeTest ut = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出 state 值</span></span><br><span class="line">        System.out.println(ut.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改 state 值</span></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(ut, stateOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出知否修改成功</span></span><br><span class="line">        System.out.println(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出修改过后的 state 值</span></span><br><span class="line">        System.out.println(ut.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会很意外的报错了：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-cec8f2150ab8c996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>为了找出原因，我们来看看 Unsafe.getUnsafe() 方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取调用 getUnsafe 方法的对象的 Class 对象，这里是 TestUnsafe.claass</span></span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 判断是不是 Bootstrap 类加载器加载的 localClass,很显然 TestUnsafe.class 是使用 AppClassLoader 加载的，所以直接抛出了异常</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要有这个判断呢？我们知道 Unsafe 类是 rt.jar 包提供的, rt.jar包里面的类是使用 Bootstrap 类加载器加载的，而我们的启动 main 函数所在的类是使用 AppClassLoader 加载的，所以在 main 函数里面加载 Unsafe 类时，根据委托机制，会委托给 Bootstrap 去加载 Unsafe 类。</p><p>如果没有这个判断的限制，那么我们的应用程序就可以随意使用 Unsafe 做事情了，而 Unsafe 类可以直接操作内存，这是不安全的，所以 JDK 开发组特意做了这个限制，不让开发人员在正规渠道使用 Unsafe 类，而是在此 jar 包里面的核心类中使用 Unsafe 功能。</p><p>既然正规渠道访问不了，那么咱们就玩点黑科技，使用万能的反射来获取 Unsafe 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Unsafe 实例</span></span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">//用于记录 state 属性的内存偏移量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用反射获取 Unsafe 的成员变量 theUnsafe</span></span><br><span class="line">            Field theUnsafeField = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置为可存取</span></span><br><span class="line">            theUnsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该变莹的值</span></span><br><span class="line">            unsafe = (Unsafe) theUnsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取 state 属性的内存偏移量</span></span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(UnsafeTest.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UnsafeTest ut = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出 state 值</span></span><br><span class="line">        System.out.println(ut.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改 state 值</span></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(ut, stateOffset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出知否修改成功</span></span><br><span class="line">        System.out.println(success);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出修改过后的 state 值</span></span><br><span class="line">        System.out.println(ut.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六、【Java 并发】ThreadGroup 详解</title>
      <link href="/javaThread/thread6/"/>
      <url>/javaThread/thread6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="ThreadGroup-与-Thread"><a href="#ThreadGroup-与-Thread" class="headerlink" title="ThreadGroup 与 Thread"></a>ThreadGroup 与 Thread</h2><p>默认情况下，新的线程都会加入到创建它的线程（也就是父线程）所在的 group 中。如同线程存在父子关系一样，ThreadGroup 同样也存在父子关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-8c2d07205b753673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="创建-ThreadGroup"><a href="#创建-ThreadGroup" class="headerlink" title="创建 ThreadGroup"></a>创建 ThreadGroup</h2><p>创建 ThreadGroup 非常简单，可通过两个构造函数来创建。</p><ul><li>public ThreadGroup(String name) </li><li>public ThreadGroup(ThreadGroup parent, String name) </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定名称不指定父线程组  (默认父线程组为创建线程组的线程的线程组,也就是当前线程的父线程组)</span></span><br><span class="line">    ThreadGroup myGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"myGroup"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定名称  指定父线程组</span></span><br><span class="line">    ThreadGroup myGroup2 = <span class="keyword">new</span> ThreadGroup(myGroup, <span class="string">"myGroup2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制-Thread"><a href="#复制-Thread" class="headerlink" title="复制 Thread"></a>复制 Thread</h2><ul><li>public int enumerate(Thread list[]) </li><li>public int enumerate(Thread list[], boolean recurse)</li></ul><p>两个方法，都可以讲 Thread 中的 active 线程全部复制到 Thread 数组中，其中 recurse 参数如果为 true，则会将所有的自 group 中的 active 线程都递归到 Thread 数组中，enumerate(Thread list[])等价于enumerate(Thread list[], true)，如果为 false，只会复制调用此方法的线程组中的 active 线程，其子线程组中的 active 线程不会复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定名称不指定父线程组  (默认父线程组为创建线程组的线程的线程组,也就是当前线程的父线程组)</span></span><br><span class="line">        ThreadGroup myGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"myGroup"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myGroup,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定名称  指定父线程组</span></span><br><span class="line">        ThreadGroup myGroup2 = <span class="keyword">new</span> ThreadGroup(myGroup, <span class="string">"myGroup2"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myGroup2,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myGroup2,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"activecount: "</span>+myGroup.activeCount());</span><br><span class="line">        <span class="comment">//myGroup.activeCount() 获取线程组中的 active 线程数,包括子线程组中的</span></span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[myGroup.activeCount()];</span><br><span class="line"><span class="comment">//        int size = myGroup.enumerate(t,true);</span></span><br><span class="line">        <span class="keyword">int</span> size = myGroup.enumerate(t,<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">"size: "</span>+size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>enumerate 方法获取的线程仅仅是个预估值，并不能百分之百地保证当前 group 的活跃线程，比如在调用复制之后，某个线程结束了声明周期或者新的线程加入了进来，都会导致数据不准确。<br>enumerate 方法返回值是本次复制，active 线程真实的数量。</p></blockquote><h2 id="复制-ThreadGroup-数组"><a href="#复制-ThreadGroup-数组" class="headerlink" title="复制 ThreadGroup 数组"></a>复制 ThreadGroup 数组</h2><ul><li>public int enumerate(ThreadGroup list[]) </li><li>public int enumerate(ThreadGroup list[], boolean recurse) </li></ul><p>和复制 Thread 数组类似，上面两个方法主要用于复制当前 ThreadGroup 的子 Group，同样 recurse 会决定是否复制子 Group 中的子 Group。</p><h2 id="ThreadGroup-操作"><a href="#ThreadGroup-操作" class="headerlink" title="ThreadGroup 操作"></a>ThreadGroup 操作</h2><p>ThreadGroup 并不能提供对线程的管理，ThreadGroup 的主要功能是对线程进行组织。</p><ul><li>activeCount() 用于获取 group 中活跃的线程，这只是个估计值，并不能百分之百的保证正确。</li><li>activeGroupCount() 获取 group 中活跃的子 group，这也是一个估值，方法方法会递归获取所有子 group。</li><li>getMaxPriority() 用于获取 group 的优先级，默认情况下，Group 的优先级为 10，在group 中，所有线程的优先级都不能大于 group 的优先级</li><li>getName() 获取 group 的名字</li><li>getParent() 用于获取 group 的父 group，如果父 group 不存在，则会返回 null，比如 system group 的父 group 就为 null。</li><li>list() 该方法没有返回值，调用该方法会将 group 中所有的活跃线程信息全部输出到控制台，也就是 System.out</li><li>parentOf(ThreadGroup g) 会判当前 group 是不是传入 group 的父 group。如果传入的 group 就是自己本身，该方法也回返回 true。</li><li>setMaxPriority(int pri) 指定 group 的最大优先级，最大优先级不能超过父 group 的最大优先级，执行该方法不仅会改变当前 group 的最大优先级，还会改变所有子 group 的最大优先级</li></ul><h2 id="ThreadGroup-的-interrupt"><a href="#ThreadGroup-的-interrupt" class="headerlink" title="ThreadGroup 的 interrupt"></a>ThreadGroup 的 interrupt</h2><p>interrupt 一个 ThreadGroup 会导致该 group 中所有的 active 线程都被 interrupt，也就是说该 group 中所有子线程的 interrupt 标识都被设置了。</p><h2 id="ThreadGroup-的-destroy"><a href="#ThreadGroup-的-destroy" class="headerlink" title="ThreadGroup 的 destroy"></a>ThreadGroup 的 destroy</h2><p>destroy 用于销毁 ThreadGroup，该方法只是针对一个没有任何 active 线程的 group 进行一次 destroy 标记，调用该方法的直接结果是在父 group 中将自己移除，调用 destroy 方法的前提是该 ThreadGroup 中所有的线程必须是空的，也就是说所有线程包括子 group 中所有线程都已经停止运行，如果有 active 线程存在，调用 destroy 方法则会抛出异常。</p><h2 id="守护-ThreadGroup"><a href="#守护-ThreadGroup" class="headerlink" title="守护 ThreadGroup"></a>守护 ThreadGroup</h2><p>线程可以设置为守护线程，ThreadGroup 也可以设置为守护 ThreadGroup，但是将一个 ThreadGroup 设置为 daemon，并不会影响线程的 daemon 属性，如果一个 ThreadGroup 被设置为守护，那么在该 group 中没有任何 active 线程的时候该 group 将自动 destroy。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>五、【Java并发】JMM之happens-before</title>
      <link href="/javaThread/thread5/"/>
      <url>/javaThread/thread5/</url>
      
        <content type="html"><![CDATA[<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><blockquote><p>happens-before是Java内存模型最核心的概念，因此理解happens-before是理解Java内存模型的关键。</p></blockquote><p>在Java语言中有个happens-before(先行发生)的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依据，依靠这个原则，我们就可以解决在并发环境中两个操作之间可能存在冲突的所有问题。下面我们来看个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>; <span class="comment">//A线程执行</span></span><br><span class="line">j = i; <span class="comment">//B线程执行</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">//C线程执行</span></span><br></pre></td></tr></table></figure></p><p>这里我们分两个情况来分析：</p><ul><li>线程C不执行<br>  假设A线程先行发生于线程B，根据先行发生原则那么就可以确定线程B执行完后，j一定等于1。</li><li>线程C执行<br>  我们依然保持线程A先行与B线程，但此时线程C出现在线程A,B之间,假设线程C与线程B之间没有先行发生原则的话，此时j的值就不确定了！！！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就可能读取到过期数据的风险，不具备多线程安全性。</li></ul><h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>Java内存模型下自带了写先行发生原则，这些先行发现原则无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在其中，并且无法从下面的规则推导出来的话，它们就没有顺序性保障，因为虚拟机可以对它们随意的进行重排序。</p><ul><li><p>程序次序规则：一个线程内，按照代码编写顺序，写在前面的操作happens-before写在后面的操作。但还是有可能指令重排，但随便怎么排，最后的结果应该和重排前代码顺序的结果是一致的。</p></li><li><p>管程锁定规则：对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。(管程是一种通用的同步术语，synchronized就是管程的实现)</p></li><li><p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果对读的这个线程是可见的。对一个volatile变量的写操作happens-before后面对这个变量的读操作(这里针对的是指令重排)；</p></li><li><p>线程启动规则：Thread对象的start()方法happens-before此线程的每一个动作；在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p></li><li><p>线程终止规则：线程中所有的操作都happens-before线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p></li><li><p>线程中断规则：对线程interrupt()方法的调用happens-before被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p></li><li><p>传递规则：就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p></li><li><p>对象终结规则：就是一个对象的初始化的完成，也就是构造函数执行的结束一定happens-before它的finalize()方法。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四、【Java并发】线程间通信之wait,notify,notifyAll</title>
      <link href="/javaThread/thread4/"/>
      <url>/javaThread/thread4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>在多线程编程当中，很多时候我们需要一个线程修改了某个值之后，而另外一个线程能够感知到变化从而进行响应的操作。比较笨的方法呢就是不断轮询判断，如果条件满足进行响应的操作，反之则等待若干时间后再次轮询判断。就如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断)&#123; </span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure></p><p>上面这段伪代码看似能够实现所需的功能，但是却有着很严重的问题：</p><ul><li>难以确保及时性。在休眠的时候，确实不会消耗处理器资源，但是通过睡眠机制，就不能及时的发现条件已经变化。</li><li>难以降低开销。如果降低睡眠的时间，比如1毫秒，这样确实能迅速的发现条件变化，但是却可能消耗更多的处理器资源，造成不必要的浪费。</li></ul><p>以上两个问题，看似矛盾难以取舍。但是Java通过等待/通知机制就能很好的解决问题并实现所需的功能。</p><h2 id="初识-wait-amp-notify"><a href="#初识-wait-amp-notify" class="headerlink" title="初识 wait &amp; notify"></a>初识 wait &amp; notify</h2><p>等待/通知相关方法是任意Java对象都具备的，因为这些方法是被定义在java.lang.Object对象上的，方法描述如下</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>notify()</td><td>通知一个在对象上等待的线程，使其从wait()方法返回，返回的前提是该线程重新获取到了对象的锁</td></tr><tr><td>notifyAll()</td><td>通知所有等待在改对象上的线程</td></tr><tr><td>wait()</td><td>调用该方法的线程进入阻塞状态并且会释放对象的锁，只有等待其他线程通知或被终端才会返回，</td></tr><tr><td>wait(long)</td><td>等待指定一段时间，时间一到就返回</td></tr><tr><td>wait(long,int)</td><td>等待指定一段时间，对于超时时间更加细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object  lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 开始"</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" wait 结束"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 开始工作"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">                    <span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 开始"</span>);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" notify 完成 开始睡眠"</span>);</span><br><span class="line">                    SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"睡眠结束即将释放锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出内容：<br><img src="https://upload-images.jianshu.io/upload_images/1455014-d2bb1f5e464ca80f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>通过上面的示例代码，会发现使用wait/notfiy相关方法时需要注意一下细节：</p><ul><li>使用wait(),notify(),notifyAll()时需要先获取到该对象的锁。</li><li>使用wait()方法会使线程进入阻塞状态，并且会释放锁。</li><li>调用notify(),notifyAll()方法后，被通知的线程依旧不会从wait返回，需要调用notify()方法的线程释放锁之后，并且等待的线程重新获取到锁之后才会返回。</li><li>notify()方法是将等待队列中的一个等待线程从等待队列移到同步队列中，而notifyAll()方法是讲等待队列中的所有线程全部移到同步队列中</li></ul><h2 id="wait-amp-sleep-的区别"><a href="#wait-amp-sleep-的区别" class="headerlink" title="wait &amp; sleep 的区别"></a>wait &amp; sleep 的区别</h2><p>从表面上来看，wait和sleep都能使当前线程进入阻塞状态，但两者还是有着本质上的区别：</p><ul><li>wait和sleep方法都可以使线程进入阻塞状态，并且均是可中断方法，被中断后都会收到中断异常。</li><li>wait是Object方法，sleep是Thread独有的方法。</li><li>wait需要在同步方法中调用，而sleep不需要。</li><li>wait方法会释放锁，而sleep方法并不会释放锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三、【Java并发】线程安全之synchronized的原理和应用</title>
      <link href="/javaThread/thread3/"/>
      <url>/javaThread/thread3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Synchronized的实现原理与应用"><a href="#Synchronized的实现原理与应用" class="headerlink" title="Synchronized的实现原理与应用"></a>Synchronized的实现原理与应用</h2><p>在多线程并发编程中线程安全和数据同步一直以来都是不可避免的问题，在JDK1.5版本之前，要解决这个问题需要使用synchronized关键字，synchronized提供了一种排他机制，也就是在同一时间只能有一个线程执行某些操作，很多人都会称呼它为重量级锁，但是随着JDK1.6对synchronized进行了各种优化之后，有些情况下它就并不会显得那么重了。下面我们一起来探究synchronized的实现原理，以及JDK1.6是如何对它进行优化，以及锁的存储结构和升级过程。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性问题，如果一个共享资源对多个线程是可见的，那么该资源的所有读或者写都将通过同步的方式来进行，具体表现如下：</p><ul><li>synchronized提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题得出现</li><li>synchronized在JVM中实现原理是基于进入和退出Monitor对象来实现方法的同步和代码块同步。<ul><li>同步代码块是使用monitorenter 和 monitorexit两个JVM指令实现的。monitorenter指令是在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法结束处和异常处。</li><li>在任何时候任何线程执行到monitorenter成功之前都必须从主内存中获取数据，在monitorexit运行成功之后，共享资源被更新后的值必须刷入主内存。</li></ul></li><li>synchronized的指令严格遵守java happens-before规则，一个monitorexit指令之前必定要有一个monitorenter指令。</li><li>Java中每个对象都可以作为锁，这是synchronized实现同步的基础，具体表现形式如下<ul><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，所示当前类的Class对象</li><li>对于同步方法块，锁是synchronized括号里设置的对象</li></ul></li></ul><h2 id="synchronized堆栈分析-amp-JVM指令分析"><a href="#synchronized堆栈分析-amp-JVM指令分析" class="headerlink" title="synchronized堆栈分析&amp;JVM指令分析"></a>synchronized堆栈分析&amp;JVM指令分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;当前线程:&quot;+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ThreadTest test = new ThreadTest();</span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，在test方法中使用同步代码块方式进行的线程同步，在main方法中定义了2个线程调用test方法，由于同步代码块的互斥性，只能有一个线程获取了mutex monitor的锁，其它的线程只能进入阻塞状态，等待获取mutex monitor的锁的线程释放锁，我可以用JDK自带的工具jconsole来查看堆栈信息，运行上面代码，打开jconsole会看到如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-5262ffd168735d45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>然后我们选中我们运行的程序连接，然后点开线程一栏查看：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1455014-319ed4f8b251044e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/1455014-2e4c0ec5e0ce92aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>我们可以很清楚看到我们创建的两个线程，Thread-0和Thread-1，此时Thread-0处于RUNNABLE状态也就是就绪状态，而Thread-1处于BLOCKED状态，并且清楚的告诉了我们锁拥有者是Thread-0线程。我们再通过jstack命令打印进程的线程的堆栈信息，截取关键的地方对其进行分析：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1455014-1c1be84c051de7de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>Thread-0持有monitor <0x00000007976030e0> 的锁，Thread1线程进入BLOCKED状态并且等待着获取monitor <0x00000007976030e0>。</0x00000007976030e0></0x00000007976030e0></p><p>下面我们再通过JDK命令javap对ThreadTest类进行反汇编，会发现输出了大量的JVM指令，在这些指令中，会发现monitor enter和monitor exit是成对出现的（有些时候会出现一个monitor enter，多个monitor exit，但是每一个monitor exit之前必有对应的monitor enter)，运行如下的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c ThreadTest</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">yuxuan</span>.<span class="title">thread2</span>.<span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.yuxuan.thread2.ThreadTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">10</span>: dup</span><br><span class="line">      11: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      14: ldc           #5                  // String 当前线程:</span><br><span class="line">      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      19: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      22: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">34</span>: aload_1</span><br><span class="line">      <span class="number">35</span>: monitorexit</span><br><span class="line">      <span class="number">36</span>: goto          <span class="number">44</span></span><br><span class="line">      <span class="number">39</span>: astore_2</span><br><span class="line">      <span class="number">40</span>: aload_1</span><br><span class="line">      <span class="number">41</span>: monitorexit</span><br><span class="line">      <span class="number">42</span>: aload_2</span><br><span class="line">      <span class="number">43</span>: athrow</span><br><span class="line">      <span class="number">44</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="Monitorenter"><a href="#Monitorenter" class="headerlink" title="Monitorenter"></a>Monitorenter</h3><p>一个monitor的lock的锁只会被一个线程在同一时间获得，在一个线程尝试获取monitor的所有权时会发生下面几件事：</p><ul><li>如果monitor的计数器为0，则代表该monitor的lock还没有被获得，一旦被某个线程获得之后会即将对该monitor的计数器加一，也就意味着该线程就是这个monitor的所有者了。</li><li>如果一个已经拥有该monitor所有权的线程重入，则会导致monitor计数器累加。</li><li>如果monitor已经被其他线程拥有，则其他线程尝试获取该monitor所有权时，会陷入阻塞状态直到monitor计数器变为0，才能再次尝试获取monitor的所有权</li></ul><h3 id="Monitorexit"><a href="#Monitorexit" class="headerlink" title="Monitorexit"></a>Monitorexit</h3><p>释放monitor所有权的过程相对比较简单，就是将monitor的计数器减一，如果计数器为0，那就意味着该线程不再拥有对该monitor的所有权，也就是我们常说的解锁。在此同时被该monitor block的线程将再次尝试获取该monitor的所有权。</p><h2 id="使用synchronized的注意点"><a href="#使用synchronized的注意点" class="headerlink" title="使用synchronized的注意点"></a>使用synchronized的注意点</h2><ul><li>与monitor关联的对象不能为空，也就是锁对象不能为null。</li><li>synchronized作用于太大，如果synchronized作用于越大，则代表期效率越低。</li><li>不同的monitor企图锁相同的方法或者代码块。</li><li>多个锁的交叉从而导致死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、【Java并发】线程生命周期以及常用方法详解</title>
      <link href="/javaThread/thread2/"/>
      <url>/javaThread/thread2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>每个线程都有自己的生命周期，下面我们就来详细的了解一下。 </p><p><img src="https://upload-images.jianshu.io/upload_images/1455014-34eb0171effba7ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>从上图我们可以看出线程的生命周期大致可以分为五个阶段：</p><ul><li>NEW(新建状态)</li><li>RUNNABLE(就绪状态)</li><li>RUNNING(运行状态)</li><li>BLOCKED(阻塞状态)</li><li>TERMINATED(死亡状态)</li></ul><h3 id="NEW-新建状态"><a href="#NEW-新建状态" class="headerlink" title="NEW(新建状态)"></a>NEW(新建状态)</h3><p>当我们new一个Thread对象时，此时它并不处于运行状态，因为还没有调用start方法启动线程。那么线程的NEW状态，其实只是Thread对象的状态，在没有调用start方法之前，该线程根本不存在，和new一个普通的Java对象没什么区别。NEW状态可以通过start方法进入RUNNABLE状态。</p><h3 id="RUNNABLE-就绪状态"><a href="#RUNNABLE-就绪状态" class="headerlink" title="RUNNABLE(就绪状态)"></a>RUNNABLE(就绪状态)</h3><p>线程对象进入RUNNABLE状态必须调用start方法，此时JVM进程中才会真正的创建一个线程，线程启动后并不会立即得到执行。线程是否运行和进程一样都要听从CPU的调度，为此我们把这个中间状态成为就绪状态，也称为可执行状态(RUNNABLE),也就是说它具备执行的资格，但是并没有真正的执行而是在等待CPU的调度。</p><p>由于存在Running状态，所以不会直接进人BLOCKED状态和TERMINATED状态，即使是在线程的执行逻辑中调用wait、sleep或者其他block的I0操作等，也必须先获得CPU的调度执行权才可以，严格来讲，RUNNABLE的线程只能意外终止或者进人RUNNING状态。</p><h3 id="RUNNING-运行状态"><a href="#RUNNING-运行状态" class="headerlink" title="RUNNING(运行状态)"></a>RUNNING(运行状态)</h3><p>一旦CPU通过时间片轮转或者其他方式选中了线程，那么此时它才能真正的执行自己的逻辑。这里需要注意的一点是一个正在RUNNING状态的线程其实也是RUNNABLE的，但是反过来则不成立。<br>在RUNNING状态中，线程的状态可以发生如下的状态转换：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者判断某个逻辑标识。</li><li>进人BLOCKED状态，比如调用了sleep,或者wait方法而加入了waitSet 中。</li><li>进行某个阻塞的I0操作，比如因网络数据的读写而进入了BLOCKED状态。</li><li>获取某个锁资源，从而加入到该锁的阻塞队列中而进人了BLOCKED状态。</li><li>由于CPU的调度器轮询使该线程放弃执行，进人RUNNABLE状态。</li><li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态。</li></ul><h3 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED(阻塞状态)"></a>BLOCKED(阻塞状态)</h3><p>上面列举了线程进入BLOCKED状态的原因，下面我们在列举线程在BLOCKED状态中可能切换的状态：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡(JVM Crash)。</li><li>线程阻塞的操作结束，比如读取了想要的数据字节进人到RUNNABLE状态。</li><li>线程完成了指定时间的休眠，进人到了RUNNABLE状态。</li><li>Wait中的线程被其他线程notify/notifyall唤醒，进人RUNNABLE状态。</li><li>线程获取到了某个锁资源，进人RUNNABLE状态。</li><li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进人RUNNABLE状态。</li></ul><h3 id="TERMINATED-死亡状态"><a href="#TERMINATED-死亡状态" class="headerlink" title="TERMINATED(死亡状态)"></a>TERMINATED(死亡状态)</h3><p>TERMINATED状态是线程最终状态，在该状态的线程不会再切换到其它任何状态，意味着线程的整个生命周期都结束了。</p><h2 id="Thread-API详解"><a href="#Thread-API详解" class="headerlink" title="Thread API详解"></a>Thread API详解</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><blockquote><p>sleep是一个静态方法，其有两个重载方法，其中一个需要传入毫秒，另外一个既需要毫秒数，还需要纳秒数<br>public static native void sleep(long millis) throws InterruptedException;<br>public static void sleep(long millis, int nanos) throws InterruptedException</p></blockquote><p>sleep方法会使当前线程休眠指定的毫秒数，暂停执行，其中有个要注意的点，sleep并不会释放锁资源。</p><p>JDK1.5以后，JDK引入了一个枚举TimeUnit，其对sleep做了很好的封装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一天</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一小时</span></span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一毫秒</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield也是一个静态方法，调用此方法会提醒调度器我愿意放弃当前的cpu资源，如果CPU资源不紧张的话，调度器可能会忽略这个提醒。操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度，而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片中还没有使用完的部分自己不想使用了，这暗示线程调度器现在就可以进行下一轮的线程调度。</p><blockquote><p>sleep 与 yield 方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂 起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield 方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。</p></blockquote><h3 id="setPriority-amp-getPriority-线程优先级"><a href="#setPriority-amp-getPriority-线程优先级" class="headerlink" title="setPriority()&amp;getPriority() 线程优先级"></a>setPriority()&amp;getPriority() 线程优先级</h3><p>在操作系统中，进程有优先级之分，线程同样也有优先级，理论上优先级高的线程有被CPU优先调度的机会，但真实情况往往并不会如你所愿，因为设置线程优先级也是一个hint(暗示)操作。</p><ul><li>对于root用户，它会hint操作系统你想要设置的优先级别，否则它会被忽略。</li><li>在CPU比较忙的情况下，设置优先级可能会获取更多的CPU调度机会，但是闲时优先级的高低一般不会有任何作用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//简单来看看设置优先级方法的源码</span><br><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        if((g = getThreadGroup()) != null) &#123;</span><br><span class="line">            if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析如上代码，可以看出线程的优先级必须是1~10，如果指定的线程优先级大于线程所在的group的优先级，那么会忽略指定的优先级从而获取group的最大优先级。线程默认的优先级和创建它的那个线程保持一致，一般情况下都是5.</p><h3 id="获取线程ID-getId"><a href="#获取线程ID-getId" class="headerlink" title="获取线程ID getId()"></a>获取线程ID getId()</h3><p>getId()获取线程的唯一ID,线程的ID在整个JVM进程中都是唯一的。</p><h3 id="线程-interrupt相关方法"><a href="#线程-interrupt相关方法" class="headerlink" title="线程 interrupt相关方法"></a>线程 interrupt相关方法</h3><ul><li><p>interrupt()方法<br>在线程内部存在着名为interrupt flag的标识，如果一个线程调用了interrupt方法，flag会被设置，但是如果当前线程正处于阻塞状态时，调用interrupt，线程将会中断阻塞，并且会抛出InterruptedException异常，这个异常就像是一个signal(信号)一样通知当前线程被打断了，并且flag会被清除。</p></li><li><p>isInterrupted()方法<br>此方法是Thread类的实例方法，主要判断当前线程是否被中断。</p></li><li><p>interrupted()方法<br>此方法是Thread中的一个静态方法，也是主要用于判断当前线程是否被中断，但是它和isInterrupted()方法有个区别就是该方法会直接清除掉该线程的interrupt标识</p></li></ul><h3 id="线程join方法"><a href="#线程join方法" class="headerlink" title="线程join方法"></a>线程join方法</h3><p>join方法会使当前线程永远的等待下去，直到期间被另外的线程中断，或者join的线程执行结束，也可以使用另外两个重载方法，指定等待毫秒数，在指定的时间到达之后，当前线程也回退出阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join() 一直等待</span><br><span class="line">join(long millis) 等待指定毫秒数</span><br><span class="line">join(long millis, int nanos) 等待指定毫秒数</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一、【Java并发】初识线程</title>
      <link href="/javaThread/thread1/"/>
      <url>/javaThread/thread1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h2><p>对于计算机来说每一个任务就是一个进程，在进程运行过程中必须至少有一条线程实在运行中。线程本身是不会独立存在的，因为线程是进程中的一个执行路径。</p><p>操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU 分配的基本单位。在Java中，当我们启动main函数时其实就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p><blockquote><p>在单核CPU的计算机中，其实并没有真正的并行运算，一般是使用时间片轮转方式让线程轮询占用的，只不过快速的轮转调度带给你的错觉，让你产生了它们真的在同一时刻同时运行。当然如果是多核CPU,那么并行运行还是真实存在的。</p></blockquote><h2 id="2-JAVA中的线程创建和运行"><a href="#2-JAVA中的线程创建和运行" class="headerlink" title="2.JAVA中的线程创建和运行"></a>2.JAVA中的线程创建和运行</h2><p>Java中有三种线程的创建方式，分别为实现Runnable接口的run方法，集成Thread类重写run方法，使用FutureTask方式。</p><h3 id="首先来看看Thread类方式的实现"><a href="#首先来看看Thread类方式的实现" class="headerlink" title="首先来看看Thread类方式的实现"></a>首先来看看Thread类方式的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//继承Thread,重写run方法</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        //创建线程</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        //启动线程</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出MyThread类继承了Thread类，并重写了run()方法。在 main 函数中创建了MyThread的实例并调用了start方式启动了线程。</p><p>使用继承有个不好的地方就是Java是不支持多继承的，所以如果使用了继承方式，那么就不能再继承其他类。还有就是任务与代码没有分离，当多个线程执行一样的任务时就会产生代码冗余。而Runable就没有这个限制。下面我们来看看Runnable接口的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//实现Runnable接口</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        </span><br><span class="line">        new Thread(myThread).start();</span><br><span class="line">        new Thread(myThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，两个线程公用了一个代码逻辑，并且MyThread可以继承其他类。但是两种方式都有一个缺点，就是任务没有返回值。下面我们可以来看看FutureTask方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//实现Callable接口</span><br><span class="line">class MyThread implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        //创建任务</span><br><span class="line">        MyThread myThread = new MyThread();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myThread);</span><br><span class="line">        </span><br><span class="line">        //启动线程</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            //等待任务执行完成,并返回结果</span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的MyThread类实现了Callable接口的call()方法。在main函数中创建了一个FutrueTask对象，然后使用FutrueTask对象作为任务创建一个线程并启动。最后通过get()等待任务执行完成拿到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（八）适配器模式</title>
      <link href="/designPattern/designPattern8/"/>
      <url>/designPattern/designPattern8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器等。在软件设计中也可能出现，需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p><p>适配器模式在编程过程中是一个经常用到的模式，它的作用是将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h2 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h2><p>适配器模式分为类结构型模式和对象结构 型模式两种，前者类之间的稠合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>该模式主要优点如下：</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul><li>目标接口（Target）：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者类（Adaptee）：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器类（Adapter）：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h3 id="类适配器模式实现"><a href="#类适配器模式实现" class="headerlink" title="类适配器模式实现"></a>类适配器模式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用适配者中的代码!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类适配器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试:"</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码实现了一个非常简单的类适配器模式，结构图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1455014-ca53429bb2c160df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="对象适配器模式实现"><a href="#对象适配器模式实现" class="headerlink" title="对象适配器模式实现"></a>对象适配器模式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用适配者中的代码!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象适配器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象适配器模式测试:"</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码实现了一个非常简单的对象适配器模式。</p><p>上述两种适配器的实现方式，可以看到，大部分情况下，两种适配器都可以满足转换接口的需求，但是它们之间还是有一定差别的，具体如下表：</p><table><thead><tr><th style="text-align:center">条件</th><th style="text-align:center">类适配器</th><th style="text-align:center">对象适配器</th></tr></thead><tbody><tr><td style="text-align:center">是否可以适配一系列继承类</td><td style="text-align:center">不可以（源类的子类不行）</td><td style="text-align:center">可以（多态）</td></tr><tr><td style="text-align:center">是否可以修改源类功能</td><td style="text-align:center">可以（多态）</td><td style="text-align:center">不可以</td></tr><tr><td style="text-align:center">结构性质</td><td style="text-align:center">静态</td><td style="text-align:center">动态</td></tr><tr><td style="text-align:center">耦合度</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">是否违反类的单一职责原则</td><td style="text-align:center">违反（满足两个接口）</td><td style="text-align:center">不违反</td></tr></tbody></table><p>由此可见，在编程中通常倾向于使用对象适配器从而实现程序更大的灵活性。这个结果也体现了面向对象的一个设计原则 “有线使用组合，而非继承”。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>在超市的家电区，有着各种各样的电器，它们的电源插头多种多样，遵循不同的标准，但是超市的壁式插座只提供标准的二相插座，怎样才能把不同的电器都连接上呢？</p><p>下面我们用对象适配器模式来模拟解决：</p><h3 id="原有系统接口（电器自带的插头）"><a href="#原有系统接口（电器自带的插头）" class="headerlink" title="原有系统接口（电器自带的插头）"></a>原有系统接口（电器自带的插头）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原有的系统接口</span></span><br><span class="line"><span class="comment"> * 带地线的插头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWithEarthWritePlug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> liveWrite 火线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nullWrite 零线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> earthWire 地线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plug</span><span class="params">(String liveWrite,String nullWrite,String earthWire)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新系统接口（壁挂插座要求的插头）"><a href="#新系统接口（壁挂插座要求的插头）" class="headerlink" title="新系统接口（壁挂插座要求的插头）"></a>新系统接口（壁挂插座要求的插头）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前系统期望的接口,也就是 目标接口</span></span><br><span class="line"><span class="comment"> * 不接地线的两相插头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INoEarthWirePlug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> liveWrite 火线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nullWrite 零线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plug</span><span class="params">(String liveWrite,String nullWrite)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源类（实现了源接口）"><a href="#源类（实现了源接口）" class="headerlink" title="源类（实现了源接口）"></a>源类（实现了源接口）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配者</span><br><span class="line"> * 电视机自带接地线插头</span><br><span class="line"> **/</span><br><span class="line">public class TVPlug implements IWithEarthWritePlug&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void plug(String liveWrite, String nullWrite, String earthWire) &#123;</span><br><span class="line">        //接通电源,电视机就可以打开了</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line">    private void play()&#123;</span><br><span class="line">        System.out.println(&quot;打开电视机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上两个接口可以看出，方法的定义是不同的，客户端无法直接使用原有接口，也就是说电视机无法直接使用原有接口，因为壁挂插座是两头的。</p><h3 id="适配器类（对象适配器）"><a href="#适配器类（对象适配器）" class="headerlink" title="适配器类（对象适配器）"></a>适配器类（对象适配器）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类(对象适配器)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plug3to2Adapter</span> <span class="keyword">implements</span> <span class="title">INoEarthWirePlug</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IWithEarthWritePlug adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plug</span><span class="params">(String liveWrite, String nullWrite)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//街上两根线,地线悬空</span></span><br><span class="line">        adaptee.plug(<span class="string">"火线"</span>,<span class="string">"零线"</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plug3to2Adapter</span><span class="params">(IWithEarthWritePlug adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器客户端代码"><a href="#适配器客户端代码" class="headerlink" title="适配器客户端代码"></a>适配器客户端代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标接口,使用适配器对源类进行转换</span><br><span class="line">        INoEarthWirePlug tvPlug = new Plug3to2Adapter(new TVPlug());</span><br><span class="line">        //按目标接口的格式访问适配者</span><br><span class="line">        tvPlug.plug(&quot;火线&quot;,&quot;零线&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里采用了构造时传入源对象(也就是电视机)。在声明 adaptee 属性时使用了接口，可以适配同一类的源对象，比如假设还有一种电冰箱是三相插头的，也需要做转换，也可以使用此适配器，只要在构造的时候传入电冰箱源类就行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而此类的接口不符合系统的要求。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。</li><li>对对象适配器而言，在设计里，需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。</li></ul><p>适配器模式允许我们使用现有类进行扩展来满足客户类的需求。当现有的类不能满足客户需要的接口时，通常可以创建一个新类来实现接口和扩展现有类。这种方法会创建一个类适配 器，它将把客户的调用转变为调用现有类的方法。除此之外，还可以使用现有类的实例来创建一个新的客户子类。这种方法会创建一个对象适配器，将客户调用转发给现有类的实例。这两种方法分别为类适配器和对象适配器。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（七）原型模式</title>
      <link href="/designPattern/designPattern7/"/>
      <url>/designPattern/designPattern7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象， 会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p><h2 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h2><p>原型（Prototype）模式的定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p><h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><p>原型模式包含以下主要角色:</p><ul><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的clone() 方法，它是可被复制的对象。</li><li>使用类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。使用了克隆的方式产生新的对象，新生成的对象也可以 根据需要稍做修改以适应需求。</p><blockquote><p>这个时候有同学就会问为什么 Object 里提供了 clone 方法，为什么还需要实现 Cloneable 接口。<br>Java语言虽然提供了这个方法，但考虑到安全问题，一方面将 clone() 方法的访问级别设置为 protected，以限制外部类访问。另一方面，强制需要提供 clone 功能的子类实现 java.lang.Cloneable 接口。在运行期，JVM 会检查调用 clone() 方法的类，如果该类未实现 java.lang. Cloneable 接口。则抛出 CloneNotSupportedException 异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name,Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())+ <span class="string">"=&gt;&gt;Goods&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", date="</span> + date +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Goods a = <span class="keyword">new</span> Goods(<span class="string">"面包"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        Goods clone = (Goods) a.clone();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(a.date==clone.date);</span><br><span class="line">        System.out.println(a==clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码简单实现了原型模式的克隆。我们可以看下运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.yuxuan.learning.design.patterns.creative.prototype.Goods@3cd1f1c8=&gt;&gt;Goods&#123;name=&apos;面包&apos;, date=Tue Aug 1 14:27:17 CST 2012&#125;</span><br><span class="line">com.yuxuan.learning.design.patterns.creative.prototype.Goods@6979e8cb=&gt;&gt;Goods&#123;name=&apos;面包&apos;, date=Tue Aug 1 14:27:17 CST 2012&#125;</span><br><span class="line">goods==clone? false</span><br><span class="line">goods.date==clone.date?true</span><br></pre></td></tr></table></figure></p><p>由结果可见，生成后的对象和源对象在内存中的确是两个不同的地址，而且生成后的对象与源对象中的属性是完全一样的。</p><p>但是，仔细一看会发现一个问题，就是虽然新对象和源对象不是一样的对象，但是其中的属性对象和源对象的属性对象共享一个对象，比如上面的 date 属性。</p><h2 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h2><p>浅克隆与深克隆的区别：</p><ul><li>浅克隆：被复制的所有变量都具有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。</li><li>深克隆：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</li></ul><p>很显然上面实现的是一个浅克隆，因为克隆出来的对象的 date 属性和源对象的 date 属性指向的还是同一个对象地址。</p><p>下面我们调整一下 clone 方法里的代码，具体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name,Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode())+ <span class="string">"=&gt;&gt;Goods&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", date="</span> + date +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Goods goods = (Goods)<span class="keyword">super</span>.clone();</span><br><span class="line">        goods.date = (Date) <span class="keyword">this</span>.date.clone();</span><br><span class="line">        <span class="keyword">return</span> goods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Goods goods = <span class="keyword">new</span> Goods(<span class="string">"面包"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        Goods clone = (Goods) goods.clone();</span><br><span class="line">        System.out.println(goods);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(<span class="string">"goods==clone? "</span>+(goods==clone));</span><br><span class="line">        System.out.println(<span class="string">"goods.date==clone.date?"</span>+(goods.date==clone.date));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在来看一下运行结果过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.yuxuan.learning.design.patterns.creative.prototype.Goods@3cd1f1c8=&gt;&gt;Goods&#123;name=&apos;面包&apos;, date=Tue Aug 1 14:46:25 CST 2012&#125;</span><br><span class="line">com.yuxuan.learning.design.patterns.creative.prototype.Goods@6979e8cb=&gt;&gt;Goods&#123;name=&apos;面包&apos;, date=Tue Aug 1 14:46:25 CST 2012&#125;</span><br><span class="line">goods==clone? false</span><br><span class="line">goods.date==clone.date?false</span><br></pre></td></tr></table></figure></p><p>从运行结果我们不难看出，现在 date 属性指向的不是同一个对象了。现在就是深克隆了。</p><blockquote><p>需要注意的是，clone 方法只会进行复制，并不会调用被复制实例的构造函数。对于在生成实例时需要进行特殊的初始化处理的类，需要自己在 clone 方法中进行处理。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型模式为我们提供了另外一种高效创建对象的方法。使用原型模式，我们可以不了解原型对象的任何细节以及它内部 的层次的结构，不影响，但是必须要实现特定的接口。当需要的对象需要从现有的对象中复制时,通常适合使用原型模式。</p><p>原型模式和工厂模式的区别 ：</p><ul><li>原型模式可以选择维护一个产品的原型对象，并在方法中返回原型对象的克隆。</li><li>工厂模式直接返回新的产品对象，此对象是根据类中的代码新创建的。</li></ul><p>原型模式也有它的缺点。每一个原型的子类都必须实现 Clone 操作，这可能会很困难。 例如，当所使用此模式的类已经存在时就难以新增 Clone 操作。当内部包括一些不支持拷贝或由循环引用的对象时，实现克隆可能也会很困难。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（六）建造者模式</title>
      <link href="/designPattern/designPattern6/"/>
      <url>/designPattern/designPattern6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>建造者模式是一种较为复杂的创建型模式,它将客户端与包含多个组成部分的复杂对象的创建过程分离,客户端无须知道复杂对象的内部组成部分与装配方式,只需要知道所需建造者的类型即可。建造者模式关注如何一步一步地创建一个复杂对象，不同的具体建造者定义了不同的创建过程,而且具体建造者相互独立，更换建造者或增加新的建造者非常方便,系统具有较好的扩展性。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="建造者模式的组成"><a href="#建造者模式的组成" class="headerlink" title="建造者模式的组成"></a>建造者模式的组成</h3><blockquote><ol><li>抽象构建者(Builder): 它为创建一个复杂对象中各个属性指定抽象接口，用于创建复杂对象的各个属性。抽象返回创建完成的复杂对象方法。Builder可以是抽象类，也可以是接口。</li><li>具体建造者(ConcreteBuilder): 它实现 Builder 接口，实现各个属性的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂对象。</li><li>构建的产品对象(Product): 它是被构建的复杂对象，包含多个属性，具体建造者创建该对象的内部实现并定义它的装配过程。</li><li>指挥者(Director): 指挥者类，他负责安排复杂对象的建造顺序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法调用建造者对象的属性构建与装配方法，完成复杂对象的建造。</li></ol></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面我们就用建造者模式来描述一个简单的客厅装修。</p><h3 id="被构建的产品对象"><a href="#被构建的产品对象" class="headerlink" title="被构建的产品对象"></a>被构建的产品对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客厅</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/29 19:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parlour</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 墙</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地面瓷砖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String floorTile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sofa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWall</span><span class="params">(String wall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFloorTile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floorTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloorTile</span><span class="params">(String floorTile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.floorTile = floorTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSofa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sofa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSofa</span><span class="params">(String sofa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sofa = sofa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Parlour&#123;"</span> +</span><br><span class="line">                <span class="string">"wall='"</span> + wall + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", floorTile='"</span> + floorTile + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sofa='"</span> + sofa + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象建造者和具体建造者"><a href="#抽象建造者和具体建造者" class="headerlink" title="抽象建造者和具体建造者"></a>抽象建造者和具体建造者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象建造者</span><br><span class="line"> **/</span><br><span class="line">public abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">    protected Parlour parlour = new Parlour();</span><br><span class="line"></span><br><span class="line">    public abstract void buildWall();</span><br><span class="line">    public abstract void buildFloorTile();</span><br><span class="line">    public abstract void buildSofa();</span><br><span class="line"></span><br><span class="line">    public Parlour getResult()&#123;</span><br><span class="line">        return parlour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 具体建造者</span><br><span class="line"> * 装修师傅 A</span><br><span class="line"> **/</span><br><span class="line">public class BuilderImplA extends Builder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildWall() &#123;</span><br><span class="line">        parlour.setWall(&quot;纯白色的墙面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildFloorTile() &#123;</span><br><span class="line">        parlour.setFloorTile(&quot;格子花纹瓷砖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildSofa() &#123;</span><br><span class="line">        parlour.setSofa(&quot;真皮沙发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 具体建造者</span><br><span class="line"> * 装修师傅 B</span><br><span class="line"> **/</span><br><span class="line">public class BuilderImplB extends Builder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildWall() &#123;</span><br><span class="line">        parlour.setWall(&quot;天蓝色的墙面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildFloorTile() &#123;</span><br><span class="line">        parlour.setFloorTile(&quot;咖啡色条纹木质瓷砖&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildSofa() &#123;</span><br><span class="line">        parlour.setSofa(&quot;纯棉沙发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> * 项目经理</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direcotr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parlour <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildWall();</span><br><span class="line">        builder.buildFloorTile();</span><br><span class="line">        builder.buildSofa();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builderA = <span class="keyword">new</span> BuilderImplA();</span><br><span class="line">        Builder builderB = <span class="keyword">new</span> BuilderImplB();</span><br><span class="line"></span><br><span class="line">        Direcotr direcotr = <span class="keyword">new</span> Direcotr();</span><br><span class="line">        direcotr.setBuilder(builderA);</span><br><span class="line">        Parlour constructA = direcotr.construct();</span><br><span class="line"></span><br><span class="line">        direcotr.setBuilder(builderB);</span><br><span class="line">        Parlour constructB = direcotr.construct();</span><br><span class="line"></span><br><span class="line">        System.out.println(constructA);</span><br><span class="line">        System.out.println(constructB);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现类图大致如下"><a href="#实现类图大致如下" class="headerlink" title="实现类图大致如下"></a>实现类图大致如下</h3><p><img src="https://upload-images.jianshu.io/upload_images/1455014-fc440ac45d5577ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建造者模式主要用于创建一些复杂的对象， 这些对象内部的建造顺序通常是稳定的，但对 象内部的构建通常面临复杂的变化。建造者模式的好处就是使得构造代码与表示代码分离， 由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</p><h3 id="与其他模式的区别"><a href="#与其他模式的区别" class="headerlink" title="与其他模式的区别"></a>与其他模式的区别</h3><ul><li>简单工厂模式：又叫静态工厂方法模式，它定义一个具体的工厂类，通过用静态方法来负责创建一些类的实例。也就是说，这个类集合了部分功能的类似或近似类的实例化，但工厂类无法被继承（只有一个工厂类，通过该类中静态方法来创建产 品类的对象，随着产品类的增多，该静态方法也越来越复杂和难以维护）。</li><li>工厂方法模式：通过一个工厂类来完成对象的实例化。工厂模式在调用的时候需要先实例化工厂类。根据不同的产品创建不同的工厂类来返回实例。</li><li>抽象工厂模式：它分为抽象工厂类、抽象产品类、具体产品类。和工厂模式差不多，区别就是抽象工厂模式把一系列的产品进行统一。抽象工厂模式中，我们会把一系列相似的产品放在一个工厂类里面实例化，和现在车间的流水线差不多，一个流水线负责生产相似的产品，不同的产品需要另一条流水线来生产。工厂模式是针对细微的产品来创建工厂类。</li><li>建造者模式：强调的是控制产品的生产过程，使不同的产品生产可以使用相同的步骤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（五）抽象工厂模式</title>
      <link href="/designPattern/designPattern5/"/>
      <url>/designPattern/designPattern5/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>前面的工厂方法模式中考虑的只是一类产品的生产，如汽车厂只生产汽车，电视机厂只生产电视机等。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类）的产品，如机车厂里既生产传统汽车也生产电动汽车，电器厂既生产电视机又生产洗衣机或空调等。</p><p>为了更清晰地理解工厂方法模式，我们先理解下面两个概念：</p><ul><li><code>产品等级结构</code>：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li><li><code>产品族</code>：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。</p><p>模式结构如下：</p><ul><li><ol><li>抽象工厂(abstract factory): 提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li></ol></li><li><ol start="2"><li>具体工厂实现(real factory): 主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li></ol></li><li><ol start="3"><li>抽象产品(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现。</li></ol></li><li><ol start="4"><li>具体产品实现(real product): 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol></li></ul><p>下面我们就通过设计一个农场例子来熟悉一下抽象工厂吧。</p><h3 id="抽象产品"><a href="#抽象产品" class="headerlink" title="抽象产品"></a>抽象产品</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动物抽象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小动物出生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Animal <span class="title">bornAnimal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 植物抽象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开花结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Plant <span class="title">bloom</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="产品实现"><a href="#产品实现" class="headerlink" title="产品实现"></a>产品实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatAnimal</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">bornAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小猫咪出生啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatAnimal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogAnimal</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">bornAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小旺仔出生啦"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogAnimal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplePlant</span> <span class="keyword">implements</span> <span class="title">Plant</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">bloom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"苹果熟了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplePlant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangePlant</span> <span class="keyword">implements</span> <span class="title">Plant</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">bloom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"橘子熟了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrangePlant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象农场</span><br><span class="line"> */</span><br><span class="line">public interface FramFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建动物</span><br><span class="line">     */</span><br><span class="line">    Animal newAnimal();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建植物</span><br><span class="line">     */</span><br><span class="line">    Plant newPlant();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂实现"><a href="#工厂实现" class="headerlink" title="工厂实现"></a>工厂实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 天天农场</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayDayFramFactory</span> <span class="keyword">implements</span> <span class="title">FramFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">newAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">newPlant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrangePlant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开心农场</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyFramFactory</span> <span class="keyword">implements</span> <span class="title">FramFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">newAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DogAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plant <span class="title">newPlant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplePlant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们就实现了一个非常简单的抽象工厂模式的样例。</p><p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性： </p><ul><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则</li><li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则 。</li></ul><p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（四）工厂方法模式</title>
      <link href="/designPattern/designPattern4/"/>
      <url>/designPattern/designPattern4/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂方法模式又称工厂模式,也叫多态工厂模式,属于类创建型模式<br>工厂方法模式实质就是: 把创建对象的过程抽象出来不实现,让其子类或实现类来决定实例化那个类.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看工厂模式的组成"><a href="#我们先简单的来看看工厂模式的组成" class="headerlink" title="我们先简单的来看看工厂模式的组成:"></a>我们先简单的来看看工厂模式的组成:</h3><blockquote><ol><li>抽象工厂(abstract factory): 抽象对象.</li><li>具体工厂实现(real factory): 实际创建对象的工厂,负责创建一个或多个对象。</li><li>抽象产品(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="抽象Car"><a href="#抽象Car" class="headerlink" title="抽象Car"></a>抽象Car</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* car抽象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 车俩启动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体Car实现"><a href="#具体Car实现" class="headerlink" title="具体Car实现"></a>具体Car实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BMW run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"QQ run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体工厂实现"><a href="#具体工厂实现" class="headerlink" title="具体工厂实现"></a>具体工厂实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BMWCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QQCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a>工厂方法模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在工厂方法模式中，使用方只需要知道所要对象的具体工厂，无须关心具体的创建过程，甚至不需要具体类的类名</li><li>在系统增加新的对象时，我们只需要添加一个具体实现类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次增加一个对象时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式完全符合“开闭原则”。</li><li>工厂方法模式使用继承，将对象的创建交给子类，通过子类实现工厂方法来创建对象。</li><li>工厂方法让子类决定要实例化的类是哪一个。</li><li>在工厂方法模式中，创建者通常会包含依赖于抽象产品的代码，而这些抽象产品是、由子类创建的，创建者不需要真的知道在制作哪种具体产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（三）简单工厂模式</title>
      <link href="/designPattern/designPattern3/"/>
      <url>/designPattern/designPattern3/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>简单工厂模式又称之为静态工厂方法(Static Factory Method), 属于创建型模式。简单工厂模式是根据传递的参数不同, 返回不同实现类的实例对象.（这些类都依赖一个父类或接口） </p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看简单工厂模式的组成"><a href="#我们先简单的来看看简单工厂模式的组成" class="headerlink" title="我们先简单的来看看简单工厂模式的组成:"></a>我们先简单的来看看简单工厂模式的组成:</h3><blockquote><ol><li>工厂类角色(Factory): 工厂类是工厂模式的最重要的组成部分. 向外提供一个创建方法,该方法会根据传递的参数来返回对应的实现类的实例对象。</li><li>抽象产品角色(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现角色(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    car = <span class="keyword">new</span> RedCar();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象Car类"><a href="#抽象Car类" class="headerlink" title="抽象Car类"></a>抽象Car类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> RedCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Car实现类"><a href="#Car实现类" class="headerlink" title="Car实现类"></a>Car实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"red car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 黑色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"black car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>明确了各自的职责和权利，有利于整个软件体系结构的优化</li><li>使用方无须知道创建类的过程,只需要提供对应的参数即可.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于工厂集中了所有对象的创建逻辑,一旦工厂出了问题,就会导致整个系统受到影响.</li><li>系统扩展受限,一旦添加新的对象就需要修改工厂逻辑,在对象类型过多时,势必会导致工厂逻辑过于复杂和臃肿,不利于系统的扩展和维护</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>简单工厂的好处就在于你需要什么,只需要传递一个规则内的参数,就可以获取到所需要的对象.</li><li>简单工厂的核心理念就是把对象的创建和对象的使用分离开来.为此当对象类型过多时势必会导致创建环节的臃肿</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（二）单例模式</title>
      <link href="/designPattern/designPattern2/"/>
      <url>/designPattern/designPattern2/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序在运行时，通常都会生成很多实例。例如，表示字符串的 String 类的实例与字符串是一一对应的关系，所以当有 1000 个字符串的时候，会生成 1000 个实例。</p><p>但是，当我们想在程序中表示某个东西只会存在一个时，就会有“只能创建-一个实例”的需求。典型的例子有表示程序所运行于的那台计算机的类、表示软件系统相关设置的类，以及表示视窗系统（window system）的类。<br>当然，只要我们在编写程序时多加注意，确保只调用一次 new MyClass（），就可以达到只生成一个实例的目的。但是，如果我们不想“必须多加注意才能确保生成一个实例”，而是要达到如下目的时，应当怎么做呢？</p><ul><li>想确保任何情况下都绝对只有 1 个实例</li><li>想在程序上表现出“只存在一个实例”</li></ul><p>像这样的确保只生成-一个实例的模式被称作 Singleton 模式。Singleton 是指只含有一个元素的集合。因为本模式只能生成一个实例，因此以 Singleton 命名。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>众所周知,一个类的实例对象产生是通过构造函数来完成的. 因此如果不想让外界随意新建对象的话我们可以通过把构造函数私有化. 当然为了让类保证可用, 就需要自己提供一个可以返回自己的实例对象的通道, 一般我们使用静态方法来暴露实例对象.</p><p>实现单例模式的方式有很多种,不同的方式都有不同的优缺点,下面我们就来一一讲解:</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--饿汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的单例实现,一般称之为饿汉式.为何叫饿汉式,这个比喻很形象,可以看出上面的对象其实在类第一次被加载后就被创建了.这样有个好处就是避免了线程安全问题.但是这样另外一个问题,因为对象实在类被第一次加载后就被创建了,可能会造成不必要的消耗,因为有可能这个实力不会被用到.基于这个原因从而引出另一个实现方式: <code>懒汉式</code>,下面我们来看看:</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象被使用时才初始化</span></span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">             lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式就叫做懒汉式。懒汉，顾名思义就是不会提前把实例对象创建出来，而是将创建的动作放在了第一次使用的时候.</p><p>但是,仔细一看就会发现上面的实现方式存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时需要使用此对象,从而存在同时进入if语句中，最后在两个线程执行完方法后创建了两个不同的对象. 针对这个问题, 我们尝试做出如下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 私有构造</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> lazy;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过修改之后,我们发现可以通过加锁的方式来解决了线程同步的问题.</p><p>但是熟悉Java内存模式的同学会发现还是会存在潜在的危险.</p><blockquote><p>在J2SE1.5版本之前使用双重锁检查时会有潜在的危险,有时会正常工作,有时候会因为线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。此问题在J2SE 5.0中被处理了.我们可以通过volatile关键字来处理</p></blockquote><p>我们只需要在我们声明的对象上加上<code>volatile</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy lazy;</span><br></pre></td></tr></table></figure><p>好了,到此关于线程安全的问题我们解决了.</p><p>现在我们再来考虑一个问题, 做过java的同学,想必对反射和序列化不陌生.为什么在这里提这两个呢? 因为这两个可能会破坏我们的单例.(具体什么原因,后面我会有详细的文章介绍).针对这个问题我们可以做出如下修改就可以解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我们只需要在单例类里定义此方法就能解决</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">       return lazy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式（一）设计模式基本概念</title>
      <link href="/designPattern/designPattern1/"/>
      <url>/designPattern/designPattern1/</url>
      
        <content type="html"><![CDATA[<h2 id="软件设计模式的概念"><a href="#软件设计模式的概念" class="headerlink" title="软件设计模式的概念"></a>软件设计模式的概念</h2><p>软件设计模式（ Software Design Pattern ），又称设计模式， 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h2 id="软件设计模式的基本要素"><a href="#软件设计模式的基本要素" class="headerlink" title="软件设计模式的基本要素"></a>软件设计模式的基本要素</h2><p>软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基 本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下4个主要部分。</p><h3 id="1-模式名称"><a href="#1-模式名称" class="headerlink" title="1. 模式名称"></a>1. 模式名称</h3><p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（ Pattern Name ）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><p>问题（ Problem ）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>模式问题的解决方案（ Solution ）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现 ，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。</p><h3 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h3><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空 间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（ Consequence ）对理解和评价这些模式有很大的帮助。</p><h2 id="GoF-的-23-种设计模式简介"><a href="#GoF-的-23-种设计模式简介" class="headerlink" title="GoF 的 23 种设计模式简介"></a>GoF 的 23 种设计模式简介</h2><p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p><h3 id="根据目的来分"><a href="#根据目的来分" class="headerlink" title="根据目的来分"></a>根据目的来分</h3><p>根据模式是用来完成什么工作来划分， 这种方式可分为创建型模式、结构型模式和行为型模 式 3 种。</p><h4 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1.创建型模式"></a>1.创建型模式</h4><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离“。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p><h4 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2.结构型模式"></a>2.结构型模式</h4><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p><h4 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h4><p>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。 GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p><h3 id="根据作用范围来分"><a href="#根据作用范围来分" class="headerlink" title="根据作用范围来分"></a>根据作用范围来分</h3><p>根据模式是主要用于类上还是主要用于对象上来分 ， 这种方式可分为类模式和对象模式两种。</p><h4 id="1-类模式"><a href="#1-类模式" class="headerlink" title="1. 类模式"></a>1. 类模式</h4><p>用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF 中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</p><h4 id="2-对象模式"><a href="#2-对象模式" class="headerlink" title="2. 对象模式"></a>2. 对象模式</h4><p>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。 GoF 中除了以上 4 种，其他的都是对象模式。</p><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>（类）适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例 原型 抽象工厂 建造者</td><td>代理 （对象）适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><h2 id="GoF-的-23-种设计模式的功能"><a href="#GoF-的-23-种设计模式的功能" class="headerlink" title="GoF 的 23 种设计模式的功能"></a>GoF 的 23 种设计模式的功能</h2><p>前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p><ul><li><p>单例（ Singleton ）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p></li><li><p>原型（ Prototype ）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p></li><li><p>工厂方法（ Facto可 Method ）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p></li><li><p>抽象工厂（ Abstract Factory ）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p></li><li><p>建造者（ Builder ）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p></li><li><p>代理（ Proxy ）模式：为某对象提供一种代理以控制对该对象的访问。 即客户端通过代理间 接地访问该对象 ， 从而限制、增强或修改该对象的一些特性。 </p></li><li><p>适配器（ Adapter ）模式： 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 </p></li><li><p>桥接（ Bridge ）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的相合度。 </p></li><li><p>装饰（ Decorator ）模式：动态的给对象增加一些职责，即增加其额外的功能。 </p></li><li><p>外观（ Facade ）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 </p></li><li><p>享元（ Flyweight ）模式：运用共享技术来有效地支持大量细粒度对象的复用。 </p></li><li><p>组合（ Composite ）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 </p></li><li><p>模板方法（ Template Method ）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></li><li><p>策略（ Strategy ）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户 。 </p></li><li><p>命令（ Command ）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 </p></li><li><p>职责链（ Chain of Responsibility ）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 </p></li><li><p>状态（ State ）模式：允许一个对象在其内部状态发生改变时改变其行为能力 。 </p></li><li><p>观察者（ Observer ）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为 。 </p></li><li><p>中介者（ Mediator ）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的相合度，使原有对象之间不必相互了解。 </p></li><li><p>迭代器（ Iterator ）模式：提供一种方法来顺序访问聚合对象中的一系列数据 ，而不暴露聚合对象的内部表示。</p></li><li><p>访问者（ Visitor ）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 </p></li><li><p>备忘录（ Memento ）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 </p></li><li><p>解释器（ Interpreter ）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p></li></ul><blockquote><p>这里必须强调一点，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式</p></blockquote><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据以下 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="开闭原则的定义"><a href="#开闭原则的定义" class="headerlink" title="开闭原则的定义"></a>开闭原则的定义</h4><p>开闭原则（ Open Closed Principle，OCP ）是由勃兰特·梅耶（ Bertrand Meyer ）提出，他在 1988 年的著作《面向对象软件构造》中提出：软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义</p><p>这里的软件实体包括以下几个部分： </p><ul><li>项目中划分出的模块</li><li>类与接口</li><li>方法 </li></ul><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h4 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h4><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具 备稳定性和延续性。具体来说，其作用如下。</p><ul><li><p>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试 代码仍然能够正常运行。</p></li><li><p>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高 代码的可复用性。</p></li><li><p>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p></li></ul><h4 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一 个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。因为抽象灵活性好， 适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><h3 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h3><h4 id="里氏替换原则的定义"><a href="#里氏替换原则的定义" class="headerlink" title="里氏替换原则的定义"></a>里氏替换原则的定义</h4><p>里氏替换原则（ Liskov Substitution Principle, LSP ）由麻省理工学院计算机科学实验室的里斯科夫（ Liskov ）女士在 1987 年的“面向对象技术的高峰会议”（ OOPSLA ）上发表的一篇文章《数据抽象和层次》（ Data Abstraction and Hierarchy ）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应 该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h4 id="里式替换原则的作用"><a href="#里式替换原则的作用" class="headerlink" title="里式替换原则的作用"></a>里式替换原则的作用</h4><p>里氏替换原则的主要作用有以下几点：</p><ul><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li></ul><h4 id="里式替换原则的实现方法"><a href="#里式替换原则的实现方法" class="headerlink" title="里式替换原则的实现方法"></a>里式替换原则的实现方法</h4><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><h4 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h4><p>依赖倒置原则（ Dependence Inversion Principle , DIP ）是 Object Mentor 公司总裁罗伯特·马丁 ( Robert C. Martin ）于 1996 年在 C++ Report 上发表的文章。其原始定义是：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。由于在 软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h4 id="依赖倒置原则的作用"><a href="#依赖倒置原则的作用" class="headerlink" title="依赖倒置原则的作用"></a>依赖倒置原则的作用</h4><p>依赖倒置原则的主要作用有以下几点：</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h4 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h4><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只 要遵循以下 4 点，就能在项目中满足这个规则 。</p><ul><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。 </li><li>使用继承时尽量遵循里氏替换原则 。</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h4><p>单一职责原则（ Single Responsibility Principle, SRP ）又称单一功能原则，由罗伯特·C.马丁（ Robert C. Martin ）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： </p><ul><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； </li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ul><h4 id="单一职责原则的优点"><a href="#单一职责原则的优点" class="headerlink" title="单一职责原则的优点"></a>单一职责原则的优点</h4><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责 原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 </li><li>提高类的可读性。复杂性降低，自然其可读性会提高。 </li><li>提高系统的可维护性。可读性提高，那自然更容易维护了 。 </li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时， 可以显著降低对其他功能的影响。</li></ul><h4 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h4><p>单一职责原则是最简单但又最难运用的原则， 需要设计人员发现类的不同职责并将其分离 ， 再 封装到不同的类或模块中 。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构 经验。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><h4 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h4><p>接口隔离原则（ Interface Segregation Principle , ISP ）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。2002 年罗伯特·c.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上。两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： </p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离；</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h4><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：</p><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活 性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成 接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的 定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个 接口的时候，被迫设计冗余的代码。</li></ul><h4 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h4><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量:</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准 就不同，深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="迪米特法则的定义"><a href="#迪米特法则的定义" class="headerlink" title="迪米特法则的定义"></a>迪米特法则的定义</h4><p>迪米特法则（ Law of Demeter，LoD ）又叫作最少知识原则（ Least Knowledge Principle, LKP ), 产生于 1987 年美国东北大学（ Northeastern University ）的一个名为迪米特（ Demeter ）的研究项目，由伊恩·荷兰（ Ian Holland ）提出 ， 被 UML 创始者之一的布奇（ Booch ）普及，后来又因为在经典著作《程序员修炼之道》提及而广为人知。</p><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的相合度，提高模块的相对独立性。</p><p>迪米特法则中的 “朋友” 是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h4 id="迪米特法则的优点"><a href="#迪米特法则的优点" class="headerlink" title="迪米特法则的优点"></a>迪米特法则的优点</h4><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：</p><ul><li>降低了类之间的相合度，提高了模块的相对独立性。</li><li>由于相合度降低，从而提高了类的可复用率和系统的扩展性。</li></ul><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间 的通信效率降低。所以，在采用迪米特法则时需要反复权衡，确保高内聚和低相合的同时，保证系统的结构清晰。</p><h4 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h4><p>从迪米特法则的定义和特点可知，它强调以下两点：从依赖者的角度来说，只依赖应该依赖的对象。从被依赖者的角度说，只暴露应该暴露的方法。所以，在运用迪米特法则时要注意以下 6 点:</p><ul><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。 </li><li>在对其他类的引用上，将引用其他对象的次数降到最低。 </li><li>不暴露类的属性成员，而应该提供相应的访问器（ set 和 get 方法）。</li><li>谨慎使用序列化（ Serializable ）功能。</li></ul><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><h4 id="合成复用原则的定义"><a href="#合成复用原则的定义" class="headerlink" title="合成复用原则的定义"></a>合成复用原则的定义</h4><p>合成复用原则（ Composite Reuse Principle, CRP ）又叫组合／聚合复用原则（ Composition/Aggregate Reuse Principle, CARP。 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏代换原则。合成复用原则同里氏代换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h4 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h4><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它 也存在以下缺点:</p><ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行 时不可能发生变化。</li></ul><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点:</p><ul><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口 。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ul><h4 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h4><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可 以调用己有对象的功能，从而达到复用。</p><h3 id="七种设计原则的要点"><a href="#七种设计原则的要点" class="headerlink" title="七种设计原则的要点"></a>七种设计原则的要点</h3><p>上面介绍了 7 种设计原则，它们是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
